.. 翻译约定(*表示认为不需要添加到convention.rst中的条目):
.. barcode -> 条形码 
.. number system -> 码制
.. number authority -> 编码规范机构
.. parity digit / parity bit -> 校验数字
.. guard sequence -> 保护序列
.. constant-time -> 常数时间
.. bound -> 边界
.. type synonym -> 类型别名
.. pivot value -> 枢轴值
.. run length -> 游程
.. list comprehension -> 列表推导式
.. guard -> ??? (list comprehension中提到)
.. generator expression -> 生成器表达式
.. local variable -> 本地变量
.. hash tbale -> 散列表
.. guard reduce -> ??? (tree的部分中提到)
.. left biased -> 左偏的
.. solution map -> ??? (并行求解校验数字部分提到)
.. checksum -> 校验和


.. 1. https://en.wikipedia.org/wiki/International_Article_Number_(EAN)
.. 2. http://www.barcodeisland.com/ean13.phtml
.. 3. https://en.wikipedia.org/wiki/Global_Trade_Item_Number
.. 4. http://www.gs1.org/sites/default/files/docs/barcodes/GS1_General_Specifications.pdf
.. 5. http://www.gs1.org/about/how-we-got-here
.. 6. http://www.barcodingfonts.com/pdf/EAN.pdf


.. _barcode-recongnition:

第十二章：条形码识别
=============================

本章我们将用第十章开发的图像分析库来制作一个条形码识别应用。只要用手机的摄像头拍下书的封底，我们就能用这个程序来提取这本书的ISBN编号。

.. _a-little-bit-about-barcodes:

条形码简介
---------------

.. FIXME: 在参考文档[1]和[2]中，在引用EAN-13这个名词的时候所采用的类别(standard/system)看起来都很随意，即这两个词可以省略，也可以任选其一使用，但是也无法确定这两个词作为EAN-13的后缀是否等价。为了避免过分的咬文嚼字，在翻译本章节的时候暂时将这两个词翻译为最常见的译法(即：standard->标准，system->系统)，并在原文没有使用这两个词的时候省略之。

.. FIXME: 最后一小句，while EAN-13 is European in origin，其中的European应该是指欧洲(并没有译为欧盟)，虽然没查到EAN-13的具体历史，但欧盟成立的时间(1991.12马约通过，1993.11马约开始生效)应该至少是远晚于EAN Association(即现在的GS1，成立于1977年，考自[5])的。

市售绝大多数带有外包装的量产消费品上都有一个条形码。尽管有很多种不同的条形码系统在多个专业领域中被使用，但是在消费品中最典型的条形码系统还是UPC-A和EAN-13两种。UPC-A由美国开发，而EAN-13最初由欧洲开发。


.. FIXME: This neatly reduces our descriptive problem to one standard.意译了一下，可能不是很精确

EAN-13发表于UPC-A之后，它是UPC-A的超集。（事实上，UPC-A在2005年就已经由官方声明作废了，尽管它在美国依然被广泛使用。)任何可以识别EAN-13条形码的硬件都可以兼容UPC-A条形码。这种兼容性一下子就让我们可以少介绍一种标准。

.. FIXME/TODO: 根据[1]中内容所述，下文所描述的四个部分的语义并不包含在EAN-13标准中，而是属于Global Trade Item Number(GTIN)标准的范畴，。二者的标准都可在[5]中找到。EAN-13，GTIN-13之间的关系应该是：由EAN-13标准规定，被编码为该规范所描述的条形码的数字必须是按照GTIN-13规范编码而成的13个数字。这部分内容如果过早的作为译注出现可能会让读者在理解上更为混乱，因此暂时不添加。

正如其名字所暗示的，EAN-13描述了一个由十三个数字组成的序列，该序列可以分为四组：

[译注：需要注意的是，在条形码编码中，这四个部分并不是按照下文描述的顺序排列的]

.. FIXME: ...describe one of a few other categories，不确定这个categories的所属是条码还是(GTIN)编码。
.. FIXME: 此处为了便于理解categories一词，应该至少再多列举一个category的例子(最好在标注上实际的编号)，比如ISMN(979，与ISBN共用)，ISSN(977)。上述两例来自[1]。

- 最前的两个数字描述了条形码采用的 *码制* 。这两位数字可以标识生产商所在国家, 或者描述该条码的类别，比方说ISBN(国际标准书号)。

.. 以下内容来自[2]

[译注：确切的讲，此处的“生产商的国籍”实际上是指“为该生产商签发生产商代码的编码管理局所属国家”]
[译注：事实上，码制的长度可能为两个数字或者三个数字，例如某条形码所编码的内容是ISBN码的话，那么它的码制部分应该为978(后文中给出的实际图中也可以看到)]

.. FIXME: numbering authority翻译为“编码规范机构”，该译法取自中文网络上某新闻中对DONA的解释(数字对象编码规范机构)。

- 接下来的五个数字为厂商代码，由各国的编码规范机构签发。

- 再接下来的5个数字是产品代码，由生产厂商决定。(规模较小的生产商可能会使用较长的生产商ID和较短的产品ID，但是两个ID加起总是10个数字。)

- 最后一个数字为 *校验数字* ，扫描设备可以通过它来校验扫描到的数字串。


EAN-13条形码与UPC-A条形码的唯一不同在于后者只用一位数字表示码制。EAN-13条形码通过将码制的第一位数字置零实现对UPC-A的兼容。

.. _ean-13-encoding:

EAN-13编码
^^^^^^^^^^^^^^^

.. FIXME: “此处的system”译为了“规则”，如果直译为“系统”的话则有一种“引用了某种既存的通用编码模式”的感觉(就好像博德之门与DND的关系)，当然我不确定是否事实就是如此。

.. FIXME: 原文此处给出的代码有错误，因为其结果可能为“10”，而校验数字只有一位，一次代码的逻辑显然是错误的。而且为了绕开关于“负数module运算的”结果符号的考据以及可能带来的疑惑，修改为了一个比较直接的实现

在我们考虑怎样解码EAN-13条形码之前，我们需要先了解它是怎样被编码出来的。EAN-13采用的编码规则有一点复杂。我们先从计算校验数字——即数字串的最后一位开始。

.. literalinclude:: /code/ch12/checkDigit.hs

这个算法相比其他算法更容易通过代码理解，而不是靠字面描述。计算从串的最右侧开始。对于每个连续的数字，交替采用“乘以3”和“保持原状”的方式处理( ``cycle`` 函数将输入列表转换为不断重复自身的无限列表)。对处理后的序列求和，然后用10减去这个和对10取模的，就得到了校验数字。

.. FIXME: bar这个词个人感觉比较恰当的译法是“竖线”，但无论哪种译法，对“白色的部分也是bar”这个概念都不太友好，最后选择将所有的bar都当作后文某处用到的stripe处理，即“条纹”(虽然这个又隐含了“可能不直”的意思)。

条形码是一系列定宽的条纹，其中黑色的部分表示二进制的“1”，白色的部分表示二进制的“0”。连续的相同二进制值看起来就像是宽一些的条纹。

条形码中的各个二进制位的顺序如下：

.. FIXME: guard sequence译为“保护序列”

- 头部保护序列，固定编码101。

- 一个由六个数字组成的分组，其中每个数字由7个二进制位表示

- 另一个保护序列，固定编码01010

.. FIXME: 此处添加了一个译注

- 另一个六个数字的组成的分组(译注：每个数字也由7个二进制位表示)

- 尾部保护序列，固定编码101

.. FIXME: 本文中，对于parity bit和parity digit的翻译并未进行区分，都译为“校验数字”。

左右两个分组有不同的编码方式。左侧分组中隐含了校验数字的编码，校验数字即条形码的第13个数字。

[译注：你可能好奇为什么编码10个数字需要用7个二进制位。事实上，七个二进制位的128种组合中，只有30种在条形码中是合法的。很快就可以看到，在条形码中编码一个数字需要去“查表”而不是算]

.. _introducing-arrays:

引入数组
-------------

在我们继续前，先来看看我们在本章接下来会用到的所有导入模块。

.. literalinclude:: /code/ch12/imports.hs

.. FIXME: 最后一句从句太长而且翻译腔很重
.. FIXME: table译为表而不是表格，“表格”这种译法显得很excel...

条形码的编码过程基本上可以采用表驱动的形式实现，即采用记录了位模式的小规模表来决定如何为每个位进行编码。Haskell中的基本数据类型——列表和元组——都不太适合构造这种可能涉及随机访问的表。列表需要线性遍历才能访问到第k个元素。元组没有这个问题，但是Haskell的类型系统使我们很难编写一个接受元组和偏移量，返回该元组内指定偏移元素的函数。(我们会在下面的练习中探究为什么这很难。)

.. FIXME: 最后两句并为了一句(逗号)

那么说起常见的支持常数时间随机访问的数据结构，数组(array)自然首当其冲。Haskell提供了数种数组数据类型，我们可以利用它们将编码表表示为数字串构成的数组。

.. FIXME: populated with译为了“填充”

最简单的数组类型位于 ``Data.Array`` 模块，它正是我们要在这里用到的类型。该类型可以表示由任何Haskell类型的值构成的数组。与普通的Haskell类型一样，该类型的数组都是不可变的。不可变的数组的值只能在它被创建的时候填充一次，之后它的内容就无法被修改了。(标准库也提供了其他的数组类型，其中有一部分是可变的，但我们暂时还不会涉及到它们。)

.. literalinclude:: /code/ch12/leftOddList.hs

.. FIXME/TODO: bounds译为边界，实际为“索引的边界”，可以考虑加一个译注

Data.Array模块中的listArray函数使用列表来填充数组。第一个参数是数组的边界，第二个参数是用来填充数组的列表。

.. FIXME: parameterized over并没有采用“参数化为...”这种译法，因为很别扭，但是似乎“parameterized”这种术语又需要把字面意思交代一次的样子。

数组有一个独特的性质，它的类型由它所包含数据的类型以及索引的类型共同确定。举例来说，String组成的一维数组的类型为Array Int String，但是二维String数组的类型则是Array (Int, Int) String。

::

	ghci> :m +Data.Array
	ghci> :type listArray
	listArray :: (Ix i) => (i, i) -> [e] -> Array i e

创建数组很简单。

::

	ghci> listArray (0,2) "foo"
	array (0,2) [(0,'f'),(1,'o'),(2,'o')]

.. FIXME: 此处的inclusive找不到明确的统一译法，暂时使用了不严格的相似概念“闭区间”(closed interval，根据wiki，这个词似乎与inclusive interval等价), 
.. FIXME: 第二句强调的是“闭区间”这个事实，所以只给出了实际的元素数目。况且elements 0, 1, 2强行翻译出来也不很自然。

注意，我们必须在构造数组时显式指定数组的边界。数组边界是闭区间，所以一个边界为0和2的数组包含3个元素。

::

	ghci> listArray (0,3) [True,False,False,True,False]
	array (0,3) [(0,True),(1,False),(2,False),(3,True)]
	ghci> listArray (0,10) "too short"
	array (0,10) [(0,'t'),(1,'o'),(2,'o'),(3,' '),(4,'s'),(5,'h'),(6,'o'),(7,'r'),(8,'t'),(9,*** Exception: (Array.!): undefined array element

Once an array is constructed, we can use the (!) operator to access its elements by index.

数组造完成后，我们就可以借助(!)运算符通过索引访问元素了。

::

	ghci> let a = listArray (0,14) ['a'..]
	ghci> a ! 2
	'c'
	ghci> a ! 100
	*** Exception: Error in array index

.. FIXME: convenient for our purpose翻译为“易用的值”太突兀了，就忽略掉了。

由于数组构造函数允许我们指定数组的边界，因此我们就没必要像C程序员一样必须用从0开始的索引值了。我们可以选用任意值作为数组的边界。

::

	ghci> let a = listArray (-9,5) ['a'..]
	ghci> a ! (-2)
	'h'

索引值的类型可以为 ``Ix`` 类型的任意成员。也就是说我们就可以用像 ``Char`` 这种类型作为数组的索引类型。

::

	ghci> let a = listArray ('a', 'h') [97..]
	ghci> a ! 'e'
	101

如需创建多维数组，可以用 ``Ix`` 实例组成的元组来作为数组的索引类型。

::

	ghci> let a = listArray ((0,0,0), (9,9,9)) [0..]
	ghci> a ! (4,3,7)
	437

.. _arrays-and-laziness:

数组与惰性
^^^^^^^^^^^^^^^

用来填充数组的列表必须包含至少与数组容量相等数量的元素。如果列表中没有提供足够多的元素，那么程序在运行时就可能发生错误。这个错误发生的时机取决于数组的性质。

.. FIXME: elements will undefined似乎应该是指不足的数组元素的值不能确定，也可能是指“在构造完成后，被轮空的数组元素不知道会发生什么(例如数组可能会被截短?(当然这是一种不靠谱的假设))”，因为原文不是remaining elements will "be" undefined. 目前采用了直译，比较模糊，有待推敲。

.. FIXME: specify as containing more than three elements似乎应该翻译成“容量大于3”会比较自然，但是有一种“数组是mutable的”的味道，所以还是采用接近直译的译法。

我们这里用到的数组类型对数组的元素采用非严格求值。如果我们想把一个三个元素的列表填充到给一个多于三个元素的数组中，其余的元素将是未定义的。但是只有我们试图访问超过第三个元素的时候才会得到一个错误。


::

	ghci> let a = listArray (0,5) "bar"
	ghci> a ! 2
	'r'
	ghci> a ! 4
	*** Exception: (Array.!): undefined array element

.. FIXME: bottom (type)保留了原文，未找到公认的译法。
.. FIXME: 原文在最后一句We will discuss the tradeoffs between...中的tradeoff一词，如果翻译为权衡的话是很别扭的，因为根据语境，这个tradeoff的对象应该是两种array不同性质带来的不同适用场景，而此处看起来更像是“用户”需要在array的使用上“抉择”。
.. TODO: unsolved hyperlink ref

Haskell也提供了严格求值的数组，它们会在上述情景中会有不同的行为。我们将在“拆箱，抬举，和bottom”一章中讨论两种数组之间的权衡。

.. _folding-over-arrays:

数组的折叠
^^^^^^^^^^^^^^^^^^^


``bounds`` 函数返回在创建数组时指定的边界组成的元组。 ``indices`` 函数返回数组中各个索引值组成的列表。我们可以用它们来定义实用的折叠函数，因为 ``Data.Array`` 模块并没有定义用于数组的折叠函数。

.. literalinclude:: /code/ch12/foldA.hs

你可能很好奇为什么数组模块不预置像折叠函数这么有用的工具函数。我们会发现一维数组和列表之间有一些明显的相似性。例如，都只有两种自然的方式来折叠他们：从左向右折叠或者从右向左折叠。此外，每次都只能折叠一个元素。

上述这些相似性对于二维数组就已经不再成立了。首先，在二维数组上有意义的折叠方式有很多种。我们也许仍然想要逐个元素地进行折叠，但是对二维数组，还可以逐行折叠或者逐列折叠。其次，就算同样是逐个元素折叠，在二维数组中也不再是只有两种遍历方式了。

换句话讲，对于二维数组来说，可以进行的有意义操作太多了，可也没什么足够的理由值得选取其中一部分添加到标准库。这个问题只存在于多维数组，所以最好还是让开发人员自己编写适用于自己应用的折叠函数。从上面的例子也可以看出，这其实没什么难度。

.. _modifying-array-elements:

修改数组元素
^^^^^^^^^^^^^^^^^

尽管有针对不可变数组的“修改”函数，但这些函数并不怎么实用。以 ``accum`` 函数为例： ``accum`` 函数接受一个数组和一个(索引，元素值)对构成的列表，返回一个在所有指定索引值的位置替换为对应值的新数组。

.. FIXME: 这个“quickly”直接翻译成了“很快”，有点不知所云，但是如果不加上一个类似的词形容这个开销的巨大，后面的半句就显得多余了。

由于数组是不可变的，那么就算只是修改一个元素，都需要拷贝整个数组。这个开销很快就会变得难以承受，哪怕是对于中等规模的数组来说也是如此。

Data.Array.Diff模块中的另一个数组类型DiffArray，尝试通过保存数组的连续版本之间的变化量来减少小规模修改造成的开销。遗憾的是，在编写本书的时候它的实现还不是很高效，对于实际应用来说，它还是太慢了。

.. note::
	不要丧气

	事实上在Haskell中想要高效地修改数组是可能的，使用 ``ST``  monad即可。我们以后会在第二十六章中讨论这个话题。 

习题
^^^^^^^^^^^^^^^^^

让我们简单的探索一下用元组替代数组的可行性

1. 编写一个函数，它接受如下两个参数：一个由4个元素组成的元组和一个整数。整数参数为0的时候，该函数应返回元组中最左侧的元素。整数参数为1的时候，返回后一个元素，依此类推。为了使该函数能通过类型检查，你需要对参数的类型做怎样的限制？

2. 写一个与上面类似的函数，第一个参数改为6个元素组成的元组。

3. 尝试重构上面的两个函数，让它们共用尽可能多的代码。你能找到多少可以共用的代码？

.. _encoding-an-ean-13-barcode:

生成EAN-13条形码
----------------------

尽管我们的目标是解析条形码，但如果能有一个编码器做参考还是很方便的。这样我们就可以——比方说——通过检查解码后编码的结果与输入是否一致来验证我们代码的逻辑是否正确。

.. literalinclude:: /code/ch12/encodeEAN13.hs

[译注：上面的代码中"where (left, right) = splitAt 6 rest", 在原文中写为了"where (left, right) = splitAt 5 rest"， 这是错误的，因为左侧分组有最后一个数字会被分到右侧分组中。]

输入编码器的串有12个数字，然后由 ``encodeDigits`` 函数添加第13个数字，即校验数字。

条形码被编码为两组，每组各6个数字，两个分组的中间和“外侧”各有一个保护序列。现在两组各6个数字都齐了，缺少的那一个数字该怎么办？

左侧分组中的每个数字都使用奇校验(odd parity)或偶校验(even parity)进行编码，使用的校验方式取决于数字串中的第一个数字的二进制表示。如果第一个数字中某一位为0，则左侧分组中对应位置的数字采用奇校验编码，该位为1，则该对应数字采用偶校验编码。这是一种优雅的设计，它使EAN-13条形码能向前兼容老式的UPC-A标准。

.. _constraints-on-our-decoder:

.. FIXME: 为了表达“为了方便而故意简化功能”的意向，将constraint译为约束似乎不太合适。

对解码器的约束
---------------------

在讨论如何解码之前，我们先对可处理的条形码图片的种类做一些一些实际约束。

手机摄像头和网络摄像头通常生成JPEG图像，但是要写一个JPEG的解码器还要用几章的篇幅，因此我们将图片的解析工作简化为只需要处理netpbm文件格式。这之中我们将会用到第十章中开发的分析组合子。

.. FIXME: 最后一句太啰嗦
.. FIXME: real image并没有译出来，此处的real是否是强调图像来自对实景的拍摄而不是来自“反拍”之类的方式？
.. FIXME: real book此处译为了实体书(就是说“不是反拍出来的条形码”之类的)。

我们希望这个解码器能处理来自低端手机上的那种劣质的定焦摄像头拍摄出来的图像。这些图像大多丢焦严重、噪点多、对比度低，分辨率也很低。幸运的是，通过代码处理噪点、丢焦、对比度低的VGA分辨率(640x480)图像并不是很难。我们已经实际验证过本章中的代码，保证它能够识别用货真价实的中低端摄像头拍摄出的实体书上的条形码。


.. FIXME: “糊到一起”有点口语化，不过应该是可用的译法

我们会绕过所有的涉及图像处理的复杂内容，因为那又是一个需要整章篇幅来介绍的课题。我们不会去校正拍摄角度，也不会去锐化由于拍摄距离过近导致较窄的条纹模糊不清，或者是拍摄距离过远导致相邻的条纹都糊到一起的图像。

.. image:: /image/ch12/ch12-bad-angled.jpg

.. image:: /image/ch12/ch12-bad-too-near.jpg

.. image:: /image/ch12/ch12-bad-too-far.jpg

[译注：上面三幅图分别展示了非正对条形码拍摄、拍摄距离过近、拍摄距离过远的情况]

.. _divide-and-conquer:

分而治之
----------------

我们的任务是从摄像头拍摄的图像中提取出有效的条形码。这个描述不是特别明确，我们很难规划如何一步步展开行动。然而，我们可以把一个大问题拆分为一系列的独立的容易解决的子问题，然后逐个击破。

- 将颜色数据转换为易于使用的形式

- 从图像中取单一扫描线，并根据该扫描线猜测这一行可能是哪些数字的编码

- 根据上面的猜测，生成一系列有效解码结果。

我们接下来会看到，上述的子问题中有些可以进一步分解。

在编写本章给出的代码时你可能会问，这种分而治之的实现方式与最终的目标吻合程度有多高呢？答案是——我们远不是什么图像处理方面的专家，因此在开始撰写这一章的时候我们也不是很确定最终的解决方案会是什么样子。

.. FIXME: 最后一句有待推敲，很不自然，意思也可能不精确。

关于到底什么样的方案才是可行的，我们在早期也做了一些合理的猜测，最后就得到了上面给出的子任务列表。接下来我们就可以开始着手于那些知道如何解决的部分，而在空闲时考虑那些我们没有实际经验的内容。我们当时肯定是不知道有什么既存的算法可用，事先也没有做过什么总体规划。

.. FIXME: psychological advantage(暂且)意译为积极情绪，如果译为“心理优势”，则原文中也没有明确提及比较的对象(也可能对比的对象是“无策略干瞪眼”solution)，容易让人理解为“相对于没有用这种approach的‘人’具有优势”，但很明显本段的这种对比(如果的确有对比的话)应该是approach之间的；另一种考虑是，以psychological这种形容词修饰的词语应该具有较强烈的术语属性，随便意译可能导致词不达意，因此还需要推敲。
.. FIXME: 本段可能需要彻底重新翻译，尤其是最后一句，好像没什么上下文联系。

像这样分解问题有两大优点。首先，通过在熟悉的领域开展实施，可以让人产生“已经开始切实解决问题”的积极情绪，哪怕现在做的以后不见得用得上也是一样。其次，在处理某个子问题时，我们可能会发现可以将它进一步分解为多个我们熟悉解决思路的子问题。我们可以继续专注于其中简单的部分，而把那些还没来得及彻底想通的部分延后，一个一个的处理上面子问题列表中的项。最后，等我们把不熟悉的和未解决的问题都搞定了，我们同时也就对最终解决方案有了完整的认识。

.. _turning-a-colour-image-into-something-tractable:

将彩色图像转换为更容易处理的形式
--------------------------------------

.. FIXME: 结尾处并没有译成“那么最容易处理的就是每个像素都...的黑白图像”，翻译腔弱一些，但是感觉破折号之后的部分直接省略掉是最好的。



这个解码器处理的对象是条形码，而条形码的本质就是连续的黑白条纹序列，而且我们还想让这个解码器尽可能的简单，那么最容易处理的表示形式就是黑白图像——它的每个像素都是非黑即白的。

.. FIXME: 关于译注中的内容，也可能是我想多了。因为拍摄到的条形码不太可能有黑白以外的颜色，而将其处理为其他颜色的monochrome image更是愚蠢到不会予以考虑了。

[译注：原文此处提到的图像是monochrome image(单色图像)，其中monochrome(单色的)一词虽然经常被当作black and white或grayscale的同义词使用(在图像领域)，但实际上这个词表示了“黑白”更广泛的颜色范围，单色图像可选的颜色并不限于黑和白，例如夜视设备生成的图像，它同样是一种单色图像，但是它生成的图像通常采用绿色为前景色。换句话说，黑白图像只是单色图像的一种。详情参见英文维基词条 *monochrome* 。由于本章节中对图像的处理的确是要将图像处理为只有黑白两种颜色像素的图像(也确实不该考虑其他的颜色组合)，因此本章中的monochrome image都译为黑白图像。]

.. _parsing-a-colour-image:

分析彩色图像
^^^^^^^^^^^^^^^^

我们之前说过，我们的解码器将只支持netpbm图像。netpbm彩色图像格式之比我们在第十章中处理的灰度图像格式稍微复杂一点。头部的标识串为“P6”,头部的其余部分都和灰度格式完全一样。在图像文件的主体部分，每个像素都由3个字节表示，三个字节分别描述红、绿、蓝三个分量。

.. FIXME: 本段后最好为“高效取整行”在译注中举一例子

我们将图像数据表示为像素构成的二维数组。为了积累数组的使用经验，此处将完全采用数组实现。但事实上对于这个应用来说，我们用“列表的列表”代替数组也可以。因为数组在这里的优势并不大，只是能让我们方便的提取出一整行罢了。

.. literalinclude:: /code/ch12/typesForImage.hs

我们定义了一些类型的同义词来提高类型签名的可读性。

对于如何设置数组，Haskell为我们提供了相当高的自由度，我们必须维数组选择一种合适的表示形式。我们将采取保守的方案，并遵守一个普遍的约定：索引值从0开始。我们并不需要显式的存储图像的尺寸，因为我们可以用 ``bounds`` 函数从数组直接提取它。

最终的解析器实现相当的简短，这都多亏了我们在第十章中开发的组合子。

.. literalinclude:: /code/ch12/imageParser.hs

.. FIXME: 代码中又“提前”用到了monad，段后的评论区中很多留言觉得这种设置不好(因为需要“学过monad之后再回过头来再这段代码”)，或者至少应在追加一些关于相关内容章节的链接，或者是更普通的做法——为代码添加更详细的注释。

上面的代码中唯一需要注意的是 ``parseTimes`` 函数，它会将一个分析器调用指定的次数，最后构造出一个分析结果组成的列表。

.. _greyscale-conversion:

灰度转换
^^^^^^^^^^^^^

对于一张彩色图像，我们需要将它的色彩数据转换为黑白的形式。其中一个步骤是将色彩信息转换为灰度信息。有一个简单并广泛应用的公式可以将彩色图像转换为灰度图像，该公式基于每个色彩通道的相对亮度来计算灰度信息。

.. literalinclude:: /code/ch12/luminance.hs

.. 代码最后三行写成where [r', g', b'] = map fromIntegral [r, g, b]其实更好(看)。但是对于没有错误的代码都尽量保持了原状。

Haskell中的数组都是 ``Functor`` 类型类的成员，所以我们可以直接用 ``fmap`` 函数一次性将整张图片或者单行扫描线从彩色格式转为灰度格式。

.. literalinclude:: /code/ch12/greyMap.hs

.. FIXME: 应该添加译注，明确一下“实际的pixmapToGreymap输入的对象不是整张图”，所以上面那个函数只是举例子用的。使该段的两句话看上去更相关一些。

上面给出来的 ``pixmapToGreymap`` 函数只是拿来举个例子，因为我们只需要检查图片的部分行来提取可能存在的条形码，也就没必要在之后不会用到的数据上做多余的转换工作了。

.. _greyscale-to-binary-and-type-safety:

灰度二值化和类型安全
^^^^^^^^^^^^^^^^^^^^^^^^^^

接下来要处理的子问题是如何将灰度图像转换为二值图像，其中每个像素都只处于“打开”或“关闭”两种状态之一。

..FIXME: 此处的digit做value译
在一个图像处理程序中通常需要同时处理大量的数值，将同一数值类型用于不同的目的是很方便的。例如，我们只要约定数字1表示一个位处于“打开”状态而0表示一个位处于“关闭”状态，就可以直接使用 ``Pixel`` 类型表示像素的开/关状态。

然而，像这样把同一个数据类型用于不同目的做法有潜在的迷惑性。如果想知道某个特定的 ``Pixel`` 类型的值究竟是代表一个数值还是一个“开”/“关”状态，就不能靠类型签名轻易确定了。在某些上下文中，我们可能很轻易的就使用了错误类型的数值，而且编译器也不会检查到错误，因为这个值的类型与签名指定的类型是吻合的。

我们可以尝试引入类型别名来解决这个问题。和前文中把 ``Pixel`` 声明为 ``Word8`` 的别名一样，我们也可以把 ``Bit`` 类型声明为 ``Pixel`` 类型的别名。这么做虽然可能提高一定的可读性，但类型别名还是不会让编译器替我们做什么有用的工作。

编译器将把Pixel和Bit当做完全相同的类型，所以就算把 ``Pixel`` 类型的值253传给一个接受Bit类型的值(0或1)的函数，编译器也不会报错。

.. FIXME: 此处的monochrome就译成了“单色”而不是“黑白”，因为本节前面以“开/关”状态来表达颜色的描述方式弱化了“monochrome=黑白”这个概念。

如果另外定义一个单色(monochrome)类型，编译器就会阻止我们像上述的例子那样意外混用不同类型。

.. literalinclude:: /code/ch12/monochrome.hs

.. FIXME: pivot value译为了“枢轴值”，其实用更日常的说法来翻译这个词(比如“参考值”)应该更好。

`` threshold`` 函数会计算输入数组中的最大值和最小值，结合参数提供的一个介于0到1之间的阈值，最后计算出一个“枢轴”(pivot)值。对于数组中的每个元素，如果该元素的值小于这个枢轴值，则计算结果为 ``Zero`` ，否则结果为 ``One`` .注意到这里我们用到了一个在“折叠数组”一节中编写的折叠函数。

.. _what-have-we-done-to-our-image:

我们对图像做了哪些处理？
---------------------------

.. FIXME: crop down to译为了“裁剪到...”

让我们暂时回过头来，想一想在我们把图像从彩色转换为黑白的过程中，到底对它做了哪些处理。下面是一张用VGA分辨率摄像头捕获的图像。我	们做的就是把这个图像裁剪到只剩条形码。

.. image:: /image/ch12/ch12-barcode-photo.jpg

.. FIXME: 此处的parity译为了“校验(的)奇偶性”，即“编码采用的“奇校验”/“偶校验”属性”
.. FIXME: 最后一句的“...之一”翻译腔太重了

这之中编码的数字序列，9780132114677，被打印在了条形码的下方。左侧分组编码了数字串780132，9被编码在该组数字所采用的编码的校验奇偶性中。右侧分组编码了数字串114677，其中最后一个7为校验数字。下面是这个条形码的清晰编码，生成自众多提供免费条形码生成服务的网站之一。

.. image:: /image/ch12/ch12-barcode-generated.png

我们从捕获的图像中选择了一个行，为了便于观察，将这一行垂直拉伸。我们把它放在“完美图像”的上方并且做了拉伸让两幅图对齐。

.. image:: /image/ch12/ch12-barcode-example.png

原图中亮度被转换的行用深灰色标出。可以看到这部分图像对比度低且清晰度差，有多处模糊和噪点。浅灰色条来自于同一行，但对比度经过了调整。

.. FIXME: 此处的threshold意译为“二值化”

这两行以下的一小段的显示了对亮度转换过的行进行二值化后的效果。你会注意到有些条纹变得更粗了而有些更细了，有些条纹还稍微左移或者右移了一点。

很明显，任何在包含这些缺陷的图像中进行精确匹配的尝试都不太可能经常成功。我们必须让代码足够健壮以应对过粗、过细或者位置有偏差的线条。线条的宽度取决于摄像头与书的距离，所以我们也不能对它做任何假设。

.. _finding-matching-digits:

寻找匹配的数字
----------------------------

我们首先要解决的是如何在某个 *可能* 编码了数字的位置把这个数字找出来。在此，我们做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的开始点。

.. _run-length-encoding:

.. FIXME: run length译为“游程编码”(来自中文维基)

游程编码
^^^^^^^^^^^^^^^^

我们如何解决线条宽度的问题呢。答案是对图像数据进行游程编码。

.. literalinclude:: /code/ch12/runLength.hs


``group`` 函数会把一个列表中所有连续的相同元素分别放入一个子列表中。

::

    group [1,1,2,3,3,3,3]
    [[1,1],[2],[3,3,3,3]]

我们的 ``runLength`` 函数将每个子列表表示为子列表长度和首个元素组成的对。

::

    ghci> let bits = [0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0]
    ghci> runLength bits
    Loading package array-0.1.0.0 ... linking ... done.
    Loading package containers-0.1.0.1 ... linking ... done.
    Loading package bytestring-0.9.0.1 ... linking ... done.
    [(2,0),(2,1),(2,0),(2,1),(6,0),(4,1),(4,0)]

[译注：上述ghci输出的最后一行的列表中，每一个“长度-值”对就是一个“游程”]

..FIXME: 最后一句不通顺

因为我们进行游程编码的数据只包含0和1，被编码的数字也只在0和1两个值之间变化。因此我们可以只保留长度而忽略被编码的数字，也不会丢失任何有用的信息。

.. literalinclude:: /code/ch12/runLength2.hs

::

    ghci> runLengths bits
    [2,2,2,2,6,4,4]

上面这个例子中的位模式并不是一个随机的值；他们是我们捕获的图像中某一行里面的左侧保护序列和第一个编码数字。如果我们丢弃表示保护序列的线条，游程编码后的值就是[2, 6, 4, 4]。我们怎样在“引入数组”一节中的编码表中找到匹配的位模式呢？

.. _scaling-run-lengths-and-finding-approximate-matches:

.. FIXME: scaling暂时译为“缩放”，缩放一词似乎有很强烈的“图像专用”的性质，但是又找不到更合适的词表示这种“将一系列值同比放大/缩小”的意思。
.. FIXME: run length译为“游程”(来自cnki wiki)

缩放游程，查找合适的匹配
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

一个合理的方法是缩放这些游程编码值，让它们的和为1。我们将使用 ``Ratio Int`` 类型替代一般的 ``Double`` 类型处理这些缩放后的值，因为 ``Ratio`` 值在 **ghci** 的输出中可读性更好，让交互式调试与开发更加方便。

.. literalinclude:: /code/ch12/scale.hs

我们定义了类型别名 ``Score``，这样其余的大部分代码就不需要关心Score底层的类型是什么。我们的代码开发完毕然后准备丢到 **ghci** 里运行的时候，只要我们愿意，我们还是能把“ ``Score`` ”对应的底层类型改为 ``Double`` ，而不需要修改其它代码。

我们可以用 ``scalarToOne`` 函数来缩放我们所要寻找的数字序列。我们解决了拍摄距离所导致的条纹宽度不能确定的问题。现在，在缩放后的游程编码表和从图像中的提取出游程编码序列间应该有十分接近的匹配。

.. FIXME: distance此处译为“差异度”，虽然原文此处使用了引号，但是直译为“距离”还是太别扭了。

接下来的问题是如何将直观感觉上的“十分接近”转化为对“足够接近”的度量。给出两个缩放过的长度序列，我们可以像下面这样计算出一个大概的“差异度”(distance)。

对精确匹配的值求出的差异度将会是0，匹配程度越低这个差异度的值就越大。

::

    ghci> let group = scaleToOne [2,6,4,4]
    ghci> distance group (head leftEvenSRL)
    13%28
    ghci> distance group (head leftOddSRL)
    17%28

对给定的一个经过缩放的游程编码表，我们从中选择与输入序列最接近的几个匹配结果。

.. literalinclude:: /code/ch12/bestScores.hs

.. _list-comprehensions:

.. FIXME: list comprehension译为“列表推导式”(该译法取自Python中的类似概念)

列表推导式
^^^^^^^^^^^^^^^^^

我们在之前的例子中引入的新表示法是 *列表推导式(list comprehension)* 的一个例子，列表推导式可以以一个或多个列表为基础创建新列表。

::

    ghci> [ (a,b) | a <- [1,2], b <- "abc" ]
    [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c')]

.. FIXME: 最后一句中，要使用“依此类推”这种短语，通常应该在前面按实际的“顺序”迭代两次以上，而且最好取三个元素。现在这样只举了起始的情况，看上去有点奇怪。

竖线右侧的每一个 *生成器表达式(generator expression)* 组合，都会代入到竖线左侧的表达式中求值。生成表达式绑定了左侧的变量a，a又用“<-”绑定到右侧的元素列表。正如上面的例子展示的，生成表达式的组合将按照深度优先的顺序遍历：先是第一个列表的第一个元素分别与第二个列表中的每个元素分别组合，以此类推。

.. FIXME: 此处guard保留了英文原文，找不到对应的中文译法。

我们还可以在列表推导式的右侧为生成器指定guard。guard是一个 ``Bool`` 表达式。如果guard的值为 ``False`` , 则该元素被跳过。

::

    ghci> [ (a,b) | a <- [1..6], b <- [5..7], even (a + b ^ 2) ]
    [(1,5),(1,7),(2,6),(3,5),(3,7),(4,6),(5,5),(5,7),(6,6)]

其中也可以用 ``let`` 表达式绑定本地变量(local variable).

::

    ghci> let vowel = (`elem` "aeiou")
    ghci> [ x | a <- "etaoin", b <- "shrdlu", let x = [a,b], all vowel x ]
    ["eu","au","ou","iu"]

即使生成器表达式中的一个模式匹配失败了，也不会有错误发生，只会跳过未匹配的列表元素。

::

    ghci> [ a | (3,a) <- [(1,'y'),(3,'e'),(5,'p')] ]
    "e"

列表推导式功能强大用法简洁，但可能很难看懂。如果能小心使用，它也可以让我们的代码更容易理解。

.. literalinclude:: /code/ch12/listComprehension.hs

.. _remembering-a-matchs-parity:

.. FIXME: 其实本文中单独出现的parity都应该是指的同一种东西

记忆匹配的校验奇偶性
^^^^^^^^^^^^^^^^^^^^^^^^^

对左侧分组中的每一个匹配，我们必须记住该匹配是在奇校验(odd parity table)表还是偶校验表(even parity table)中匹配到的。

.. literalinclude:: /code/ch12/formParity.hs

我们将一个值包装在编码它所采用的奇偶性内，并且使它成为一个 ``Functor`` 实体，这样我们就可以方便的操作依赖奇偶校验编码的值了。

..FIXME:啰嗦

我们可能需要对采用奇偶校验的编码按它们包含的值进行排序。 ``Data.Function`` 模块提供的一个好用的组合子 ``on`` 可以帮助我们实现这个功能。

.. literalinclude:: /code/ch12/on.hs

.. CONFME: apply翻译为了应用

它的作用可能不是很明确，你可以试着去想象这样一个函数：它接受两个参数f和g，返回值是一个函数，这个返回的函数也有两个参数，分别为x和y。 ``on`` 将g分别对x和y应用，然后将f分别应用于这两个结果(所以它的名字叫 ``on`` )。

把匹配值装入奇偶性的方法一目了然。

.. literalinclude:: /code/ch12/best.hs


一旦在奇校验表或偶校验表里找到了左侧分组某个编码的几个最佳匹配，我们就可以将他们按照匹配的质量排序。

.. _another-kind-of-laziness-of-keyboarding-variety:

.. FIXME: 这真不知道怎么发挥了

键盘惰性
^^^^^^^^^^^^^^^^

定义 ``Parity`` 类型时,我们可以使用haskell的记录( ``record`` )语法来避免手写formParity函数。也就是说，可以这么写：

.. literalinclude:: /code/ch12/recordParity.hs

那我们为什么没这么做呢？答案说起来有些丢人，而且与 **ghci** 的交互调试有关。当我们告诉GHC让它自动把一个类型派生为 ``Show`` 的实体时，GHC会根据我们是否使用记录语法来定义这个类型而生成不同的代码。

::

	ghci> show $ Even 1
	"Even 1"
	ghci> show $ AltEven 1
	"AltEven {fromAltParity = 1}"
	ghci> length . show $ Even 1
	6
	ghci> length . show $ AltEven 1
	27

.. FIXME：verbose直接翻译成啰嗦感觉很形象，但是又感觉不太规范，所以加了个引号

使用记录语法定义生成的Show实体明显很“啰嗦”。在我们查看像由ghci打印的奇偶校验编码值组成的列表的时候，这种“啰嗦”会带来很多噪音。

.. FIXME： 最后一句的译法存疑

当然我们可以手动实现噪音更少的Show实体。避开记录语法写起来更省事儿，而且通过编写我们自己的formParity函数可以让GHC帮我们派生更简洁的Show实例。这么其实做没什么特别充分的依据，但是程序员的惰性有时也确实会引入一些奇怪的做法。

.. _chunking-a-list:

列表分块
^^^^^^^^^^^^^

使用列表时常常需要对它进行分块(chunk)。例如，条形码中的每个数字都由四个连续的数字编码而成。我们可以将表示一个行的列表转换为如下这种包含四个元素的列表组成的列表。

.. literalinclude:: /code/ch12/chunk.hs

需要像这样手写通用的列表操作函数的情况比较罕见。一般都是在Data.List模块里翻一翻就能找到完全符合要求或者基本满足需要的函数。

.. _generating-a-list-of-candidate-digits:

生成候选数字列表
^^^^^^^^^^^^^^^^^^^^^^^

.. FIXME: 原文是first few equations of our function, 在Haskell中，此处的equation应该是对应的函数对参数进行的一种模式匹配以及该匹配所对应的函数体，为了避免啰嗦，此处模糊地译为了“前几部分”

我们的辅助函数小分队一旦就位，为每个数字的生成候选匹配的函数就很容易搞定了。 首先，我们先得做一些前期的检查，来确定这些匹配是否都是有意义的。一个列表必须以黑色( ``Zero`` )条纹开始，并且包含足够多的条纹。下面是这个函数的前几部分。

.. literalinclude:: /code/ch12/candidateDigits.hs

如果 ``bestLeft`` 或 ``bestRight`` 的应用得到一个空列表，表示无法匹配到任何结果。否则，我们就丢掉scores，返回一个由奇偶校验编码的候选数字列表组成的列表。外部的列表有12个元素，其中每个元素都代表条形码中的一个数字。子列表中的每个数字都根据匹配质量排序。

下面给出这个函数的其余部分

.. literalinclude:: /code/ch12/candidateDigits2.hs

我们看看从上面图像中提取出的每个线条的分组对应的候选数字。

ghci> :type input
input :: [(Run, Bit)]
ghci> take 7 input
[(2,Zero),(2,One),(2,Zero),(2,One),(6,Zero),(4,One),(4,Zero)]
ghci> mapM\_ print $ candidateDigits input
[Even 1,Even 5,Odd 7,Odd 1,Even 2,Odd 5]
[Even 8,Even 7,Odd 1,Odd 2,Odd 0,Even 6]
[Even 0,Even 1,Odd 8,Odd 2,Odd 4,Even 9]
[Odd 1,Odd 0,Even 8,Odd 2,Even 2,Even 4]
[Even 3,Odd 4,Odd 5,Even 7,Even 0,Odd 2]
[Odd 2,Odd 4,Even 7,Even 0,Odd 1,Even 1]
[None 1,None 5,None 0]
[None 1,None 5,None 2]
[None 4,None 5,None 2]
[None 6,None 8,None 2]
[None 7,None 8,None 3]
[None 7,None 3,None 8]

.. _life-without-arrays-or-hash-tables:

没有数组和散列表的日子
------------------------------------------

.. FIXME: 避免长从句采用了意译

在命令式语言中，数组的地位就像是Haskell中的列表或元组，不可或缺。命令式语言中的数组通常是可变的，我们也想当然地这么认为；在命令式语言中，我们可以根据需要，随时修改数组的元素。

正如我们在“修改数组元素”一节中提到的一样，Haskell数组并不是可变的。这意味着如果要“修改”数组中的单个元素，整个数组都要被复制一次，被修改的元素将在复制的过程中被设置为新的值。很明显，这种方法不可能在性能比拼中获胜。

.. FIXME: hash table译为“散列表”，相应的，hash翻译为“散列”
.. FIXME: 对于新元素的插入，散列函数的作用是为了“确定位置”而不是原文中的“查找”(find)

可变数组用于构建另一种命令式语言数据结构，即散列表(hash table)。在典型的实现中，数组扮演了哈希表的“脊柱”的角色，数组中的每个元素都是一个列表。在哈希表中添加一个元素时，我们通过对元素进行散列(hash)，确定这个元素在数组中的偏移，然后修改这个偏移处的列表，把这个元素添加进去。

.. FIXME: 原文第二局说的是putting a new list at the offset indicated by the element's hash，如果考虑到上下文并通过学习之前的章节形成了“Haskell常识”的话，这种说法大概应该不会引起误会(即新列表并不是空的，它包含了修改前该偏移量处的列表所包含的所有元素并完成了指定修改)。

如果散列表采用的数组不是可变的，那么要更新一个哈希表的话，我们就必须创建一个新的数组。我们复制这个数组，并把一个新的列表放到由散列值确定的偏移位置上，我们不需要复制其他偏移位置上的列表，但是由于必须复制这个“脊柱”，性能已经受到了致命打击。

不可变数组从我们的工具箱中一举消灭了两种命令式语言中的典型数据结构。数组在纯Haskell代码中不像在许多别的语言中那么有用。但是很多涉及数组的代码都只是在构造阶段更新数组，接下来都是遵从只读原则操作数组。

.. FIXME: 直译，完全不知所云，因为整段在讲“tree”吗？

答案的森林
^^^^^^^^^^^^^^^^^^^^^^^^^

但事实上，没有可变的数组和散列表可用并没有想象中那么悲剧。数组和散列表经常被用作由键索引的集合，而在Haskell中，我们使用树来实现这个功能。

..FIXME：原文第二局直接结束了本段，很突兀，可以优化一下

实现一个简单的树类型在Haskell中非常简单。除此之外，更实用的树类型实现起来也是出奇的简单。比方说红黑树这种自平衡结构，就是因为其平衡算法出了名的难搞，让几代CS在校生闻风丧胆。

.. FIXME: guard reduce未译出

Haskell的代数数据类型组合、模式匹配、guard reduce可以把最可怕的平衡操作的代码缩减至只有几行。但是，我们先别摩拳擦掌急着构造树类型，先来关注为什么它们在纯函数式语言中特别有用。

.. FIXME: size of the tree意译为了“节点数”

对函数式程序员来说，树的吸引力在于修改代价低。我们不用打破不可变规则：树就和其他东西一样不可变。然而，我们修改一棵树的时候，可以在新旧两棵树之间共享大部分的结构。举例来说，有一颗有10000个节点的树，我们可能想要在里面添加或者移除一个节点，这种情况下，新旧两棵树能够共享大约9985个节点。换句话说，每次更新树的时候所需要修改的元素数目取决于树的高度，或者说是节点数的对数。

Haskell标准库提供了两种采用平衡树实现的集合类型：Data.Map用于键值对，Data.Set用于值集合。鉴于我们在下一节会用到Data.Map，我们还是来快速介绍一下该类型。Data.Set与Data.Map相当接近，你应该也能很快掌握。


.. FIXME: 第一句原文是Compared to a hash table, a well-implemented purely functional tree data structure will perform competitively.按照如下的译法的话，有一种“树的性能与散列表的性能至少处于同一数量级，如果实现的特别精良，树的性能可能接近、等同甚至超过(命令式语言中的)散列表”的意味在里面，而这显然不太可能(大概)。但如果最后说成是“可比的”又感觉这句话光秃秃的。

.. note::

	关于性能

	一个具有良好实现的纯函数式树结构与散列表在性能上应该是可以一较高下的。你不应该在你的代码会付出性能代价的假设下实现树类型。

.. _a-brief-introduction-to-maps:

.. FIXME: 所有表达“依赖键-值对的关联容器”这种概念的map都使用了原文，或者说应该译为“映射表”？

map简介
^^^^^^^^^^^^^

..FIXME: 第二句的含义应该是“不应该对底层的数据结构做任何假设”，是否应该添加一处译注，虽然在后文中也明确提到了由于这个原因而无法进行模式匹配。

.. FIXME: size-balanced tree似乎没有通用的译法，在此保留了原样。

``Data.Map`` 模块提供了参数化类型 ``Map k a`` ,将键类型k映射到关联值类型a。尽管其内部为一个size-balanced tree，但是其具体实现对我们却是不可见的。

.. FIXME: 这句话来自http://www.nocow.cn/index.php/Size_Balanced_Tree

[译注：Size-Balanced Tree（SBT）是一种通过大小(Size)域来保持平衡的二叉搜索树，它也因此得名。]

.. FIXME: value的译法参考自英文维基Associative containers词条中，对于键值对的展开。

[译注：原文对于value的使用有些混乱。为了明确表达，从此处开始，key都译为“键”，而value在表达“Map中由key所映射到的值”时都译为“映射值”]

``Map`` 的键是严格求值的，但是映射值却是非严格求值。换句话说，map的 *脊柱* ，或者说结构，总是保持最新的值，但是map中映射的值还是要等到我们强迫对它们求值的时候才被计算出来。

..FIXME: 这个内存泄漏应该优化为只提及一次

记住这点很重要，因为对于不期望内存泄漏的程序员来说， ``Map`` 类型对映射值采用的惰性求值策略经常是内存泄漏的源头。

由于 ``Data.Map`` 模块包含几个与 ``Prelude`` 模块中冲突的名字，所以它通常用限定形式导入。本章靠前的部分中，我们用前缀 ``M`` 将它导入。

.. _type-constraints:

类型约束
^^^^^^^^^^^^^

.. FIXME: 最后一句遵从了原文的表达，但是感觉翻译了之后显得很兜圈子，不如译为“不该由库作者来设置约束”。

Map类型并不对键值的类型做任何显式的约束，但是该模块中多数实用函数都要求键类型为Ord类型类的实体。需要留心这点，因为这体现了Haskell中一个常见设计模式： 类型约束应该推迟到应用处再设置，而不需要库作者为这种东西做额外劳动。

Map类型和该模块中的函数都没有约束映射值可以选用的类型。

.. _partial-application-awkwardness:

局部应用的不便
^^^^^^^^^^^^^^^^^^^^^^^^

.. FIXME：这里的适配函数的作用似乎不能用“调整”来形容，不过考虑到函数式语言的语境(即‘你几乎不能修改“什么)好像又没问题

由于某些原因，``Data.Map`` 模块中的某些函数的类型签名并不便于局部应用。函数操作的map总是最后一个参数，而它们如果是第一个参数才更便于局部应用。结果造成使用局部应用Map函数的代码几乎总是需要适配函数来调整参数顺序。

.. _getting-started-with-the-api:

map API入门
^^^^^^^^^^^^^

.. FIXME: "surface area"发挥了一下，翻译为”暴露区“

``Data.Map`` 模块有一个巨大的“暴露区”(surface area)：它导出了很多函数。而其中只有不多的几个函数是该模块中最常用的核心部分。

使用 ``empty`` 函数创建一个空的map 。如果要创建包含一个键/值对的 ``map`` ，则使用 ``singleton`` 函数。

::

	ghci> M.empty
	Loading package array-0.1.0.0 ... linking ... done.
	Loading package containers-0.1.0.1 ... linking ... done.
	fromList []
	ghci> M.singleton "foo" True
	fromList [("foo",True)]

由于 ``Map`` 的实现对我们是透明的，我们就不能对 ``Map`` 类型的值进行模式匹配。取而代之的是该模块提供的一些查找函数，其中有两个函数应用特别广泛。查找函数有一个稍微复杂的类型签名，但是不要着急，这些很快在第14章中都会弄明白的。
::

	ghci> :type M.lookup
	M.lookup :: (Ord k, Monad m) => k -> M.Map k a -> m a

.. FIXME: ”lookup函数会返回包裹在Just中的映射值“这种译法有歧义，换了一种比较绕圈子的

返回值中的类型参数m通常是Maybe类型。话句话说，如果map中包含具有给定键的映射值，lookup函数会把映射值装入 ``Just`` 返回。否则返回 ``Nothing`` 。

::

	ghci> let m = M.singleton "foo" 1 :: M.Map String Int
	ghci> case M.lookup "bar" m of { Just v -> "yay"; Nothing -> "boo" }
	"boo"

.. FIXME: ”返回该键是否存在于这个map中“是有语病的译法，还需要推敲

``findWithDefault`` 函数额外指定一个参数值，如果map中不包含查找的键值，则返回该指定值。

.. FIXME: 此处为Beware，未设置rst格式

.. note::

	小心局部应用函数！

	有一个(!)运算符会查找键并且返回与该键关联的原始值（即，不是返回装在 ``Maybe`` 或者其他什么东西里的值)。不幸的是，这并不是一个全函数：如果该键在map中不存在的话，它会调用 ``error`` 。

要在map中添加一个键值对，最有用的函数是 ``insert`` 和 ``insertWith’`` 。insert函数就是简单的在map中插入键值对，如果该键已经存在，则覆盖其关联的任何值。

::

	ghci> :type M.insert
	M.insert :: (Ord k) => k -> a -> M.Map k a -> M.Map k a
	ghci> M.insert "quux" 10 m
	fromList [("foo",1),("quux",10)]
	ghci> M.insert "foo" 9999 m
	fromList [("foo",9999)]

.. FIXME: 这里需要看一眼下面给出的签名才能确定“value”指的是映射值，而如果已经键已经存在的话，“插入”的就只有“映射值”，这种表达应该也不会引起什么误会。

insertWith'函数会额外接受一个组合函数。如果map中没有指定的键，就把该键/值对原封不动插入。否则，就先对新旧两个映射值应用组合函数，把应用的结果作为新的映射值到map中。

::

	ghci> :type M.insertWith'
	M.insertWith' :: (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
	ghci> M.insertWith' (+) "zippity" 10 m
	fromList [("foo",1),("zippity",10)]
	ghci> M.insertWith' (+) "foo" 9999 m
	fromList [("foo",10000)]

函数名最后的钩号暗示我们 ``insertWith'`` 将对combining函数严格求值。这个设计帮你避免了内存泄漏。该函数同时存在一个惰性的变种(即没有最后钩号的 ``insertWith`` )，你几乎永远用不到它。

.. FIXME: 需要强调“指定键被删除，那么该键映射值也会被删除”吗？

delete函数从map中删除指定键。如果键不存在的话，delete会将map原封不动返回。

::

	ghci> :type M.delete
	M.delete :: (Ord k) => k -> M.Map k a -> M.Map k a
	ghci> M.delete "foo" m
	fromList []

最后，还有几个高效的函数用于在maps上进行类似集合的操作。例如，我们接下来会用到的 ``union``。这个函数是“左偏”(left biased)的：如果两个map包含相同的键，返回map中将包含左侧map中对应的关联值。

::

	ghci> m `M.union` M.singleton "quux" 1
	fromList [("foo",1),("quux",1)]
	ghci> m `M.union` M.singleton "foo" 0

	fromList [("foo",1)]

我们仅仅涵盖了Data.Map中百分之十的API。我们在第13章中会更加广泛深入的讲解这里面的API。我们鼓励你自行浏览模块的文档，你会从中获得更多启发。这个模块的滴水不漏的设计一定会让你印象深刻。
 
.. _further-reading:

延伸阅读
^^^^^^^^^^^^^

.. FIXME: 第一句尽可能顺着原文翻译，但是很罗嗦。原文：The book [Okasaki99] gives a wonderful and thorough implementor's tour of many pure functional data structures, including several kinds of balanced tree.

[Okasaki99]一书将教我们如何优雅且严密地实现纯函数式数据结构，其中包括多种平衡树。该书还中还包含了作者对于纯函数式数据结构和惰性求值的宝贵思考。

我们把Okasaki这本书列为为函数式程序员的必读书目。如果你不方便翻阅Okasaki这本书，可以去看Okasaki的博士论文，[Okasaki96]是该书的一个不很完整的精简版本，在网上可以免费获得。

.. _turning-digit-soup-into-an-answer:

..FIXME: 有点意译过头了，但大体方向应该是一致的，并且下文里也没提到soup或者类似的东西。

从数字的迷雾中找到答案
--------------------------------

我们现在又有了新的问题要解决。后十二个数字有许多候选数字。还有，我们需要根据前这12个数字中的前6个数字隐含的奇偶性信息来计算第一个数字。最后，我们还需要确认求出的校验数字的有效性。

这看起来很有挑战！这一大堆不确定的数据；该拿它们怎么办？采用暴力搜索是一个很合理的提议。如果候选数字就是上面的 **ghci** 会话中给出的那些，我们需要测试多少种组合？

::

	ghci> product . map length . candidateDigits $ input
	34012224

可见暴力搜索要检查的组合过多了。我们还是先着眼于一个知道如何解决的子问题，晚些时候在考虑剩下的。

.. _solving-for-check-digits-in-parallel:

并行求解校验数字
^^^^^^^^^^^^^^^^^^^^^^^

我们暂时不考虑搜索的方案，先来关注如何计算校验数字。条形码的校验数字可以是十个数字中的任意一个。对于一个给定的校验数字，怎样反推出它是由哪一种输入序列计算出来的呢？

.. literalinclude:: /code/ch12/solutionMap.hs

在这个map中，键值是一个校验数字，映射值是一个可以计算出这个校验数字的序列。以它为基础，我们进一步定义两种map类型。

.. FIXME: 这个solution map的译法还可以改进

我们将把这两种类型的map统称为“求解map”(solution map)，因为它们包含了“求得”每个校验数字对应的各个数字序列。

给定一个数字，我们可以按如下方法更新一个既存的求解map

.. literalinclude:: /code/ch12/updateMap.hs

从map中取出一个既存的校验数字，一个可以求出该校验数字的序列，一个新的输入数字，这个函数将可以求出新的校验数字的新序列更新至map。

这部分内容可能有点不太好消化，看一个例子应该会更明白。我们假设现在要查找数字是 ``4`` ，它是序列 ``[1, 3]`` 对应的校验数字，我们想要添加到map的数字是 ``8`` 。 ``4+8`` ，模10得 ``2`` ，那么 ``2`` 就是要插入到map中的键。能计算出新校验数字 ``2`` 的序列就是 ``[8, 1, 3]`` ，这个序列就是要插入的映射值。

对序列中的每一个数字，我们都会通过该数字和之前的map生成一个新的求解map。

.. literalinclude:: /code/ch12/useDigit.hs

我们再通过一个例子演示这段代码的实际功能。这次，我们用ghci交互演示。

::

	ghci> let single n = M.singleton n [Even n] :: ParityMap
	ghci> useDigit (single 1) M.empty (Even 1)
	fromList [(2,[Even 1,Even 1])]
	ghci> useDigit (single 1) (single 2) (Even 2)
	fromList [(2,[Even 2]),(3,[Even 2,Even 1])]

传给 ``useDigits`` 函数的新求解map最开始是空的。其值完全通过在输入数字的序列上折叠执行 ``useDigits`` 函数来填充。

.. literalinclude:: /code/ch12/incorporateDigits.hs

这个函数可以用旧的求解map生成新的求解map。

::

	ghci> incorporateDigits (M.singleton 0 []) [Even 1, Even 5]
	fromList [(1,[Even 1]),(5,[Even 5])]

.. FIXME: 最后一小句太过于直译了 

最终，我们必须构造完整的求解map。我们先创建一个空的map，然后在条形码的数字位序列上依次折叠。我们为每个位置生成一个包含在该位置的猜测值的新map。这个map将作为下一轮折叠过程的旧map出现。

.. literalinclude:: /code/ch12/finalDigits.hs

(回想一下，我们在“EAN-13编码”一节中定义checkDigit函数的时候，要求计算校验数字的时候，数字要乘以3后处理。)

.. FIXME: ...so obviously we can't provide that一句的宾语是谁？

``finalDigits`` 处理的列表有多长？我们还不知道我们这个序列的第一个数字是什么，所以很明显我们还不能规定这个长度。并且我们也不想把校验数字的猜测值计入。所以这个列表一定有11个元素。

刚从 ``finalDigits`` 返回的时候，求解map必然不完整，因为我们还没有确定首位数字是什么。

.. _completing-the-solution-map-with-the-first-digit:

用首位数字补全求解map
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

我们还没讨论过该如何从左侧分组的奇偶校验类型中提取出首位数字。其实只要直接重用我们之前编写的代码就可以了。

.. literalinclude:: /code/ch12/firstDigit.hs

现在每个不完整的求解map都包含一个逆序的由数字和编码奇偶性信息组成的列表。我们接下来的任务是通过计算每个序列的首位数字来创建一个完整的求解map，并通过它创建最终的求解map。

.. literalinclude:: /code/ch12/addFirstDigit.hs

如此往复，我们最终消去了Parity类型，并撤销了之前乘以3的操作。最后一步，就是完成校验数字的计算。

.. literalinclude:: /code/ch12/buildMap.hs

.. _finding-the-correct-sequence:

找出正确的序列
^^^^^^^^^^^^^^^^^^^^^

.. checksum == check digit

我们现在有一个包含了所有可能的校验数字与对应序列映射的map。剩下的就是逐一验证我们对校验数字的猜测值，检查是否该改项的值互相吻合。

.. literalinclude:: /code/ch12/solve.hs

我们用从照片上取下来的那一行来试验，看看能否得到正确的结果。

ghci> listToMaybe . solve . candidateDigits $ input
Just [9,7,8,0,1,3,2,1,1,4,6,7,7]


棒极了！这正是照片中编码的数字序列。

.. _working-with-row-data:

处理行数据
-----------------------

我们反复提到“处理的是图像中的一行”。下面是具体的做法

.. literalinclude:: /code/ch12/withRow.hs

``withRow`` 函数接受图像中的一行，将该行转换为黑白图像，然后对游程编码后的行数据调用指定函数。它通过 ``row`` 函数来获取行数据。

::

	row :: (Ix a, Ix b) => b -> Array (a,b) c -> Array a c
	row j a = ixmap (l,u) project a
    	where project i = (i,j)
          	((l,_), (u,_)) = bounds a

.. FIXME: 这个“强大的”很突兀
.. FIXME: 按照原文的这种描述，那个whereas用的就很奇怪了，或许这仨的相似处就是“针对单个数组的处理函数”？
.. slice译为了切片，并稍微修改了表达方式，以避免“切割/分割”隐含的“生成两个部分”的意向(split)。

这个函数需要稍作解释。正如 ``fmap`` 用来变换数组中的元素值，``ixmap`` 用来变换数组中的索引值。上面这个强大的函数则允许我们任意地从数组取出“切片”。

``ixmap`` 的第一个参数是新数组的边界。边界可以与原数组有不同的维。比方说，我们可以从一个二维数组中按行取出一个一维数组。

[译注： 此处所说的“有不同的维”包括维数不同、“维的类型”不同、以及两种都有的情况。]

第二个参数是一个映射函数。其参数为新数组的索引值，返回值为原数组的索引值。映射索引的值接下来会变为新数组原索引值处的值。例如，如果我们把2传给映射函数，它返回(2, 2)。这表示新数组中索引值为2的元素值取自源数组中索引值为(2, 2)的元素。

.. _pulling-it-all-together:

最终装配
----------------------

.. FIXME: 这一段的两句话关联并不明显

``candidateDigits`` 只要不是从条形码序列的起始处调用,就会返回一个空结果。使用下面的函数，我们可以轻松的扫描一整行，并得到匹配结果。

.. literalinclude:: /code/ch12/findMatch.hs

..FIXME: 应该是指的candidateDigits的惰性求值

这里，我们利用了惰性求值的优点。 ``tails`` 前面的map函数只会在产生非空列表的时候参会真正求值。

.. literalinclude:: /code/ch12/findEAN13.hs

最后，我们做了一个简单的封装，用来打印从命令行传入的netpbm图像文件中提取的条形码。

注意在我们本章定义的超过30个函数中，只有 ``main`` 是涉及IO的。

.. _a-few-comments-on-development-style:

关于开发方式的一些意见
----------------------------------

你可能发现了，本章中给出的许多函数都是些放在源码顶部的小函数。这并非偶然。正如我们早些时候提到过的，当我们开始本章的撰写时，我们并不知道要拿什么来构造这个解决方案。

.. FIXME:第一句不明确

我们还经常需要找到问题域来明确解决问题的大方向。为了这个目的，我们耗费了大量的时间摆弄 **ghci** ，对各种函数做小测试。这需要函数定义在源文件的最上方，否则 **ghci** 就看不到它们了。

一旦我们对这些函数的功能和行为满意了，我们就开始将它们黏合在一起，继续通过 **ghci** 观察执行的结果。这就是添加类型签名的好处——如果某些函数没法组合到一起，我们可以通过类型签名尽早发现。

最后，我们有了一大堆短小的顶层函数，每个函数都有类型签名。这可能并不是最紧凑的形式；在搞定这些函数的逻辑之后，我们本可以将其中很多函数放到 ``let`` 或者 ``where`` 块中。然而，我们发现这种更大的纵向空间，短小的函数体，以及类型签名，都使代码变得更易读了，所以我们也不再考虑把这些函数“golfing”了。

.. FIXME: 第二段采用了意译，与原文是否等价不明确。

使用强静态类型的语言工作不会影响增量的流式的问题解决模式。我们发现这种“先编写函数”，再“用**ghci** 测试， 获取有用信息”的模式非常快速；这为我们快速编写优质代码提供了巨大帮助。

.. [29] 公式在ITU-R Recommendation 601中首次提及

.. [30] 这里golf的用法来源于Perl程序员们玩儿的一个游戏，即程序员尝试为某种目的编写最短的代码，敲键盘次数最少的获胜。
