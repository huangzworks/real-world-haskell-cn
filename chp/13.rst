第十三章：数据结构
=====================

关联列表
-----------

我们常常会跟一些以键为索引的无序数据打交道。

举个例子，UNIX 管理员可能会这么一个列表，它包含了用户 ID 及其对应的用户名。这个列表根据用户 ID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。

Haskell 里有几种不同的方法来处理这种结构的数据，最常用的两个是关联列表（association list）和 ``Data.Map`` 模块提供的 ``Map`` 类型。

关联列表非常简单，易于使用。由于关联列表由 Haskell 列表构成，因此所有列表操作函数都可以用于处理关联列表。

另一方面， ``Map`` 类型在处理大数据集时，性能比关联列表要好。

本章将同时介绍这两种数据结构。

一个关联列表就是一个包含 ``(key, value)`` 元组的列表， ``key`` 和 ``value`` 可以是任意类型。一个处理用户 ID 和用户名映射的关联列表的类型可能是 ``[(Integer, String)]`` 。

[注：关联列表的 ``key`` 必须是 ``Eq`` 类型的成员。]

关联列表的构建方式和构建普通列表一样。Haskell 提供了一个 ``Data.List.lookup`` 函数，用于在关联列表中查找数据。这个函数的类型签名为 ``Eq a => a -> [(a, b)] -> Maybe b`` 。它的使用方式如下：

::

    Prelude> let al = [(1, "one"), (2, "two"), (3, "three"), (4, "four")]

    Prelude> lookup 1 al
    Just "one"

    Prelude> lookup 5 al
    Nothing

``lookup`` 函数的定义如下：

.. literalinclude:: /code/ch13/lookup.hs

``lookup`` 在输入列表为空时返回 ``Nothing`` 。如果输入列表不为空，那么它检查当前列表元素的 ``key`` 是否就是我们要找的 ``key`` ，如果是的话就返回和这个 ``key`` 对应的 ``value`` ，否则就继续递归处理剩余的列表元素。

现在来看一个更复杂的关联列表例子。在 Unix/Linux 系统中，有一个 ``/etc/passwd`` 文件，这个文件保存了用户名称，用户 ID，用户的 HOME 目录位置，以及其他一些数据。文件以行分割每个用户的资料，每个数据域用分号隔开：

::

    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/bin/sh
    bin:x:2:2:bin:/bin:/bin/sh
    sys:x:3:3:sys:/dev:/bin/sh
    sync:x:4:65534:sync:/bin:/bin/sync
    games:x:5:60:games:/usr/games:/bin/sh
    man:x:6:12:man:/var/cache/man:/bin/sh
    lp:x:7:7:lp:/var/spool/lpd:/bin/sh
    mail:x:8:8:mail:/var/mail:/bin/sh
    news:x:9:9:news:/var/spool/news:/bin/sh
    jgoerzen:x:1000:1000:John Goerzen,,,:/home/jgoerzen:/bin/bash

以下程序读入并处理 ``/etc/passwd`` 文件，它创建一个关联列表，使得我们可以根据给定用户 ID ，获取相应的用户名：

.. literalinclude:: /code/ch13/passwd-al.hs

``findByUID`` 是整个程序的核心，它逐行读入并处理输入，使用 ``lookup`` 从处理结果中查找给定用户 ID ：

::

    *Main> findByUID "root:x:0:0:root:/root:/bin/bash" 0
    Just "root"

``parseline`` 读入并处理一个字符串，返回一个包含用户 ID 和用户名的元组：

::

    *Main> parseline "root:x:0:0:root:/root:/bin/bash"
    (0,"root")

``split`` 函数根据给定分隔符 ``delimiter`` 将一个文本行分割为列表：

::

    *Main> split ':' "root:x:0:0:root:/root:/bin/bash"
    ["root","x","0","0","root","/root","/bin/bash"]

以下是在本机执行 ``passwd-al.hs`` 处理 ``/etc/passwd`` 的结果：

::

    $ runghc passwd-al.hs /etc/passwd 0
    root

    $ runghc passwd-al.hs /etc/passwd 10086
    Could not find that UID


Map
------

``Data.Map`` 模块提供的 ``Map`` 类型的行为和关联列表类似，但 ``Map`` 类型的性能更好。

``Map`` 提供了和其他语言的哈希表同等的能力。 ``Map`` 在内部由平衡二叉树实现，在 Haskell 这种使用不可变数据的语言中，它是一个比哈希表更有效的表示。这是一个非常明显的例子，说明纯函数式语言是如何深入地影响我们编写程序的方式：对于一个给定的任务，我们总是选择合适的算法和数据结构，使得解决方案尽可能地简单和有效，但这些（纯函数式的）选择通常不同于命令式语言处理同样问题时的选择。

因为 ``Data.Map`` 模块的一些函数和 ``Prelude`` 模块的函数重名，我们通过 ``import qualified Data.Map as Map`` 的方式引入模块，并使用 ``Map.name`` 的方式引用模块中的名字。

我们以展示几种不同的构建 ``Map`` 的方式作为开始：

.. literalinclude:: /code/ch13/buildmap.hs

``Map.insert`` 函数处理数据的方式非常 Haskell 化：它返回经过函数应用的输入数据的副本。这种处理数据的方式在操作多个 ``Map`` 时非常有用，它意味着你可以像前面代码中 ``mapFold`` 那样使用 ``fold`` 来构建一个 ``Map`` ，又或者像 ``mapManual`` 那样，串连起多个 ``Map.insert`` 调用。

现在，到 ghci 中验证一下是否所有定义都如我们所预期的那样工作：

::

    Prelude> :l buildmap.hs
    [1 of 1] Compiling Main             ( buildmap.hs, interpreted )
    Ok, modules loaded: Main.
    *Main> al
    Loading package array-0.4.0.0 ... linking ... done.
    Loading package deepseq-1.3.0.0 ... linking ... done.
    Loading package containers-0.4.2.1 ... linking ... done.
    [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
    *Main> mapFromAL
    fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
    *Main> mapFold
    fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
    *Main> mapManual
    fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]

注意， ``Map`` 并不保证它的输出排列和原本的输入排列一致，对比 ``mapManual`` 的输入和输出可以看出这一点。

``Map`` 的操作方式和关联列表类似。 ``Data.Map`` 模块提供了一组函数，用于增删 ``Map`` 元素，对 ``Map`` 进行过滤、修改和 fold ，以及在 ``Map`` 和关联列表之间进行转换。 ``Data.Map`` 模块本身的文档非常优秀，因此我们在这里不会详细讲解每个函数，而是使用一个具体的例子来展示本章介绍的概念。


函数也是数据
-------------------

Haskell 语言的威力部分在于它可以让我们方便地创建并操作函数。

以下示例展示了怎样将函数保存到记录的域中：

.. literalinclude:: /code/ch13/funcrecs.hs

注意 ``colorCalc`` 域的类型：它是一个函数，接受一个 ``Int`` 类型值作为参数，并返回一个 ``(CustomColor, Int)`` 元组。

我们创建了两个 ``FuncRec`` 记录： ``plus5`` 和 ``always0`` ，这两个记录的 ``colorCalc`` 域都总是返回紫色（purple）。 ``FuncRec`` 自身并没有域去保存所使用的颜色，颜色的值被保存在函数当中。这种用法被称为\ *闭包*\ 。

以下是示例代码：

::

    *Main> :l funcrecs.hs
    [1 of 1] Compiling Main             ( funcrecs.hs, interpreted )
    Ok, modules loaded: Main.
    *Main> :t plus5
    plus5 :: FuncRec
    *Main> name plus5
    "plus5"
    *Main> :t colorCalc plus5
    colorCalc plus5 :: Int -> (CustomColor, Int)
    *Main> (colorCalc plus5) 7
    (CustomColor {red = 255, green = 0, blue = 255},12)
    *Main> :t colorCalc always0
    colorCalc always0 :: Int -> (CustomColor, Int)
    *Main> (colorCalc always0) 7
    (CustomColor {red = 255, green = 0, blue = 255},0)

上面的程序工作得很好，但我们还想做一些更有趣的事，比如说，在多个域中使用同一段数据。可以使用一个类型构造函数来做到这一点：

.. literalinclude:: /code/ch13/funcrecs2.hs

``mkFuncRecs`` 函数接受一个字符串和一个函数作为参数，返回一个新的 ``FuncRec`` 记录。以下是对 ``mkFuncRecs`` 函数的测试：

::

    *Main> :l funcrecs2.hs
    [1 of 1] Compiling Main             ( funcrecs2.hs, interpreted )
    Ok, modules loaded: Main.
    *Main> :t plus5
    plus5 :: FuncRec
    *Main> name plus5
    "plus5"
    *Main> (calc plus5) 5
    10
    *Main> (namedCalc plus5) 5
    ("plus5",10)
    *Main> let plus5a = plus5 {name = "PLUS5A"}
    *Main> name plus5a
    "PLUS5A"
    *Main> (namedCalc plus5a) 5
    ("plus5",10)

注意 ``plus5a`` 的创建过程：我们改变了 ``plus5`` 的 ``name`` 域，但没有修改它的 ``namedCalc`` 域。这就是为什么调用 ``name`` 会返回新名字，而 ``namedCalc`` 依然返回原本使用 ``mkFuncRecs`` 创建时设置的名字 —— 除非我们显式地修改域，否则它们不会被改变。


扩展示例： /etc/password
-----------------------------

扩展示例：数值类型
---------------------

首要步骤
^^^^^^^^^^

补全代码
^^^^^^^^^^

善用『函数既数据』思想
---------------------------

将不同的列表作为单个包
^^^^^^^^^^^^^^^^^^^^^^^

列表，不同的列表，以及 Monoids
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通用序列
----------
