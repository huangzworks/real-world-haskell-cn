
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 18 章： Monad变换器 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 19 章： 错误处理" href="19.html" />
    <link rel="prev" title="第 16 章：使用Parsec" href="16.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="16.html">第 16 章：使用Parsec</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="19.html">第 19 章： 错误处理</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="monad">
<h1>第 18 章： Monad变换器<a class="headerlink" href="#monad" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>动机： 避免样板代码<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。</p>
<p>比如，回忆在第十章中开发的 <code class="docutils literal"><span class="pre">Parse</span></code> 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 <code class="docutils literal"><span class="pre">State</span></code> monad。事实上我们的monad比标准的 <code class="docutils literal"><span class="pre">State</span></code> monad 更加复杂：它同时也使用了 <code class="docutils literal"><span class="pre">Either</span></code> 类型来表达解析过程中可能的失败。在这个例子中，我们想在解析失败的时候就立刻停止这个过程，而不是以错误的状态继续执行解析。这个monad同时包含了带状态计算的效果和提早退出计算的效果。</p>
<p>普通的 <code class="docutils literal"><span class="pre">State</span></code> monad不允许我们提早退出，因为其只负责状态的携带。其使用的是 <code class="docutils literal"><span class="pre">fail</span></code> 函数的默认实现：直接调用 <code class="docutils literal"><span class="pre">error</span></code> 抛出异常 － 这一异常无法在纯函数式的代码中捕获。因此，尽管 <code class="docutils literal"><span class="pre">State</span></code> monad似乎允许错误，但是这一能力并没有什么用。（再次强调：请尽量避免使用 <code class="docutils literal"><span class="pre">fail</span></code> 函数！）</p>
<p>理想情况下，我们希望能使用标准的 <code class="docutils literal"><span class="pre">State</span></code> monad，并为其加上实用的错误处理能力以代替手动地大量定制各种monad。虽然在 <code class="docutils literal"><span class="pre">mtl</span></code> 库中的标准monad不可合并使用，但使用库中提供了一系列的 <em>monad变换器</em> 可以达到相同的效果。</p>
<p>Monad变换器和常规的monad很类似，但它们并不是独立的实体。相反，monad变换器通过修改其以为基础的monad的行为来工作。 大部分 <code class="docutils literal"><span class="pre">mtl</span></code> 库中的monad都有对应的变换器。习惯上变换器以其等价的monad名为基础，加以 <code class="docutils literal"><span class="pre">T</span></code> 结尾。 例如，与 <code class="docutils literal"><span class="pre">State</span></code> 等价的变换器版本称作 <code class="docutils literal"><span class="pre">StateT</span></code> ； 它修改下层monad以增加可变状态。此外，若将 <code class="docutils literal"><span class="pre">WriterT</span></code> monad变换器叠加于其他（或许不支持数据输出的）monad之上，在被monad修改后的的monad中，输出数据将成为可能。</p>
<p>[注：<code class="docutils literal"><span class="pre">mtl</span></code> 意为monad变换器函数库(Monad Transformer Library)]</p>
<p>[译注：Monad变换器需要依附在一已有monad上来构成新的monad，在接下来的行文中将使用“下层monad”来称呼monad变换器所依附的那个monad]</p>
</div>
<div class="section" id="id2">
<h2>简单的Monad变换器实例<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在介绍monad变换器之前，先看看以下函数，其中使用的都是之前接触过的技术。这个函数递归地访问目录树，并返回一个列表，列表中包含树的每层的实体个数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/CountEntries.hs</span>
<span class="kr">module</span> <span class="nn">CountEntries</span>
  <span class="p">(</span> <span class="nf">listDirectory</span>
  <span class="p">,</span> <span class="nf">countEntriesTrad</span>
  <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">System.Directory</span> <span class="p">(</span><span class="nf">doesDirectoryExist</span><span class="p">,</span> <span class="nf">getDirectoryContents</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.FilePath</span> <span class="p">((</span><span class="o">&lt;/&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM</span><span class="p">,</span> <span class="nf">liftM</span><span class="p">)</span>

<span class="nf">listDirectory</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">listDirectory</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="n">filter</span> <span class="n">notDots</span><span class="p">)</span> <span class="o">.</span> <span class="n">getDirectoryContents</span>
  <span class="kr">where</span> <span class="n">notDots</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">/=</span> <span class="s">&quot;.&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">/=</span> <span class="s">&quot;..&quot;</span>

<span class="nf">countEntriesTrad</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">[(</span><span class="kt">FilePath</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
<span class="nf">countEntriesTrad</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">listDirectory</span> <span class="n">path</span>
    <span class="n">rest</span> <span class="ow">&lt;-</span> <span class="n">forM</span> <span class="n">contents</span> <span class="o">$</span> <span class="nf">\</span><span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">newName</span> <span class="ow">=</span> <span class="n">path</span> <span class="o">&lt;/&gt;</span> <span class="n">name</span>
        <span class="n">isDir</span> <span class="ow">&lt;-</span> <span class="n">doesDirectoryExist</span> <span class="n">newName</span>
        <span class="kr">if</span> <span class="n">isDir</span>
          <span class="kr">then</span> <span class="n">countEntriesTrad</span> <span class="n">newName</span>
          <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">length</span> <span class="n">contents</span><span class="p">)</span> <span class="kt">:</span> <span class="n">concat</span> <span class="n">rest</span>
</pre></div>
</div>
<p>现在看看如何使用 <code class="docutils literal"><span class="pre">Writer</span></code> monad 实现相同的目标。由于这个monad允许随时记下数值，所以并不需要我们显示地去构建结果。</p>
<p>为了遍历目录，这个函数必须在 <code class="docutils literal"><span class="pre">IO</span></code> monad中执行，因此我们无法直接使用 <code class="docutils literal"><span class="pre">Writer</span></code> monad。但我们可以用 <code class="docutils literal"><span class="pre">WriterT</span></code> 将记录信息的能力赋予 <code class="docutils literal"><span class="pre">IO</span></code> 。一种简单的理解方法是首先理解涉及的类型。</p>
<p>通常 <code class="docutils literal"><span class="pre">Writer</span></code> monad有两个类型参数，因此写作 <code class="docutils literal"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">a</span></code> 更为恰当。其中参数 <code class="docutils literal"><span class="pre">w</span></code> 用以指明我们想要记录的数值的类型。而另一类型参数 <code class="docutils literal"><span class="pre">a</span></code> 是monad类型类所要求的。因此 <code class="docutils literal"><span class="pre">Writer</span> <span class="pre">[(FilePath，Int)]</span> <span class="pre">a</span></code> 是个记录一列目录名和目录大小的writer monad。</p>
<p><code class="docutils literal"><span class="pre">WriterT</span></code> 变换器有着类似的结构。但其增加了另外一个类型参数 <code class="docutils literal"><span class="pre">m</span></code> ：这便是下层monad，也是我们想为其增加功能的monad。 <code class="docutils literal"><span class="pre">WriterT</span></code> 的完整类型签名是 <code class="docutils literal"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">m</span> <span class="pre">a</span></code>。</p>
<p>由于所需的目录遍历操作需要访问 <code class="docutils literal"><span class="pre">IO</span></code> monad，因此我们将writer功能累加在 <code class="docutils literal"><span class="pre">IO</span></code> monad之上。通过将monad变换器与原有monad结合，我们得到了类型签名： <code class="docutils literal"><span class="pre">WriterT</span> <span class="pre">[(FilePath，</span> <span class="pre">Int)]</span> <span class="pre">IO</span> <span class="pre">a</span></code> 这个monad变换器和monad的组合自身也是一个monad：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/CountEntriesT.hs</span>
<span class="kr">module</span> <span class="nn">CountEntriesT</span>
  <span class="p">(</span> <span class="nf">listDirectory</span>
  <span class="p">,</span> <span class="nf">countEntries</span>
  <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">CountEntries</span> <span class="p">(</span><span class="nf">listDirectory</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.Directory</span> <span class="p">(</span><span class="nf">doesDirectoryExist</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">System.FilePath</span> <span class="p">((</span><span class="o">&lt;/&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM_</span><span class="p">,</span> <span class="nf">when</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Trans</span> <span class="p">(</span><span class="nf">liftIO</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Writer</span> <span class="p">(</span><span class="kt">WriterT</span><span class="p">,</span> <span class="nf">tell</span><span class="p">)</span>

<span class="nf">countEntries</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">WriterT</span> <span class="p">[(</span><span class="kt">FilePath</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">countEntries</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">listDirectory</span> <span class="o">$</span> <span class="n">path</span>
    <span class="n">tell</span> <span class="p">[(</span><span class="n">path</span><span class="p">,</span> <span class="n">length</span> <span class="n">contents</span><span class="p">)]</span>
    <span class="n">forM_</span> <span class="n">contents</span> <span class="o">$</span> <span class="nf">\</span><span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">newName</span> <span class="ow">=</span> <span class="n">path</span> <span class="o">&lt;/&gt;</span> <span class="n">name</span>
        <span class="n">isDir</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">doesDirectoryExist</span> <span class="o">$</span> <span class="n">newName</span>
        <span class="n">when</span> <span class="n">isDir</span> <span class="o">$</span> <span class="n">countEntries</span> <span class="n">newName</span>
</pre></div>
</div>
<p>代码与其先前的版本区别不大，需要时 <code class="docutils literal"><span class="pre">liftIO</span></code> 可以将 <code class="docutils literal"><span class="pre">IO</span></code> monad暴露出来；同时， <code class="docutils literal"><span class="pre">tell</span></code> 可以用以记下对目录的访问。</p>
<p>为了执行这一代码，需要选择一个 <code class="docutils literal"><span class="pre">WriterT</span></code> 的执行函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">runWriterT</span>
<span class="nf">runWriterT</span> <span class="ow">::</span> <span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">execWriterT</span>
<span class="nf">execWriterT</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">w</span>
</pre></div>
</div>
<p>这些函数都可以用以执行动作，移除 <code class="docutils literal"><span class="pre">WriterT</span></code> 的包装，并将结果交给其下层monad。其中 <code class="docutils literal"><span class="pre">runWriterT</span></code> 函数同时返回动作结果以及在执行过程获得的记录。而 <code class="docutils literal"><span class="pre">execWriterT</span></code> 丢弃动作的结果，只将记录返回。</p>
<p>因为没有 <code class="docutils literal"><span class="pre">IOT</span></code> 这样的monad变换器，所以此处我们在 <code class="docutils literal"><span class="pre">IO</span></code> 之上使用 <code class="docutils literal"><span class="pre">WriterT</span></code> 。一旦要用 <code class="docutils literal"><span class="pre">IO</span></code> monad和其他的一个或多个monad变换器结合， <code class="docutils literal"><span class="pre">IO</span></code> 一定在monad栈的最底下。</p>
<p>[译注：“monad栈”由monad和一个或多个monad变换器叠加而成，形成一个栈的结构。若在monad栈中需要 <code class="docutils literal"><span class="pre">IO</span></code> monad，由于没有对应的monad变换器（ <code class="docutils literal"><span class="pre">IOT</span></code> ），所以 <code class="docutils literal"><span class="pre">IO</span></code> monad只能位于整个monad栈的最底下。此外， <code class="docutils literal"><span class="pre">IO</span></code> 是一个很特殊的monad，它的 <code class="docutils literal"><span class="pre">IOT</span></code> 版本是无法实现的。]</p>
</div>
<div class="section" id="monadmonad">
<h2>Monad和Monad变换器中的模式<a class="headerlink" href="#monadmonad" title="Permalink to this headline">¶</a></h2>
<p>在 <code class="docutils literal"><span class="pre">mtl</span></code> 库中的大部分monad与monad变换器遵从一些关于命名和类型类的模式。</p>
<p>为说明这些规则，我们将注意力聚焦在一个简单的monad上： <code class="docutils literal"><span class="pre">reader</span></code> monad。 <code class="docutils literal"><span class="pre">reader</span></code> monad的具体API位于 <code class="docutils literal"><span class="pre">MonadReader</span></code> 中。大部分 <code class="docutils literal"><span class="pre">mtl</span></code> 中的monad都有一个名称相对的类型类。例如 <code class="docutils literal"><span class="pre">MonadWriter</span></code> 定义了writer monad的API，以此类推。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/Reader.hs</span>
<span class="cm">{-# LANGUAGE FunctionalDependencies #-}</span>
<span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadReader</span> <span class="n">r</span> <span class="n">m</span> <span class="o">|</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">r</span> <span class="kr">where</span>
    <span class="n">ask</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">r</span>
    <span class="n">local</span> <span class="ow">::</span> <span class="p">(</span><span class="n">r</span> <span class="ow">-&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>其中类型变量 <code class="docutils literal"><span class="pre">r</span></code> 表示reader monad所附带的不变状态， <code class="docutils literal"><span class="pre">Reader</span> <span class="pre">r</span></code> monad是个 <code class="docutils literal"><span class="pre">MonadReader</span></code> 的实例，同时 <code class="docutils literal"><span class="pre">ReaderT</span> <span class="pre">r</span> <span class="pre">m</span></code> monad变换器也是一个。这个模式同样也在其他的 <code class="docutils literal"><span class="pre">mtl</span></code> monad中重复着： 通常有个具体的monad，和其对应的monad变换器，而它们都是相应命令的类型类的实例。这个类型类定义了功能相同的monad的API。</p>
<p>回到我们reader monad的例子中，我们之前尚未讨论过 <code class="docutils literal"><span class="pre">local</span></code> 函数。
通过一个类型为 <code class="docutils literal"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">r</span></code> 的函数，它可临时修改当前的环境，
并在这一临时环境中执行其动作。举个具体的例子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/LocalReader.hs</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Reader</span>

<span class="nf">myName</span> <span class="n">step</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">step</span> <span class="o">++</span> <span class="s">&quot;, I am &quot;</span> <span class="o">++</span> <span class="n">name</span><span class="p">)</span>

<span class="nf">localExample</span> <span class="ow">::</span> <span class="kt">Reader</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">localExample</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">myName</span> <span class="s">&quot;First&quot;</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">local</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;dy&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">myName</span> <span class="s">&quot;Second&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">myName</span> <span class="s">&quot;Third&quot;</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>若在 <code class="docutils literal"><span class="pre">ghci</span></code> 中执行 <code class="docutils literal"><span class="pre">localExample</span></code> ，可以观察到对环境修改的效果被限制在了一个地方：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runReader</span> <span class="n">localExample</span> <span class="s">&quot;Fred&quot;</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="s">&quot;First, I am Fred&quot;</span><span class="p">,</span><span class="s">&quot;Second, I am Freddy&quot;</span><span class="p">,</span><span class="s">&quot;Third, I am Fred&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>当下层monad <code class="docutils literal"><span class="pre">m</span></code> 是一个 <code class="docutils literal"><span class="pre">MonadIO</span></code> 的实例时， <code class="docutils literal"><span class="pre">mtl</span></code> 提供了关于 <code class="docutils literal"><span class="pre">ReaderT</span> <span class="pre">r</span> <span class="pre">m</span></code> 和其他类型类的实例，这里是其中的一些：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/Reader.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="o">...</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadIO</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadIO</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="o">...</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadPlus</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>再次说明：为方便使用，大部分的 <code class="docutils literal"><span class="pre">mtl</span></code> monad变换器都定义了诸如此类的实例。</p>
</div>
<div class="section" id="id3">
<h2>叠加多个Monad变换器<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>之前提到过，在常规monad上叠加monad变换器可得到另一个monad。由于混合的结果也是个monad，我们可以凭此为基础再叠加上一层monad变换器。事实上，这么做十分常见。但在什么情况下才需要创建这样的monad呢？</p>
<ul class="simple">
<li>若代码想和外界打交道，便需要 <code class="docutils literal"><span class="pre">IO</span></code> 作为这个monad栈的基础。否则普通的monad便可以满足需求。</li>
<li>加上一层 <code class="docutils literal"><span class="pre">ReaderT</span></code> ，以添加访问只读配置信息的能力。</li>
<li>叠加上 <code class="docutils literal"><span class="pre">StateT</span></code> ，就可以添加可修改的全局状态。</li>
<li>若想得到记录事件的能力，可以添加一层 <code class="docutils literal"><span class="pre">WriterT</span></code> 。</li>
</ul>
<p>这个做法的强大之处在于：我们可以指定所需的计算效果，以量身定制monad栈。</p>
<p>举个多重叠加的moand变换器的例子，这里是之前开发的 <code class="docutils literal"><span class="pre">countEntries</span></code> 函数。我们想限制其递归的深度，并记录下它在执行过程中所到达的最大深度：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="kr">import</span> <span class="nn">System.Directory</span>
<span class="kr">import</span> <span class="nn">System.FilePath</span>
<span class="kr">import</span> <span class="nn">System.Monad.Reader</span>
<span class="kr">import</span> <span class="nn">System.Monad.State</span>

<span class="kr">data</span> <span class="kt">AppConfig</span> <span class="ow">=</span> <span class="kt">AppConfig</span>
  <span class="p">{</span> <span class="n">cfgMaxDepth</span> <span class="ow">::</span> <span class="kt">Int</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">AppState</span> <span class="ow">=</span> <span class="kt">AppState</span>
  <span class="p">{</span> <span class="n">stDeepestReached</span> <span class="ow">::</span> <span class="kt">Int</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>此处使用 <code class="docutils literal"><span class="pre">ReaderT</span></code> 来记录配置数据，数据的内容表示最大允许的递归深度。同时也使用了 <code class="docutils literal"><span class="pre">StateT</span></code> 来记录在实际遍历过程中所达到的最大深度。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="kr">type</span> <span class="kt">App</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">AppConfig</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">AppState</span> <span class="kt">IO</span><span class="p">)</span>
</pre></div>
</div>
<p>我们的变换器以 <code class="docutils literal"><span class="pre">IO</span></code> 为基础，依次叠加 <code class="docutils literal"><span class="pre">StateT</span></code> 与 <code class="docutils literal"><span class="pre">ReaderT</span></code> 。在此例中，栈顶是 <code class="docutils literal"><span class="pre">ReaderT</span></code> 还是 <code class="docutils literal"><span class="pre">WriterT</span></code> 并不重要，但是 <code class="docutils literal"><span class="pre">IO</span></code> 必须作为最下层monad。</p>
<p>仅仅几个monad变换器的叠加，也会使类型签名迅速变得复杂起来。故此处以 <code class="docutils literal"><span class="pre">type</span></code> 关键字定义类型别名，以简化类型的书写。</p>
<hr class="docutils" />
<div class="section" id="id4">
<h3>缺失的类型参数呢？<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>或许你已注意到，此处的类型别名并没有我们为monad类型所常添加的类型参数 <code class="docutils literal"><span class="pre">a</span></code>：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="kr">type</span> <span class="kt">App2</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">AppConfig</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">AppState</span> <span class="kt">IO</span><span class="p">)</span> <span class="n">a</span>
</pre></div>
</div>
<p>在常规的类型签名用例下， <code class="docutils literal"><span class="pre">App</span></code> 和 <code class="docutils literal"><span class="pre">App2</span></code> 不会遇到问题。但如果想以此类型为基础构建其他类型，两者的区别就显现出来了。</p>
<p>例如我们想另加一层monad变换器，编译器会允许 <code class="docutils literal"><span class="pre">WriterT</span> <span class="pre">[String]</span> <span class="pre">App</span> <span class="pre">a</span></code> 但拒绝 <code class="docutils literal"><span class="pre">WriterT</span> <span class="pre">[String]</span> <span class="pre">App2</span> <span class="pre">a</span></code> 。</p>
<p>其中的理由是：Haskell不允许对类型别名的部分应用。 <code class="docutils literal"><span class="pre">App</span></code> 不需要类型参数，故没有问题。另一方面，因为 <code class="docutils literal"><span class="pre">App2</span></code> 需要一个类型参数，若想基于 <code class="docutils literal"><span class="pre">App2</span></code> 构造其他的类型，则必须为这个类型参数提供一个类型。</p>
<p>这一限制仅适用于类型别名，当构建monad栈时，通常的做法是用 <code class="docutils literal"><span class="pre">newtype</span></code> 来封装（接下来的部分就会看到这类例子）。 因此实际应用中很少出现这种问题。</p>
<p>[译注：类似于函数的部分应用，“类型别名的部分应用”指的是在应用类型别名时，给出的参数数量少于定义中的参数数量。在以上例子中， <code class="docutils literal"><span class="pre">App</span></code> 是一个完整的应用，因为在其定义 <code class="docutils literal"><span class="pre">type</span> <span class="pre">App</span> <span class="pre">=</span> <span class="pre">...</span></code> 中，没有类型参数；而 <code class="docutils literal"><span class="pre">App2</span></code> 却是个部分应用，因为在其定义 <code class="docutils literal"><span class="pre">type</span> <span class="pre">App2</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">...</span></code> 中，还需要一个类型参数 <code class="docutils literal"><span class="pre">a</span></code> 。]</p>
<hr class="docutils" />
<p>我们monad栈的执行函数很简单：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="nf">runApp</span> <span class="ow">::</span> <span class="kt">App</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">AppState</span><span class="p">)</span>
<span class="nf">runApp</span> <span class="n">k</span> <span class="n">maxDepth</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">config</span> <span class="ow">=</span> <span class="kt">AppConfig</span> <span class="n">maxDepth</span>
        <span class="n">state</span> <span class="ow">=</span> <span class="kt">AppState</span> <span class="mi">0</span>
    <span class="kr">in</span> <span class="n">runStateT</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="n">k</span> <span class="n">config</span><span class="p">)</span> <span class="n">state</span>
</pre></div>
</div>
<p>对 <code class="docutils literal"><span class="pre">runReaderT</span></code> 的应用移除了 <code class="docutils literal"><span class="pre">ReaderT</span></code> 变换器的包装，之后 <code class="docutils literal"><span class="pre">runStateT</span></code> 移除了 <code class="docutils literal"><span class="pre">StateT</span></code> 的包装，最后的结果便留在 <code class="docutils literal"><span class="pre">IO</span></code> monad中。</p>
<p>和先前的版本相比，我们的修改并未使代码复杂太多，但现在函数却能记录目前的路径，和达到的最大深度：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">constrainedCount</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">App</span> <span class="p">[(</span><span class="kt">FilePath</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
<span class="nf">constrainedCount</span> <span class="n">curDepth</span> <span class="n">path</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">listDirectory</span> <span class="o">$</span> <span class="n">path</span>
    <span class="n">cfg</span> <span class="ow">&lt;-</span> <span class="n">ask</span>
    <span class="n">rest</span> <span class="ow">&lt;-</span> <span class="n">forM</span> <span class="n">contents</span> <span class="o">$</span> <span class="nf">\</span><span class="n">name</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">newPath</span> <span class="ow">=</span> <span class="n">path</span> <span class="o">&lt;/&gt;</span> <span class="n">name</span>
        <span class="n">isDir</span> <span class="ow">&lt;-</span> <span class="n">liftIO</span> <span class="o">$</span> <span class="n">doesDirectoryExist</span> <span class="n">newPath</span>
        <span class="kr">if</span> <span class="n">isDir</span> <span class="o">&amp;&amp;</span> <span class="n">curDepth</span> <span class="o">&lt;</span> <span class="n">cfgMaxDepth</span> <span class="n">cfg</span>
          <span class="kr">then</span> <span class="kr">do</span>
            <span class="kr">let</span> <span class="n">newDepth</span> <span class="ow">=</span> <span class="n">curDepth</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">st</span> <span class="ow">&lt;-</span> <span class="n">get</span>
            <span class="n">when</span> <span class="p">(</span><span class="n">stDeepestReached</span> <span class="n">st</span> <span class="o">&lt;</span> <span class="n">newDepth</span><span class="p">)</span> <span class="o">$</span>
              <span class="n">put</span> <span class="n">st</span> <span class="p">{</span><span class="n">stDeepestReached</span> <span class="ow">=</span> <span class="n">newDepth</span><span class="p">}</span>
            <span class="n">constrainedCount</span> <span class="n">newDepth</span> <span class="n">newPath</span>
          <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
    <span class="n">return</span> <span class="o">$</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">length</span> <span class="n">contents</span><span class="p">)</span> <span class="kt">:</span> <span class="n">concat</span> <span class="n">rest</span>
</pre></div>
</div>
<p>在这个例子中如此运用monad变换器确实有些小题大做，因为这仅仅是个简单函数，其并没有因此得到太多的好处。但是这个方法的实用性在于，可以将其 <em>轻易扩展以解决更加复杂的问题</em> 。</p>
<p>大部分指令式的应用可以使用和这里的 <code class="docutils literal"><span class="pre">App</span></code> monad类似的方法，在monad栈中编写。在实际的程序中，或许需要携带更复杂的配置数据，但依旧可以使用 <code class="docutils literal"><span class="pre">ReaderT</span></code> 以保持其只读，并只在需要时暴露配置；或许有更多可变状态需要管理，但依旧可以使用 <code class="docutils literal"><span class="pre">StateT</span></code> 封装它们。</p>
</div>
<div class="section" id="id5">
<h3>隐藏细节<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>使用常规的 <code class="docutils literal"><span class="pre">newtype</span></code> 技术，便可将细节与接口分离开：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">MyApp</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MyA</span>
  <span class="p">{</span> <span class="n">runA</span> <span class="ow">::</span> <span class="kt">ReaderT</span> <span class="kt">AppConfig</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">AppState</span> <span class="kt">IO</span><span class="p">)</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Monad</span><span class="p">,</span> <span class="kt">MonadIO</span><span class="p">,</span> <span class="kt">MonadReader</span> <span class="kt">AppConfig</span><span class="p">,</span>
              <span class="kt">MonadState</span> <span class="kt">AppState</span><span class="p">)</span>

<span class="nf">runMyApp</span> <span class="ow">::</span> <span class="kt">MyApp</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">AppState</span><span class="p">)</span>
<span class="nf">runMyApp</span> <span class="n">k</span> <span class="n">maxDepth</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">config</span> <span class="ow">=</span> <span class="kt">AppConfig</span> <span class="n">maxDepth</span>
        <span class="n">state</span> <span class="ow">=</span> <span class="kt">AppState</span> <span class="mi">0</span>
    <span class="kr">in</span> <span class="n">runStateT</span> <span class="p">(</span><span class="n">runReaderT</span> <span class="p">(</span><span class="n">runA</span> <span class="n">k</span><span class="p">)</span> <span class="n">config</span><span class="p">)</span> <span class="n">state</span>
</pre></div>
</div>
<p>若只导出 <code class="docutils literal"><span class="pre">MyApp</span></code> 类构造器和 <code class="docutils literal"><span class="pre">runMyApp</span></code> 执行函数，客户端的代码就无法知晓这个monad的内部结构是否是monad栈了。</p>
<p>此处，庞大的 <code class="docutils literal"><span class="pre">deriving</span></code> 子句需要 <code class="docutils literal"><span class="pre">GeneralizedNewtypeDeriving</span></code> 语言编译选项。编译器可以为我们生成这些实例，这看似十分神奇，究竟是如何做到的呢？</p>
<p>早先，我们提到 <code class="docutils literal"><span class="pre">mtl</span></code> 库为每个monad变换器都提供了一系列实例。例如 <code class="docutils literal"><span class="pre">IO</span></code> monad实现了 <code class="docutils literal"><span class="pre">MonadIO</span></code> ，若下层monad是 <code class="docutils literal"><span class="pre">MonadIO</span></code> 的实例，那么 <code class="docutils literal"><span class="pre">mtl</span></code> 也将为其对应的 <code class="docutils literal"><span class="pre">StateT</span></code> 构建一个 <code class="docutils literal"><span class="pre">MonadIO</span></code> 的实例，类似的事情也发生在 <code class="docutils literal"><span class="pre">ReaderT</span></code> 上。</p>
<p>因此，这其中并无太多神奇之处：位于monad栈顶层的monad变换器，已是所有我们声明的 <code class="docutils literal"><span class="pre">deriving</span></code> 子句中的类型类的实例，我们做的只不过是重新派生这些实例。这是 <code class="docutils literal"><span class="pre">mtl</span></code> 精心设计的一系列类型类和实例完美配合的结果。除了基于 <code class="docutils literal"><span class="pre">newtype</span></code> 声明的常规的自动推导以外并没有发生什么。</p>
<p>[译注：注意到此处 <code class="docutils literal"><span class="pre">newtype</span> <span class="pre">MyApp</span> <span class="pre">a</span></code> 只是乔装过的 <code class="docutils literal"><span class="pre">ReaderT</span> <span class="pre">AppConfig</span> <span class="pre">(StateT</span> <span class="pre">AppState</span> <span class="pre">IO)</span> <span class="pre">a</span></code> 。因此我们可以列出 <code class="docutils literal"><span class="pre">MyApp</span> <span class="pre">a</span></code> 这个monad栈的全貌（自顶向下）：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">ReaderT</span> <span class="pre">AppConfig</span></code> （monad变换器）</li>
<li><code class="docutils literal"><span class="pre">StateT</span> <span class="pre">AppState</span></code> （monad变换器）</li>
<li><code class="docutils literal"><span class="pre">IO</span></code> （monad）</li>
</ul>
<p>注意这个monad栈和 <code class="docutils literal"><span class="pre">deriving</span></code> 子句中类型类的相似度。这些实例都可以自动派生： <code class="docutils literal"><span class="pre">MonadIO</span></code> 实例自底层派生上来， <code class="docutils literal"><span class="pre">MonadStateT</span></code> 从中间一层派生，而 <code class="docutils literal"><span class="pre">MonadReader</span></code> 实例来自顶层。所以虽然 <code class="docutils literal"><span class="pre">newtype</span> <span class="pre">MyApp</span> <span class="pre">a</span></code> 引入了一个全新的类型，其实例是可以通过内部结构自动推导的。]</p>
</div>
<div class="section" id="id6">
<h3>练习<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>修改 <code class="docutils literal"><span class="pre">App</span></code> 类型别名以交换 <code class="docutils literal"><span class="pre">ReaderT</span></code> 和 <code class="docutils literal"><span class="pre">StateT</span></code> 的位置，这一变换对执行函数 <code class="docutils literal"><span class="pre">runApp</span></code> 会带来什么影响？</li>
<li>为 <code class="docutils literal"><span class="pre">App</span></code> monad栈添加 <code class="docutils literal"><span class="pre">WriterT</span></code> 变换器。 相应地修改 <code class="docutils literal"><span class="pre">runApp</span></code> 。</li>
<li>重写 <code class="docutils literal"><span class="pre">contrainedCount</span></code> 函数，在为 <code class="docutils literal"><span class="pre">App</span></code> 新添加的 <code class="docutils literal"><span class="pre">WriterT</span></code> 中记录结果。</li>
</ol>
<p>[译注：第一题中的 <code class="docutils literal"><span class="pre">StateT</span></code> 原为 <code class="docutils literal"><span class="pre">WriterT</span></code> ，鉴于 <code class="docutils literal"><span class="pre">App</span></code> 定义中并无 <code class="docutils literal"><span class="pre">WriterT</span></code> ，此处应该指的是 <code class="docutils literal"><span class="pre">StateT</span></code> ]</p>
</div>
</div>
<div class="section" id="id7">
<h2>深入Monad栈中<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>至今，我们了解了对monad变换器的简单运用。对 <code class="docutils literal"><span class="pre">mtl</span></code> 库的便利组合拼接使我们免于了解monad栈构造的细节。我们确实已掌握了足以帮助我们简化大量常见编程任务的monad变换器相关知识。</p>
<p>但有时，为了实现一些实用的功能，还是我们需要了解 <code class="docutils literal"><span class="pre">mtl</span></code> 库并不便利的一面。这些任务可能是将定制的monad置于monad栈底，也可能是将定制的monad变换器置于monad变换器栈中的某处。为了解其中潜在的难度，我们讨论以下例子。</p>
<p>假设我们有个定制的monad变换器 <code class="docutils literal"><span class="pre">CustomT</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/CustomT.hs</span>
<span class="kr">newtype</span> <span class="kt">CustomT</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">mtl</span></code> 提供的框架中，每个位于栈上的monad变换器都将其下层monad的API暴露出来。这是通过提供大量的类型类实例来实现的。遵从这一模式的规则，我们也可以实现一系列的样板实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/CustomT.hs</span>
<span class="kr">instance</span> <span class="kt">MonadReader</span> <span class="n">r</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadReader</span> <span class="n">r</span> <span class="p">(</span><span class="kt">CustomT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="o">...</span>

<span class="kr">instance</span> <span class="kt">MonadIO</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadIO</span> <span class="p">(</span><span class="kt">CustomT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>若下层monad是 <code class="docutils literal"><span class="pre">MonadReader</span></code> 的实例，则 <code class="docutils literal"><span class="pre">CustomT</span></code> 也可作为 <code class="docutils literal"><span class="pre">MonadReader</span></code> 的实例： 实例化的方法是将所有相关的API调用转接给其下层实例的相应函数。经过实例化之后，上层的代码就可以将monad栈作为一个整体，当作 <code class="docutils literal"><span class="pre">MonadReader</span></code> 的实例，而不再需要了解或关心到底是其中的哪一层提供了具体的实现。</p>
<p>不同于这种依赖类型类实例的方法，我们也可以显式指定想要使用的API。 <code class="docutils literal"><span class="pre">MonadTrans</span></code> 类型类定义了一个实用的函数 <code class="docutils literal"><span class="pre">lift</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span><span class="o">.</span><span class="kt">Trans</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">MonadTrans</span>
<span class="kr">class</span> <span class="kt">MonadTrans</span> <span class="n">t</span> <span class="kr">where</span> <span class="n">lift</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">m</span> <span class="n">a</span>
      <span class="c1">-- Defined in Control.Monad.Trans</span>
</pre></div>
</div>
<p>这个函数接受来自monad栈中，当前栈下一层的monad动作，并将这个动作变成，或者说是 <em>抬举</em> 到现在的monad变换器中。每个monad变换器都是 <code class="docutils literal"><span class="pre">MonadTrans</span></code> 的实例。</p>
<p><code class="docutils literal"><span class="pre">lift</span></code> 这个名字是基于此函数与 <code class="docutils literal"><span class="pre">fmap</span></code> 和 <code class="docutils literal"><span class="pre">liftM</span></code> 目的上的相似度的。这些函数都可以从类型系统的下一层中把东西提升到我们目前工作的这一层。它们的区别是：</p>
<dl class="docutils">
<dt>fmap</dt>
<dd>将纯函数提升到functor层次</dd>
<dt>liftM</dt>
<dd>将纯函数提升到monad层次</dd>
<dt>lift</dt>
<dd>将一monad动作，从monad栈中的下一层提升到本层</dd>
</dl>
<p>[译注：实际上 <code class="docutils literal"><span class="pre">liftM</span></code> 间接调用了 <code class="docutils literal"><span class="pre">fmap</span></code> ，两个函数在效果上是完全一样的。译者认为，当操作对象是monad（所有的monad都是functor）的时候，使用其中的哪一个只是思考方法上的不同。]</p>
<p>现在重新考虑我们在早些时候定义的 <code class="docutils literal"><span class="pre">App</span></code> monad栈 (之前我们将其包装在 <code class="docutils literal"><span class="pre">newtype</span></code> 中)：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="kr">type</span> <span class="kt">App</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">AppConfig</span> <span class="p">(</span><span class="kt">StateT</span> <span class="kt">AppState</span> <span class="kt">IO</span><span class="p">)</span>
</pre></div>
</div>
<p>若想访问 <code class="docutils literal"><span class="pre">StateT</span></code> 所携带的 <code class="docutils literal"><span class="pre">AppState</span></code> ，通常需要依赖 <code class="docutils literal"><span class="pre">mtl</span></code> 的类型类实例来为我们处理组合工作：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="nf">implicitGet</span> <span class="ow">::</span> <span class="kt">App</span> <span class="kt">AppState</span>
<span class="nf">implicitGet</span> <span class="ow">=</span> <span class="n">get</span>
</pre></div>
</div>
<p>通过将 <code class="docutils literal"><span class="pre">get</span></code> 函数从 <code class="docutils literal"><span class="pre">StateT</span></code> 中抬举进 <code class="docutils literal"><span class="pre">ReaderT</span></code> ， <code class="docutils literal"><span class="pre">lift</span></code> 函数也可以实现同样的效果：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/UglyStack.hs</span>
<span class="nf">explicitGet</span> <span class="ow">::</span> <span class="kt">App</span> <span class="kt">AppState</span>
<span class="nf">explicitGet</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">get</span>
</pre></div>
</div>
<p>显然当 <code class="docutils literal"><span class="pre">mtl</span></code> 可以为我们完成这一工作时，代码会变得更清晰。但是 <code class="docutils literal"><span class="pre">mtl</span></code> 并不总能完成这类工作。</p>
<div class="section" id="id8">
<h3>何时需要显式的抬举？<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>我们必须使用 <code class="docutils literal"><span class="pre">lift</span></code> 的一个例子是：当在一个monad栈中，同一个类型类的实例出现了多次时：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/StackStack.hs</span>
<span class="kr">type</span> <span class="kt">Foo</span> <span class="ow">=</span> <span class="kt">StateT</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">String</span><span class="p">)</span>
</pre></div>
</div>
<p>若此时我们试着使用 <code class="docutils literal"><span class="pre">MonadState</span></code> 类型类中的 <code class="docutils literal"><span class="pre">put</span></code> 动作，得到的实例将是 <code class="docutils literal"><span class="pre">StateT</span> <span class="pre">Int</span></code> ，因为这个实例在monad栈顶。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/StackStack.hs</span>
<span class="nf">outerPut</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span> <span class="nb">()</span>
<span class="nf">outerPut</span> <span class="ow">=</span> <span class="n">put</span>
</pre></div>
</div>
<p>在这个情况下，唯一能访问下层 <code class="docutils literal"><span class="pre">State</span></code> monad的 <code class="docutils literal"><span class="pre">put</span></code> 函数的方法是使用 <code class="docutils literal"><span class="pre">lift</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/StackStack.hs</span>
<span class="nf">innerPut</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Foo</span> <span class="nb">()</span>
<span class="nf">innerPut</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">put</span>
</pre></div>
</div>
<p>有时我们需要访问多于一层以下的monad，这时我们必须组合 <code class="docutils literal"><span class="pre">lift</span></code> 调用。每个函数组合中的 <code class="docutils literal"><span class="pre">lift</span></code> 将我们带到更深的一层。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/StackStack.hs</span>
<span class="kr">type</span> <span class="kt">Bar</span> <span class="ow">=</span> <span class="kt">ReaderT</span> <span class="kt">Bool</span> <span class="kt">Foo</span>

<span class="nf">barPut</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Bar</span> <span class="nb">()</span>
<span class="nf">barPut</span> <span class="ow">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">put</span>
</pre></div>
</div>
<p>正如以上代码所示，当需要用 <code class="docutils literal"><span class="pre">lift</span></code> 的时候，一个好习惯是定义并使用包裹函数来为我们完成抬举工作。因为这种在代码各处显式使用lift的方法使代码变得混乱。另一个显式lift的缺点在于，其硬编码了monad栈的层次细节，这将使日后对monad栈的修改变得复杂。</p>
</div>
</div>
<div class="section" id="id9">
<h2>构建以理解Monad变换器<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>为了深入理解monad变换器通常是如何运作的，在本节我们将自己构建一个monad变换器，期间一并讨论其中的组织结构。我们的目标简单而实用： <code class="docutils literal"><span class="pre">MaybeT</span></code> 。但是 <code class="docutils literal"><span class="pre">mtl</span></code> 库意外地并没有提供它。</p>
<p>[译注：如果想使用现成的 <code class="docutils literal"><span class="pre">MaybeT</span></code> ，现在你可以在 Hackage 上的 <code class="docutils literal"><span class="pre">transformers</span></code> 库中找到它。]</p>
<p>这个monad变换器修改monad的方法是：将下层monad <code class="docutils literal"><span class="pre">m</span> <span class="pre">a</span></code> 的类型参数
包装在 <code class="docutils literal"><span class="pre">Maybe</span></code> 中，以得到类型 <code class="docutils literal"><span class="pre">m</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code> 。正如 <code class="docutils literal"><span class="pre">Maybe</span></code> monad一样，若在 <code class="docutils literal"><span class="pre">MaybeT</span></code> monad变换器中调用 <code class="docutils literal"><span class="pre">fail</span></code> ，则计算将提早结束执行。</p>
<p>为使 <code class="docutils literal"><span class="pre">m</span> <span class="pre">(Maybe</span> <span class="pre">a)</span></code> 成为 <code class="docutils literal"><span class="pre">Monad</span></code> 的实例，其必须有个独特的类型。这里我们通过 <code class="docutils literal"><span class="pre">newtype</span></code> 声明来实现：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="kr">newtype</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MaybeT</span>
  <span class="p">{</span> <span class="n">runMaybeT</span> <span class="ow">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>现在需要定义三个标准的monad函数。其中最复杂的是 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> ，它的实现也阐明了我们实际上在做什么。在开始研究其操作之前，不妨先看看其类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="nf">bindMT</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>为理解其类型签名，回顾之前在十五章中对“多参数类型类”讨论。此处我们想使 <em>部分类型</em> <code class="docutils literal"><span class="pre">MaybeT</span> <span class="pre">m</span></code> 成为 <code class="docutils literal"><span class="pre">Monad</span></code> 的实例。这个部分类型拥有通常的单一类型参数 <code class="docutils literal"><span class="pre">a</span></code> ，这样便能满足 <code class="docutils literal"><span class="pre">Monad</span></code> 类型类的要求。</p>
<p>[译注： <code class="docutils literal"><span class="pre">MaybeT</span></code> 的完整定义是 <code class="docutils literal"><span class="pre">MaybeT</span> <span class="pre">m</span> <span class="pre">a</span></code> ，因此 <code class="docutils literal"><span class="pre">MaybeT</span> <span class="pre">m</span></code> 只是部分应用。]</p>
<p>理解以下 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 实现的关键在于： <code class="docutils literal"><span class="pre">do</span></code> 代码块里的代码是在 <em>下层</em> monad中执行的，无论这个下层monad是什么。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">bindMT</span><span class="p">`</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">unwrapped</span> <span class="ow">&lt;-</span> <span class="n">runMaybeT</span> <span class="n">x</span>
    <span class="kr">case</span> <span class="n">unwrapped</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="kt">Nothing</span>
      <span class="kt">Just</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">runMaybeT</span> <span class="p">(</span><span class="n">f</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>我们的 <code class="docutils literal"><span class="pre">runMaybeT</span></code> 函数解开了在 <code class="docutils literal"><span class="pre">x</span></code> 中包含的结果。进而，注意到 <code class="docutils literal"><span class="pre">&lt;-</span></code> 符号是 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 的语法糖：monad变换器必须使用其下层monad的 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 。而最后一部分对 <code class="docutils literal"><span class="pre">unwrapped</span></code> 的结构分析（ <code class="docutils literal"><span class="pre">case</span></code> 表达式），决定了我们是要短路当前计算，还是将计算继续下去。最后，观察表达式的最外层。为了将下层monad再次藏起来，这里必须用 <code class="docutils literal"><span class="pre">MaybeT</span></code> 构造器包装结果。</p>
<p>刚才展示的 <code class="docutils literal"><span class="pre">do</span></code> 标记看起来更容易阅读，但是其将我们依赖下层monad的 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 函数的事实也藏了起来。下面提供一个更符合语言习惯的 <code class="docutils literal"><span class="pre">MaybeT</span></code> 的 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 实现：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">altBindMT</span><span class="p">`</span> <span class="n">f</span> <span class="ow">=</span>
    <span class="kt">MaybeT</span> <span class="o">$</span> <span class="n">runMaybeT</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">maybe</span> <span class="p">(</span><span class="n">return</span> <span class="kt">Nothing</span><span class="p">)</span> <span class="p">(</span><span class="n">runMaybeT</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们了解了 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 在干些什么。关于 <code class="docutils literal"><span class="pre">return</span></code> 和 <code class="docutils literal"><span class="pre">fail</span></code> 无需太多解释， <code class="docutils literal"><span class="pre">Monad</span></code> 实例也不言自明：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="nf">returnMT</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">returnMT</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="o">$</span> <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span>

<span class="nf">failMT</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">MaybeT</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">failMT</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="o">$</span> <span class="n">return</span> <span class="kt">Nothing</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">MaybeT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="ow">=</span> <span class="n">returnMT</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bindMT</span>
  <span class="n">fail</span> <span class="ow">=</span> <span class="n">failM</span>
</pre></div>
</div>
<div class="section" id="id10">
<h3>建立Monad变换器<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>为将我们的类型变成monad变换器，必须提供 <code class="docutils literal"><span class="pre">MonadTrans</span></code> 的实例，以使用户可以访问下层monad：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="kt">MaybeT</span> <span class="kr">where</span>
    <span class="n">lift</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">m</span><span class="p">)</span>
</pre></div>
</div>
<p>下层monad以类型 <code class="docutils literal"><span class="pre">a</span></code> 开始：我们“注入” <code class="docutils literal"><span class="pre">Just</span></code> 构造器以使其变成需要的类型： <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></code> 。进而我们通过 <code class="docutils literal"><span class="pre">MaybeT</span></code> 藏起下层monad。</p>
</div>
<div class="section" id="id11">
<h3>更多的类型类实例<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>在定义好 <code class="docutils literal"><span class="pre">MonadTrans</span></code> 的实例后，便可用其来定义其他大量的 <code class="docutils literal"><span class="pre">mtl</span></code> 类型类实例了：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadIO</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadIO</span> <span class="p">(</span><span class="kt">MaybeT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">liftIO</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">liftIO</span> <span class="n">m</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">MonadState</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">MonadState</span> <span class="n">s</span> <span class="p">(</span><span class="kt">MaybeT</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">get</span> <span class="ow">=</span> <span class="n">lift</span> <span class="n">get</span>
  <span class="n">put</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">put</span> <span class="n">k</span><span class="p">)</span>

<span class="c1">-- ... 对 MonadReader，MonadWriter等的实例定义同理 ...</span>
</pre></div>
</div>
<p>由于一些 <code class="docutils literal"><span class="pre">mtl</span></code> 类型类使用了函数式依赖，有些实例的声明需要GHC大大放宽其原有的类型检查规则。(若我们忘记了其中任意的 <code class="docutils literal"><span class="pre">LANGUAGE</span></code> 指令，编译器会在其错误信息中提供建议。)</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MaybeT.hs</span>
<span class="cm">{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses,</span>
<span class="cm">             UndecidableInstances #-}</span>
</pre></div>
</div>
<p>是花些时间来写这些样板实例呢，还是显式地使用 <code class="docutils literal"><span class="pre">lift</span></code> 呢？这取决于这个monad变换器的用途。 如果我们只在几种有限的情况下使用它，那么只提供 <code class="docutils literal"><span class="pre">MonadTrans</span></code> 实例就够了。在这种情况下，也无妨提供一些依然有意义的实例，比如 <code class="docutils literal"><span class="pre">MonadIO</span></code>。另一方面，若我们需要在大量的情况下使用这一monad变换器，那么花些时间来完成这些实例或许也不错。</p>
</div>
<div class="section" id="monadparse">
<h3>以Monad栈替代Parse类型<a class="headerlink" href="#monadparse" title="Permalink to this headline">¶</a></h3>
<p>现在我们已开发了一个支持提早退出的monad变换器，可以用其来辅助开发了。例如，此处若想处理解析一半失败的情况，便可以用这一以我们的需求定制的monad变换器来替代我们在第十章“隐式状态”一节开发的 <code class="docutils literal"><span class="pre">Parse</span></code> 类型。</p>
</div>
<div class="section" id="id12">
<h3>练习<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>我们的Parse monad还不是之前版本的完美替代。因为其用的是 <code class="docutils literal"><span class="pre">Maybe</span></code> 而不是 <code class="docutils literal"><span class="pre">Either</span></code> 来代表结果。因此在失败时暂时无法提供任何有用的信息。</li>
</ol>
<blockquote>
<div>构建一个 <code class="docutils literal"><span class="pre">EitherT</span> <span class="pre">s</span></code> （其中 <code class="docutils literal"><span class="pre">s</span></code> 是某个类型）来表示结果，并用其实现更适合的 <code class="docutils literal"><span class="pre">Parse</span></code> monad以在解析失败时汇报具体错误信息。</div></blockquote>
<p>或许在你探索Haskell库的途中，在 <code class="docutils literal"><span class="pre">Control.Monad.Error</span></code> 遇到过一个 <code class="docutils literal"><span class="pre">Either</span></code> 类型的 <code class="docutils literal"><span class="pre">Monad</span></code> 实例。
我们建议不要参照它来完成你的实现，因为它的设计太局限了：虽然其将 <code class="docutils literal"><span class="pre">Either</span> <span class="pre">String</span></code> 变成一个monad，
但实际上把 <code class="docutils literal"><span class="pre">Either</span></code> 的第一个类型参数限定为 <code class="docutils literal"><span class="pre">String</span></code> 并非必要。</p>
<p>提示: 若你按照这条建议来做，你的定义中或许需要使用 <code class="docutils literal"><span class="pre">FlexibleInstances</span></code> 语言扩展。</p>
</div>
</div>
<div class="section" id="id13">
<h2>注意变换器堆叠顺序<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>从早先使用 <code class="docutils literal"><span class="pre">ReaderT</span></code> 和 <code class="docutils literal"><span class="pre">StateT</span></code> 的例子中，你或许会认为叠加monad变换器的顺序并不重要。事实并非如此，考虑在 <code class="docutils literal"><span class="pre">State</span></code> 上叠加 <code class="docutils literal"><span class="pre">StateT</span></code> 的情况，或许会助于你更清晰地意识到：堆叠的顺序确实产生了结果上的区别：类型 <code class="docutils literal"><span class="pre">StateT</span> <span class="pre">Int</span> <span class="pre">(State</span> <span class="pre">String)</span></code> 和类型 <code class="docutils literal"><span class="pre">StateT</span> <span class="pre">String</span> <span class="pre">(State</span> <span class="pre">Int)</span></code> 或许携带的信息相同，但它们却无法互换使用。叠加的顺序决定了我们是否要用 <code class="docutils literal"><span class="pre">lift</span></code> 来取得状态中的某个部分。</p>
<p>下面的例子更加显著地阐明了顺序的重要性。假设有个可能失败的计算，而我们想记录下在什么情况下其会失败：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MTComposition.hs</span>
<span class="cm">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>
<span class="kr">import</span> <span class="nn">MaybeT</span>

<span class="nf">problem</span> <span class="ow">::</span> <span class="kt">MonadWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">problem</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;this is where i fail&quot;</span><span class="p">]</span>
  <span class="n">fail</span> <span class="s">&quot;oops&quot;</span>
</pre></div>
</div>
<p>那么这两个monad栈中的哪一个会带给我们需要的信息呢？</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">WriterT</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Maybe</span>

<span class="kr">type</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="p">(</span><span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>

<span class="nf">a</span> <span class="ow">::</span> <span class="kt">A</span> <span class="nb">()</span>
<span class="nf">a</span> <span class="ow">=</span> <span class="n">problem</span>

<span class="nf">b</span> <span class="ow">::</span> <span class="kt">B</span> <span class="nb">()</span>
<span class="nf">b</span> <span class="ow">=</span> <span class="n">problem</span>
</pre></div>
</div>
<p>我们在 <code class="docutils literal"><span class="pre">ghci</span></code> 中试试看：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runWriterT</span> <span class="n">a</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runWriter</span> <span class="o">$</span> <span class="n">runMaybeT</span> <span class="n">b</span>
<span class="p">(</span><span class="kt">Nothing</span><span class="p">,[</span><span class="s">&quot;this is where i fail&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>看看执行函数的类型签名，其实结果并不意外：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">runWriterT</span>
<span class="nf">runWriterT</span> <span class="ow">::</span> <span class="kt">WriterT</span> <span class="n">w</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">runWriter</span> <span class="o">.</span> <span class="n">runMaybeT</span>
<span class="nf">runWriter</span> <span class="o">.</span> <span class="n">runMaybeT</span> <span class="ow">::</span> <span class="kt">MaybeT</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>在 <code class="docutils literal"><span class="pre">Maybe</span></code> 上叠加 <code class="docutils literal"><span class="pre">WriterT</span></code> 的策略使 <code class="docutils literal"><span class="pre">Maybe</span></code> 成为下层monad，因此 <code class="docutils literal"><span class="pre">runWriterT</span></code> 必须给我们以 <code class="docutils literal"><span class="pre">Maybe</span></code> 为类型的结果。在测试样例中，我们只会在不出现任何失败的情况下才能获得日志！</p>
<p>叠加monad变换器类似于组合函数：如果我们改变函数应用的顺序，那么我们并不会对得到不同的结果感到意外。同样的道理也适用于对monad变换器的叠加。</p>
</div>
<div class="section" id="id14">
<h2>纵观Monad与Monad变换器<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>本节，让我们暂别细节，讨论一下用monad和monad变换器编程的优缺点。</p>
<div class="section" id="id15">
<h3>对纯代码的干涉<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>在实际编程中，使用monad的最恼人之处或许在于其阻碍了我们使用纯代码。很多实用的纯函数需要一个monad版的类似函数，而其monad版只是加上一个占位参数 <code class="docutils literal"><span class="pre">m</span></code> 供monad类型构造器填充：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">filter</span>
<span class="nf">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="n">filterM</span>
<span class="nf">filterM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
      <span class="c1">-- Defined in Control.Monad</span>
</pre></div>
</div>
<p>然而，这种覆盖是有限的：标准库中并不总能提供纯函数的monad版本。</p>
<p>其中有一部分历史原因：Eugenio Moggi于1988年引入了使用monad编程的思想。而当时Haskell 1.0标准尚在开发中。现今版本的 <code class="docutils literal"><span class="pre">Prelude</span></code> 中的大部分函数可以追溯到于1990发布的Haskell 1.0。在1991年，Philip Wadler开始为更多的函数式编程听众作文，阐述monad的潜力。从那时起，monad开始用于实践。</p>
<p>直到1996年Haskell 1.3标准发布之时，monad才得到了支持。但是在那时，语言的设计者已经受制于维护向前兼容性: 它们无法改变 <code class="docutils literal"><span class="pre">Prelude</span></code> 中的函数签名，因为那会破坏现有的代码。</p>
<p>从那以后，Haskell社区学会了很多合适的抽象。因此我们可以写出不受这一纯函数／monad函数分裂影响的代码。你可以在 <code class="docutils literal"><span class="pre">Data.Traversable</span></code> 和 <code class="docutils literal"><span class="pre">Data.Foldable</span></code> 中找到这些思想的精华。</p>
<p>尽管它们极具吸引力，由于版面的限制。我们不会在本书中涵盖相关内容。但如果你能轻易理解本章内容，自行理解它们也不会有问题。</p>
<p>在理想世界里，我们是否会与过去断绝，并让 <code class="docutils literal"><span class="pre">Prelude</span></code> 包含 <code class="docutils literal"><span class="pre">Traversable</span></code> 和 <code class="docutils literal"><span class="pre">Foldable</span></code> 类型呢？或许不会，因为学习Haskell本身对新手来说已经是个相当刺激的历程了。在我们已经了解functor和monad之后， <code class="docutils literal"><span class="pre">Foldable</span></code> 和 <code class="docutils literal"><span class="pre">Traversable</span></code> 的抽象是十分容易理解的。但是对学习者来说这意味着摆在他们面前的是更多纯粹的抽象。若以教授语言为目的， <code class="docutils literal"><span class="pre">map</span></code> 操作的最好是列表，而不是functor。</p>
<p>[译注：实际上，自GHC 7.10开始， <code class="docutils literal"><span class="pre">Foldable</span></code> 和 <code class="docutils literal"><span class="pre">Traversable</span></code> 已经进入了 <code class="docutils literal"><span class="pre">Prelude</span></code> 。
一些函数的类型签名会变得更加抽象（以GHC 7.10.1为例）：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">-</span><span class="mf">7.10</span><span class="o">.</span><span class="mi">1</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">mapM</span>
<span class="nf">mapM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Traversable</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">t</span> <span class="n">b</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">-</span><span class="mf">7.10</span><span class="o">.</span><span class="mi">1</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">foldl</span>
<span class="nf">foldl</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>这并不是一个对初学者友好的改动，但由于新的函数只是旧有函数的推广形式，使用旧的函数签名依旧可以通过类型检查：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">-</span><span class="mf">7.10</span><span class="o">.</span><span class="mi">1</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">mapM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>
<span class="p">(</span><span class="n">mapM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span>
  <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">-</span><span class="mf">7.10</span><span class="o">.</span><span class="mi">1</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="n">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">(</span><span class="n">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span>
  <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>若在学习过程中遇到障碍，不妨暂且以旧的类型签名来理解它们。]</p>
</div>
<div class="section" id="id16">
<h3>对次序的过度限定<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>我们使用monad的一个基本原因是：其允许我们指定效果发生的次序。再看看我们早先写的一小段代码：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch18/MTComposition.hs</span>
<span class="cm">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>
<span class="kr">import</span> <span class="nn">MaybeT</span>

<span class="nf">problem</span> <span class="ow">::</span> <span class="kt">MonadWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">problem</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;this is where i fail&quot;</span><span class="p">]</span>
  <span class="n">fail</span> <span class="s">&quot;oops&quot;</span>
</pre></div>
</div>
<p>因为我们在monad中执行， <code class="docutils literal"><span class="pre">tell</span></code> 的效果可以保证发生在 <code class="docutils literal"><span class="pre">fail</span></code> 之前。这里的问题在于，这个次序并不必要，但是我们却得到了这样的次序保证。编译器无法任意安排monad式代码的次序，即便这么做能使代码效率更高。</p>
<p>[译注：解释一下这里的“次序并不必要”。回顾之前对叠加次序问题的讨论：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">WriterT</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Maybe</span>

<span class="kr">type</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">MaybeT</span> <span class="p">(</span><span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>

<span class="nf">a</span> <span class="ow">::</span> <span class="kt">A</span> <span class="nb">()</span>
<span class="nf">a</span> <span class="ow">=</span> <span class="n">problem</span>
<span class="c1">-- runWriterT a == Nothing</span>

<span class="nf">b</span> <span class="ow">::</span> <span class="kt">B</span> <span class="nb">()</span>
<span class="nf">b</span> <span class="ow">=</span> <span class="n">problem</span>
<span class="c1">-- runWriter (runMaybeT b) == (Nothing, [&quot;this is where i fail&quot;])</span>
</pre></div>
</div>
<p>下面把注意力集中于 <code class="docutils literal"><span class="pre">a</span></code> ： 注意到 <code class="docutils literal"><span class="pre">runWriterT</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">Nothing</span></code> ， <code class="docutils literal"><span class="pre">tell</span></code> 的结果并不需要，因为接下来的 <code class="docutils literal"><span class="pre">fail</span></code> 取消了计算，将之前的结果抛弃了。利用这个事实，可以得知让 <code class="docutils literal"><span class="pre">fail</span></code> 先执行效率更高。同时注意对 <code class="docutils literal"><span class="pre">fail</span></code> 和 <code class="docutils literal"><span class="pre">tell</span></code> 的实际处理来自monad栈的不同层，所以在一定限制下调换某些操作的顺序会不影响结果。但是由于这个monad栈本身也要是个monad，使这种本来可以进行的交换变得不可能了。]</p>
</div>
<div class="section" id="id17">
<h3>运行时开销<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>最后，当我们使用monad和monad变换器时，需要付出一些效率的代价。 例如 <code class="docutils literal"><span class="pre">State</span></code> monad携带状态并将其放在一个闭包中。在Haskell的实现中，闭包的开销或许廉价但绝非免费。</p>
<p>Monad变换器把其自身的开销附加在了其下层monad之上。每次我们使用 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 时，MaybeT变换器便需要包装和解包。而由 <code class="docutils literal"><span class="pre">ReaderT</span></code> ， <code class="docutils literal"><span class="pre">StateT</span></code> 和 <code class="docutils literal"><span class="pre">MaybeT</span></code> 依次叠加组成的monad栈，在每次使用 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 时，更是有一系列的簿记工作需要完成。</p>
<p>一个足够聪明的编译器或许可以将这些开销部分，甚至于全部消除。但是那种深度的复杂工作尚未广泛适用。</p>
<p>但是依旧有些相对简单技术可以避免其中的一些开销，版面的限制只允许我们在此做简单描述。例如，在continuation monad中，对 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 频繁的包装和解包可以避免，仅留下执行效果的开销。所幸的是使用这种方法所要考虑的大部分复杂问题，已经在函数库中得到了处理。</p>
<p>这一部分的工作在本书写作时尚在积极的开发中。如果你想让你对monad变换器的使用更加高效，我们推荐在Hackage中寻找相关的库或是在邮件列表或IRC上寻求指引。</p>
</div>
<div class="section" id="id18">
<h3>缺乏灵活性的接口<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>若我们只把 <code class="docutils literal"><span class="pre">mtl</span></code> 当作黑盒，那么所有的组件将很好地合作。但是若我们开始开发自己的monad和monad变换器，并想让它们于 <code class="docutils literal"><span class="pre">mtl</span></code> 提供的组件配合，这种缺陷便显现出来了。</p>
<p>例如，我们开发一个新的monad变换器 <code class="docutils literal"><span class="pre">FooT</span></code> ，并想沿用 <code class="docutils literal"><span class="pre">mtl</span></code> 中的模式。我们就必须实现一个类型类 <code class="docutils literal"><span class="pre">MonadFoo</span></code> 。若我们想让其更好地和 <code class="docutils literal"><span class="pre">mtl</span></code> 配合，那么便需要提供大量的实例来支持 <code class="docutils literal"><span class="pre">mtl</span></code> 中的类型类。</p>
<p>除此之外，还需要为每个 <code class="docutils literal"><span class="pre">mtl</span></code> 中的变换器提供 <code class="docutils literal"><span class="pre">MonadFoo</span></code> 的实例。大部分的实例实现几乎是完全一样的，写起来也十分乏味。若我们想在 <code class="docutils literal"><span class="pre">mtl</span></code> 中集成更多的monad变换器，那么我们需要处理的各类活动部件将达到引入的monad变换器数量的 <em>平方级别</em> ！</p>
<p>公平地看来，这个问题会只影响到少数人。大部分 <code class="docutils literal"><span class="pre">mtl</span></code> 的用户并不需要开发新的monad。</p>
<p>造成这一 <code class="docutils literal"><span class="pre">mtl</span></code> 设计缺陷的原因在于，它是第一个monad变换器的函数库。想像其设计者投入这个未知的领域，完成了大量的工作以使这个强大的函数库对于大部分用户来说做到简便易用。</p>
<p>一个新的关于monad和变换器的函数库 <code class="docutils literal"><span class="pre">monadLib</span></code> ，修正了 <code class="docutils literal"><span class="pre">mtl</span></code> 中大量的设计缺陷。若在未来你成为了一个monad变换器的中坚骇客，这值得你一试。</p>
<p>平方级别的实例定义实际上是使用monad变换器带来的问题。除此之外另有其他的手段来组合利用monad。虽然那些手段可以避免这类问题，但是它们对最终用户而言仍不及monad变换器便利。幸运的是，并没有太多基础而泛用的monad变换器需要去定义实现。</p>
</div>
<div class="section" id="id19">
<h3>综述<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>Monad在任何意义下都不是处理效果和类型的终极途径。它只是在我们探索至今，处理这类问题最为实用的技术。语言的研究者们一直致力于找到可以扬长避短的替代系统。</p>
<p>尽管在使用它们时我们必须做出妥协，monad和monad变换器依旧提供了一定程度上的灵活度和控制，而这在指令式语言中并无先例。 仅仅几个声明，我们就可以给分号般基础的东西赋予崭新的意义。</p>
<p>[译注：此处的分号应该指的是 <code class="docutils literal"><span class="pre">do</span></code> 标记中使用的分号。]</p>
</div>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="16.html">第 16 章：使用Parsec</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="19.html">第 19 章： 错误处理</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>