第26章 高级库设计：构建一个布隆过滤器
==========================================

布隆过滤器介绍
----------------

布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是空间利用的高效性。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询的某个元素存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前没有插入过的元素，那么布隆过滤器可能会返回错误的结果，即声称它是存在的。

对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如 BitTorrent），使得一些交互式会话（比如 ``ssh`` 或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在 10000 个批量数据包中误判其中的 1 个为交互式数据包且没有截止，也不会造成任何问题。

布隆过滤器吸引人的地方在于它的空间效率。举个例子，假设现在有一个包含一百万个单词的词典，我们想基于这个词典构建一个拼写检查器，若使用集合数据结构则可能会消耗 20MB 的空间。相比之下，布隆过滤器会消耗大约 0.5MB，代价是漏掉大约 1% 拼错的单词。

布隆过滤器的内部非常简单。它由一个位数组（bit array）和少数哈希函数组成。我们使用 k 表示哈希函数的数量。向布隆过滤器中插入数据时，先用哈希函数为数据计算出 k 个哈希值，然后在位数组中将这些位设置为 1。如果我们想要看看某个数据是否存在，那么就为这个数据计算出 k 个哈希值，然后检查位数组中这些哈希值的位是否都为 1。

下面通过一个例子理解整个过程。现在我们想向布隆过滤器中插入字符串 ``"foo"`` 和 ``"bar"`` ，这个布隆过滤器有 8 位宽，并且我们有两个哈希函数：

1. 假设用两个哈希函数分别计算 ``"foo"`` 的哈希值，得到 ``1`` 和 ``6``
2. 在位数组中置位 ``1`` 和 ``6``
3. 同样用 1 中的两个哈希函数计算 ``"bar"`` 的哈希值，得到 ``6`` 和 ``3``
4. 在位数组中置位 ``6`` 和 ``3``

这个例子解释了为什么我们不能从布隆过滤器中移除一个元素：插入 ``"foo"`` 和 ``"bar"`` 都会导致位数组中的第 ``6`` 位被置位。

假设我们现在想要查询布隆过滤器中 ``"quux"`` 和 ``"baz"`` 是否存在：

1. 用和之前相同的两个哈希函数计算 ``"quux"`` 的哈希值，得到 ``4`` 和 ``0``
2. 检查位数组中的位 ``4``，位 ``4`` 没有被置位，所以 ``"quux"`` 不可能存在，我们不需要检查位 ``0``
3. 计算 ``“baz”`` 的两个哈希值，得到 ``1`` 和 ``3``
4. 检查位数组中的位 ``1`` ，位 ``1`` 被置位；同样，位 ``3`` 也被置位。所以我们认为 ``"baz"`` 存在。但是实际上 ``"bar"`` 并不存在，这里我们得到了一个误判。

如果你想了解布隆过滤器的一些使用案例，请参阅 [Broder02]_

使用场景与封装设计
------------------

不是所有布隆过滤器的使用都有相同的需求。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对其他应用，我们可能需要在创建布隆过滤器之后持续更新。我们通过把可变和不可变的 API 放在不同的模块中来对它们实施分离，其中 ``BloomFilter`` 用于实现不可变的布隆过滤器，而 ``BloomFilter.Mutable`` 则用于实现可变的布隆过滤器。

我们将可变与不可变的API分离，通过把他们放在不同的模块中： ``BloomFilter`` 用于不可变的代码，``BloomFilter.Mutable`` 用于可变代码。

另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。

最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 ``a -> [Word32]`` 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。

基本设计
------------------

跟前面介绍布隆过滤器实现原理时提到的数据结构一样，我们的 Haskell 版布隆过滤器也会用到一个位数组和一个能够计算出多个哈希值的函数。

::

    -- file: BloomFilter/Internal.hs
    module BloomFilter.Internal
        (
          Bloom(..)
        , MutBloom(..)
        ) where

    import Data.Array.ST (STUArray)
    import Data.Array.Unboxed (UArray)
    import Data.Word (Word32)

    data Bloom a = B {
          blmHash  :: (a -> [Word32])
        , blmArray :: UArray Word32 Bool
        }

因为 ``BloomFilter.Internal`` 模块纯粹是为了控制名称的可见性而存在的，所以在创建 Cabal 包时，我们将不会导出这个模块。我们把 ``BloomFilter.Internal`` 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块 API 相关的类型。

拆箱，提升和bottom
^^^^^^^^^^^^^^^^^^^^^^^^

与其他 Haskell 的数组不同， ``UArray`` 包含未装箱的值。

对于一个常规的 Haskell 类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值 ``⊥`` ，发音为（有时候也写作） "bottom"。值 ``⊥`` 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 ``error`` 应用，或者特殊值 ``undefined`` 。

一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 ``error "eek!"`` 或者 ``undefined`` 来代替常规表达式。

存储形式程序和 bottom 的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 ``Word32`` 类型。这种类型的值是全 32 位宽的，所以在 32 位系统上，没有办法直接用 32 位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 ``⊥`` 。

一个未装箱的值没有这种间接性。通过未装箱可以获得性能，但是牺牲了表示形式程序或者 bottom 的能力。因为未装箱的数组可以比常规 Haskell 的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。

.. info::

	装箱和提升

	与未装箱类型相对应的是使用了间接层的装箱类型。所有提升的值都是装箱的，但是一些底层的装箱类型没有被提升。比如，GHC 的运行时系统有一个底层数组类型用于装箱（例如，它维护了一个数组的指针）。如果它是一个数组引用，那么它知道数组肯定是存在的，所以它不需要关心 bottom 是否存在。所以这个数组类型是装箱的，但是未提升的。装箱但是未提升的类型仅展示了底层运行时的特殊实现（hacking）。在常规使用中我们不会遇到它们。

GHC 通过将 8 个数组元素组装成 1 个字节，实现了一种 Bool 类型的 UArray 数组，这种数组非常适合我们的需求。

ST monad
---------------------------

正如前面的 :ref:`modifying-array-elements` 部分所说，因为修改一个不可变数组需要对整个数组进行复制，所以这种修改的代价是非常高的。即使使用 ``UArray`` ，这一问题仍然会存在。那么我们如何才能将复制不可变数组的代价降低到我们可以承受的水平呢？

在指令式语言中，我们可以简单地原地修改数组元素，并且在 Haskell 里面也可以这样做。

Haskell 提供了一个特殊的 Monad，叫做 ``ST`` [59]_ *（State Transformer）* 。 ``ST`` 允许我们安全地工作在可变状态下。与 ``State`` Monad 相比，它有一些强大的额外的功能。

* 解冻一个不可变数组并得到一个可变数组，接着原地对可变数组进行修改，然后在修改完成之后冻结出一个新的不可变数组。
* 通过 *可变引用（mutable references）* 可以构建出一种数据结构，这种数据结构允许用户像命令式语言一样随时对其进行修改。对于那些尚未找到高效纯函数替代的命令式数据结构和算法来说，这个功能尤为重要。

``IO`` Monad 同样提供了这些功能。两者的主要区别在于， ``ST`` Monad 是为了让用户能够从 Monad 中回退到纯 Haskell 代码中而设计的。和大部分 Haskell Monad（当然除了 ``IO`` ）一样，我们通过执行函数 ``runST`` 进入 ``ST`` Monad，然后通过从 ``runST`` 中 return 来退出。

当我们应用一个 Monad 的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 ``runST`` 。为了达到这种可重复性（repeatablility），``ST`` Monad比 ``IO`` Monad 更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 ``runST`` 的调用方。在返回数据之前，可变数组必须被冻结（frozen）为不可变数组，并且可变引用不可以逃逸。

设计一个合格的输入API
------------------------

我们需要讨论一下用来处理布隆过滤器的公开接口。

::

  -- file: BloomFilter/Mutable.hs
  module BloomFilter.Mutable
      (
        MutBloom
      , elem
      , notElem
      , insert
      , length
      , new
      ) where

  import Control.Monad (liftM)
  import Control.Monad.ST (ST)
  import Data.Array.MArray (getBounds, newArray, readArray, writeArray)
  import Data.Word (Word32)
  import Prelude hiding (elem, length, notElem)

  import BloomFilter.Internal (MutBloom(..))

在我们导出的函数当中，有几个函数和 Prelude 导出的函数具有相同的名称。这么做是经过考虑的：我们希望用户使用限制名称导入我们的模块，这减轻了用户记忆的负担，因为他们对 Prelude 中的 ``elem`` ，``notElem`` 和 ``length`` 函数已经相当熟悉了。

在导入这种风格的模块时，我们通常会使用单个字母来作为前缀。例如，用户在代码中使用 ``import qualified BloomFilter.Mutable as M`` 导入模块，此时用户可以将导入模块中的 ``length`` 写为 ``M.length`` ，这保持了代码的紧凑型和可读性。

我们也可以不使用限制名称导入模块，但这样一来的话，我们就需要通过 ``import Prelude hiding (length)`` 来隐藏 Prelude 与模块相冲突的函数。我们不建议使用这种做法，因为它使读者容易忽视代码中的 ``length`` 并非 Prelude 模块的 ``length`` 。

当然，我们在上面定义的模块头中违背了这个规则：我们导入了 Prelude 并且隐藏了它的一些函数名。这是因为我们在模块中定义了自己的函数 ``length`` ，如果不先隐藏 Prelude 包中的同名函数，编译器将无法确定它该导出我们自定义的 ``length`` 还是 Prelude 中的 ``length`` 。

虽然导出完全限定名称 ``BloomFilter.Mutable.length`` 能够消除歧义，但它看起来更丑陋。这个决定对使用模块的用户没有影响，它仅仅针对我们自己 —— 黑盒的设计者，所以这里一般不会导致混淆。

创建一个可变的布隆过滤器
---------------------------

我们将可变布隆过滤器和不可变的 ``Bloom`` 类型均声明在 ``BloomFilter.Internal`` 模块中。

::

	-- file: BloomFilter/Internal.hs
	data MutBloom s a = MB {
		  mutHash :: (a -> [Word32])
		, mutArray :: STUArray s Word32 Bool
		}
		
``STUArray`` 类型提供了可以在 ``ST`` monad 中使用的可变数组，我们可以使用 ``newArray`` 函数创建一个 ``STUArray`` 。下面的 ``new`` 函数属于 ``BloomFilter.Mutable`` 模块（译注：此处应为 ``module`` ，原著中此处为 ``function`` ）。

::

	-- file: BloomFilter/Mutable.hs
	new :: (a -> [Word32]) -> Word32 -> ST s (MutBloom s a)
	new hash numBits = MB hash `liftM` newArray (0,numBits-1) False
	
``STUArray`` 的大多数方法实际上是 ``MArray`` 类型类（在 ``Data.Array.MArray`` 模块中定义）的实现。

有两个因素导致我们自己定义的 ``length`` 函数略显复杂：函数依赖于位数组对自己边界的记录，且 ``MArray`` 实例的 ``getBounds`` 函数有一个 monadic 类型。此外最终的结果还需要加 1，因为数组的上限比实际长度小 1。

当向布隆过滤器添加元素时，需要将哈希函数计算出的所有位置位。 ``mod`` 函数确保了所有计算出的哈希值都限制在位数组范围之内，并将计算位数组偏移量的代码独立为一个函数。（译注：这里使用 ``mod`` 函数最好保证散列的范围是取模的倍数，否则使用 ``mod`` 会使散列结果倾向于某种概率分布。由于布隆过滤器和散列通常基于概率，因此应当避免概率分布过分偏离平均）

::

	-- file: BloomFilter/Mutable.hs
	insert :: MutBloom s a -> a -> ST s ()
	insert filt elt = indices filt elt >>=
					  mapM_ (\bit -> writeArray (mutArray filt) bit True)

	indices :: MutBloom s a -> a -> ST s [Word32]
	indices filt elt = do
	  modulus <- length filt
	  return $ map (`mod` modulus) (mutHash filt elt)
	  
判断一个元素是否属于布隆过滤器的成员非常简单：只要计算出哈希值对应的每一位都被置位，则可以认为这个元素已经位于布隆过滤器中。

::

	-- file: BloomFilter/Mutable.hs
	elem, notElem :: a -> MutBloom s a -> ST s Bool

	elem elt filt = indices filt elt >>=
					allM (readArray (mutArray filt))

	notElem elt filt = not `liftM` elem elt filt

我们需要再编写一个简单的支持函数：monadic 版本的 ``all`` ，这里将其命名为 ``allM`` 。

::
	
	-- file: BloomFilter/Mutable.hs
	allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
	allM p (x:xs) = do
	  ok <- p x
	  if ok
		then allM p xs
		else return False
	allM _ [] = return True
	
不可变的 API
----------------

我们为可变布隆过滤器保留的接口与不可变布隆过滤器的 API 有相同的结构：

::

	-- file: ch26/BloomFilter.hs
	module BloomFilter
		(
		  Bloom
		, length
		, elem
		, notElem
		, fromList
		) where

	import BloomFilter.Internal
	import BloomFilter.Mutable (insert, new)
	import Data.Array.ST (runSTUArray)
	import Data.Array.IArray ((!), bounds)
	import Data.Word (Word32)
	import Prelude hiding (elem, length, notElem)

	length :: Bloom a -> Int
	length = fromIntegral . len

	len :: Bloom a -> Word32
	len = succ . snd . bounds . blmArray

	elem :: a -> Bloom a -> Bool
	elt `elem` filt   = all test (blmHash filt elt)
	  where test hash = blmArray filt ! (hash `mod` len filt)

	notElem :: a -> Bloom a -> Bool
	elt `notElem` filt = not (elt `elem` filt)

我们还提供了一个易于使用的方法，用户可以通过 ``fromList`` 函数创建不可变的布隆过滤器。这个函数对用户隐藏了 ``ST`` monad，因此他们只能看到不可变类型。

::

	-- file: ch26/BloomFilter.hs
	fromList :: (a -> [Word32])    -- family of hash functions to use
			 -> Word32             -- number of bits in filter
			 -> [a]                -- values to populate with
			 -> Bloom a
	fromList hash numBits values =
		B hash . runSTUArray $
		  do mb <- new hash numBits
			 mapM_ (insert mb) values
			 return (mutArray mb)
			 
[Forec 译注：上面的代码在 **GHC** 7.x 中无法通过编译，可以作如下修改来通过编译。

::
	
	fromList hash numBits values =
		(B hash . runSTUArray) (new hash numBits >>= \mb -> do
		mapM_ (insert mb) values
		return (mutArray mb))

]
			 
``fromList`` 函数的关键在于 ``runSTUArray`` 。前面提过，为了从 ``ST`` monad 返回一个不可变数组，我们必须冻结一个可变数组，而 ``runSTUArray`` 函数将执行和冻结相结合。给定一个返回 ``STUArray`` 的动作， ``runSTUArray`` 会使用 ``runST`` 执行这个动作，之后冻结返回的 ``STUArray`` 并将结果作为 ``UArray`` 返回。

``MArray`` 类型类同样提供了一个可用的冻结函数，不过 ``runSTUArray`` 更方便，也更有效。这是因为冻结必须将底层数据从 ``STUArray`` 复制到新的 ``UArray`` 以确保对 ``STUArray`` 的后续修改不会影响 ``UArray`` 。因为类型系统的存在， ``runSTUArray`` 可以在创建 ``UArray`` 的同时保证 ``STUArray`` 不能被访问。因此 ``runSTUArray`` 无需复制也可以共享两个数组之间的底层内容。

创建友好的接口
--------------

一旦我们创建了一个布隆过滤器，上面的不可变布隆过滤器 API 就可以被直接使用。需要注意的是， ``fromList`` 函数还遗留了一些重要的决策没有完成。我们仍然要选择一个适合的哈希函数，并确定布隆过滤器的容量。

::

	-- file: BloomFilter/Easy.hs
	easyList :: (Hashable a)
			 => Double        -- false positive rate (between 0 and 1)
			 -> [a]           -- values to populate the filter with
			 -> Either String (B.Bloom a)

这里有一种更 “友好” 的方式创建布隆过滤器：这种方式将计算哈希值的任务交给了 ``Hashable`` 类型类，并且允许我们将可容忍的错误率作为参数配置布隆过滤器。它还可以根据容错率和输入列表中的元素数量为我们自动选择合适的过滤器大小。

当然，这种方式不是始终可用的。例如，它可能在输入列表的长度过长时失败。然而，这种方法的简便性使提供给用户的接口更加全面：我们必须为用户提供创建布隆过滤器时从完全命令到完全声明的一整套控制流程。

导出更方便的名称
^^^^^^^^^^^^^^^^

在模块的导出列表中，我们从基本的 ``BloomFilter`` 模块中重新导出了一些名称。这允许临时用户只导入 ``BloomFilter.Easy`` 模块，并访问他们可能需要的所有类型和功能。

你可能会好奇，同时导入一个被 ``BloomFilter.Easy`` 和 ``BloomFilter`` 二者均导出的名称会带来什么后果。我们知道，如果不使用 ``qualified`` 导入 ``BloomFilter`` 并调用 ``length`` 函数，GHC 会发出一个有关歧义的错误，因为 ``Prelude`` 中也包含一个同名函数。

Haskell 标准的实现要能够分辨出指向同一个 “事物” 的多个不同名称。例如， ``BloomFilter`` 和 ``BloomFilter.Easy`` 均导出了 ``Bloom`` 类型，如果我们同时导入了这两个模块并使用 ``Bloom`` ，GHC 将能够发现这两个模块导出的 ``Bloom`` 相同，并且不会报告歧义。

哈希值
^^^^^^^

一个布隆过滤器的性能取决于快速、高质量的哈希函数，然而编写一个兼具这两种属性的哈希函数非常困难。

幸运的是，一个名为 Bob Jenkins 的开发人员编写了一些具有这些属性的哈希函数，并公开了代码（网址为 http://burtleburtle.net/bob/hash/doobs.html [59]_）。这些哈希函数使用 C 语言编写，可以通过 FFI 创建它们的绑定。在该网站上，我们需要的特定源文件名为 ``lookup3.c`` ，在本地创建一个 ``cbits`` 目录并将这个文件下载到该目录。

.. info::

	稍作编辑
	
	在刚刚下载的 ``lookup3.c`` 的第 36 行，有一个名为 ``SELF_TEST`` 的宏定义。要将这个源文件作为库使用必须将此行注释掉。如果你没有注释掉这部分代码，文件底部定义的主函数会取代任何试图链接这个库的 Haskell 程序。

还剩下最后一个难题没有解决：我们可能经常需要七个、十个，甚至更多个散列函数，但又不想把这些不同功能的哈希函数混杂到一起。幸运的是，在实际应用中我们多数情况下只需要两个哈希函数，下面很快就会讲到如何实现。Jenkins 的散列库包含两个函数 ``hashword2`` 和 ``hashlittle2`` ，它们计算两个哈希值。这里有一个 C 语言的头文件，它描述了这两个函数的 API，我们将它保存为 ``cbits/lookup3.h`` 。

::

	/* save this file as lookup3.h */

	#ifndef _lookup3_h
	#define _lookup3_h

	#include <stdint.h>
	#include <sys/types.h>

	/* only accepts uint32_t aligned arrays of uint32_t */
	void hashword2(const uint32_t *key,  /* array of uint32_t */
			   size_t length,	     /* number of uint32_t values */
			   uint32_t *pc,	     /* in: seed1, out: hash1 */
			   uint32_t *pb);	     /* in: seed2, out: hash2 */

	/* handles arbitrarily aligned arrays of bytes */
	void hashlittle2(const void *key,   /* array of bytes */
			 size_t length,     /* number of bytes */
			 uint32_t *pc,      /* in: seed1, out: hash1 */
			 uint32_t *pb);     /* in: seed2, out: hash2 */

	#endif /* _lookup3_h */
	
“盐” 是在计算哈希值时加入的干扰值。如果我们用某哈希函数求一个值的散列，并分别加入两个不同的盐，那么计算出的两个结果不同。因为即使是同一个哈希函数，接收了两个不同的盐值后，计算结果也会相去甚远。
	
下面的代码是对这两个函数的绑定：

::

	-- file: BloomFilter/Hash.hs
	{-# LANGUAGE BangPatterns, ForeignFunctionInterface #-}
	module BloomFilter.Hash
		(
		  Hashable(..)
		, hash
		, doubleHash
		) where

	import Data.Bits ((.&.), shiftR)
	import Foreign.Marshal.Array (withArrayLen)
	import Control.Monad (foldM)
	import Data.Word (Word32, Word64)
	import Foreign.C.Types (CSize)
	import Foreign.Marshal.Utils (with)
	import Foreign.Ptr (Ptr, castPtr, plusPtr)
	import Foreign.Storable (Storable, peek, sizeOf)
	import qualified Data.ByteString as Strict
	import qualified Data.ByteString.Lazy as Lazy
	import System.IO.Unsafe (unsafePerformIO)

	foreign import ccall unsafe "lookup3.h hashword2" hashWord2
		:: Ptr Word32 -> CSize -> Ptr Word32 -> Ptr Word32 -> IO ()

	foreign import ccall unsafe "lookup3.h hashlittle2" hashLittle2
		:: Ptr a -> CSize -> Ptr Word32 -> Ptr Word32 -> IO ()
		
[Forec 译注：上面的代码在 **GHC** 7.6 后无法通过编译，解决方法是将 ``import Foreign.C.Types (CSize)`` 修改为 ``import Foreign.C.Types (CSize(..))`` 或者 ``import Foreign.C.Types (CSize(CSize))`` 。]

函数的定义可以查看我们刚刚创建的 ``lookup3.h`` 。

出于对效率和便捷的考虑，我们将 Jenkins 散列函数所需的 32 位盐值和计算出的散列值组成单个 64 位值：

::

	-- file: BloomFilter/Hash.hs
	hashIO :: Ptr a    -- value to hash
		   -> CSize    -- number of bytes
		   -> Word64   -- salt
		   -> IO Word64
	hashIO ptr bytes salt =
		with (fromIntegral salt) $ \sp -> do
		  let p1 = castPtr sp
			  p2 = castPtr sp `plusPtr` 4
		  go p1 p2
		  peek sp
	  where go p1 p2
			  | bytes .&. 3 == 0 = hashWord2 (castPtr ptr) words p1 p2
			  | otherwise        = hashLittle2 ptr bytes p1 p2
			words = bytes `div` 4
	
[Forec 译注： ``with`` 在下面的段落中会有解释， ``castPtr`` 没有介绍过，你可以在 
http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with 查看 ``with`` 的文档，在 
http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html#v:castPtr 查看 ``castPtr`` 的文档。此外，这里使用 ``castPtr`` 并对 ``p1`` 和 ``p2`` 使用类型推断虽然简短了代码，但也降低了代码的可读性。]
	
上面的代码如果没有明确的类型来描述其功能，那么可能看起来就不是很清晰。 ``with`` 函数在 C 程序的堆栈段中为盐值分配了空间，并存储了当前的盐值，所以 ``sp`` 的类型是 ``Ptr Word64`` 。指针 ``p1`` 和 ``p2`` 的类型是 ``Ptr Word32`` ； ``p1`` 指向了 ``sp`` 的低位字， ``p2`` 指向了 ``sp`` 的高位字。这就是我们将一个 ``Word64`` 的盐值切分为两个 ``Ptr Word32`` 参数的方法。

因为所有的数据指针均来自 Haskell 堆，所以它们会在一个能够安全传递给 ``hashWord2`` （只接受 32 位对齐地址）或者 ``hashLittle2`` 的地址上对齐。由于 ``hashWord2`` 是两个哈希函数中较快的，所以当我们在数据为 4 字节的倍数时调用 ``hashWord2`` ，否则调用 ``hashLittle2`` 。 [Forec 译注：这里原著拼写错误，将 ``hashWord2`` 误拼写为 ``hashWord32`` ]

C 语言编写的哈希函数会将计算出的哈希值写入 ``p1`` 和 ``p2`` 指向的地址，我们可以通过 ``sp`` 直接检索计算结果。

使用这个模块的客户不应当被低级细节困扰，所以我们通过类型类来提供一个干净、高级的接口：

::

	-- file: BloomFilter/Hash.hs
	class Hashable a where
		hashSalt :: Word64        -- ^ salt
				 -> a             -- ^ value to hash
				 -> Word64

	hash :: Hashable a => a -> Word64
	hash = hashSalt 0x106fc397cf62f64d3
	
我们还提供了一些这个类型类的实用的实现。要计算基本类型的哈希值，必须先编写一点样板代码：

::

	-- file: BloomFilter/Hash.hs
	hashStorable :: Storable a => Word64 -> a -> Word64
	hashStorable salt k = unsafePerformIO . with k $ \ptr ->
						  hashIO ptr (fromIntegral (sizeOf k)) salt

	instance Hashable Char   where hashSalt = hashStorable
	instance Hashable Int    where hashSalt = hashStorable
	instance Hashable Double where hashSalt = hashStorable
	
下面的代码使用 ``Storable`` 类型类将声明减少到一个：

::

	-- file: BloomFilter/Hash.hs
	instance Storable a => Hashable a where
		hashSalt = hashStorable

[Forec 译注：上面使用 ``Storable`` 的代码需要添加 ``{-# LANGUAGE FlexibleInstances #-}`` 和 ``{-# LANGUAGE UndecidableInstances #-}`` 两个编译选项后才能通过编译。 ]

不幸的是，Haskell 不允许编写这种形式的实例，因为它们会使类型系统无法判定：编译器的类型检查器可能会陷入无限循环中。对不可确定类型的限制使我们必须单独列出声明，但它对于上面的定义并不会造成什么影响。[Forec 译注：上面的例子中如果存在 ``instance Hashable a => Storable a`` 这样的代码（虽然这样的代码没什么意义），则编译器会陷入循环。但如果程序开发者能够保证这种情况不会发生，则可以开启编译选项并使用这一扩展功能。]

::

	-- file: BloomFilter/Hash.hs
	hashList :: (Storable a) => Word64 -> [a] -> IO Word64
	hashList salt xs =
		withArrayLen xs $ \len ptr ->
		  hashIO ptr (fromIntegral (len * sizeOf x)) salt
	  where x = head xs

	instance (Storable a) => Hashable [a] where
		hashSalt salt xs = unsafePerformIO $ hashList salt xs
		
编译器会接受这个实例，因而我们能够对多种列表类型计算哈希值 [60]_ 。最重要的是，由于 ``Char`` 是 ``Storable`` 的一个实例，所以 ``String`` 类型的哈希值同样可以被计算。

利用函数组合可以计算元组的哈希值：在组合管道的一端取盐，并将元组中每个元素的散列结果作为计算该元组中下一个元素使用的盐值。

::

	-- file: BloomFilter/Hash.hs
	hash2 :: (Hashable a) => a -> Word64 -> Word64
	hash2 k salt = hashSalt salt k

	instance (Hashable a, Hashable b) => Hashable (a,b) where
		hashSalt salt (a,b) = hash2 b . hash2 a $ salt

	instance (Hashable a, Hashable b, Hashable c) => Hashable (a,b,c) where
		hashSalt salt (a,b,c) = hash2 c . hash2 b . hash2 a $ salt

要计算 ``ByteString`` 类型的哈希值，我们可以编写一个直接插入到 ``ByteString`` 类型内部的特殊实例，其效率非常出色：

::

	-- file: BloomFilter/Hash.hs
	hashByteString :: Word64 -> Strict.ByteString -> IO Word64
	hashByteString salt bs = Strict.useAsCStringLen bs $ \(ptr, len) ->
							 hashIO ptr (fromIntegral len) salt

	instance Hashable Strict.ByteString where
		hashSalt salt bs = unsafePerformIO $ hashByteString salt bs

	rechunk :: Lazy.ByteString -> [Strict.ByteString]
	rechunk s
		| Lazy.null s = []
		| otherwise   = let (pre,suf) = Lazy.splitAt chunkSize s
						in  repack pre : rechunk suf
		where repack    = Strict.concat . Lazy.toChunks
			  chunkSize = 64 * 1024

	instance Hashable Lazy.ByteString where
		hashSalt salt bs = unsafePerformIO $
						   foldM hashByteString salt (rechunk bs)
		
由于惰性的 ``ByteString`` 类型是由一系列块表示的，我们必须留意块之间的边界。举个例子，字符串 ``foobar`` 可以通过五种不同方式表示，如 ``["foob", "ar"]`` 或者 ``["fo", "obar"]`` 。这一点对于多数用户不可见，但我们直接使用了底层的块。 ``rechunck`` 函数能够确保传递给 C 语言代码的块大小统一为 64 KB，所以无论原始边界在哪里，计算出的哈希值都是一致的。




将两个哈希值转换为多个
^^^^^^^^^^^^^^^^^^^^^^

实现简单的创建函数
^^^^^^^^^^^^^^^^^^

创建一个 Cabal 包
-----------------

处理不同的构建设置
^^^^^^^^^^^^^^^^^^

编译选项和针对 C 的接口
^^^^^^^^^^^^^^^^^^^^^^^

用 QuickCheck 测试
------------------

多态测试
^^^^^^^^

为 ByteString 编写任意实例
^^^^^^^^^^^^^^^^^^^^^^^^^^

推荐大小是正确的吗？
^^^^^^^^^^^^^^^^^^^

性能分析和调优
--------------

配置驱动的性能调优
^^^^^^^^^^^^^^^^^^

练习
----


.. [Broder02] Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..
.. [59] ``ST`` 是 “状态变换器” （state transformer） 的缩写。
.. [60] Jenkins 的哈希函数相比一些流行的非加密哈希函数（如 FNV 和 hashpjw）具有好的多的混合属性，因此我们建议避免使用那些非加密哈希函数。