第四章：函数式编程
========================

使用 Haskell 思考
----------------------

初学 Haskell 的人需要迈过两个难关：

首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。

其次，我们需要熟悉 Haskell 的标准库。和其他语言一样，函数库可以像杠杆那样，极大地提升我们解决问题的能力。因为 Haskell 是一门层次非常高的语言，而 Haskell 的标准库也趋向于处理高层次的抽象，因此对 Haskell 标准库的学习也稍微更难一些，但这些努力最终都会物有所值。

这一章会介绍一些常用的函数式编程技术，以及一些 Haskell 特性。还会在命令式语言和函数式语言之间进行对比，帮助读者了解它们之间的区别，并且在这个过程中，陆续介绍一些基本的 Haskell 标准库。


一个简单的命令行程序
------------------------

在本章的大部分时间里，我们都只和无副作用的代码打交道。为了将注意力集中在实际的代码上，我们需要开发一个接口程序，连接起带副作用的代码和无副作用的代码。

这个接口程序读入一个文件，将函数应用到文件，并且将结果写到另一个文件：

.. literalinclude:: /code/ch04/InteractWith.hs

[译注：原书代码中最后一段的缩进是错误的。 ``myFunction = id`` 应该顶格。还有代码中 ``main`` 函数的缩进有严格的要求，不要随便改动，否则很容易会造成编译错误。]

这是一个简单但完整的文件处理程序。其中 ``do`` 关键字引入一个块，标识那些带有副作用的代码，比如对文件进行读和写操作。被 ``do`` 包围的 ``<-`` 操作符效果等同于赋值。第七章还会介绍更多 I/O 方面的函数。

当我们需要测试其他函数的时候，我们就将程序中的 ``id`` 换成其他函数的名字。另外，这些被测试的函数的类型包含 ``String -> String`` ，也即是，这些函数应该都接受并返回字符串值。

[译注： ``id`` 函数接受一个值，并原封不动地返回这个值，比如 ``id "hello"`` 返回值 ``"hello"`` ，而 ``id 10`` 返回值 ``10`` 。]

[译注：这一段最后一句的原文是“ ... need to have the type ``String -> String`` ... ” ，因为 Haskell 是一种带有类型多态的语言，所以将“  have the type ” 翻译成 “  包含 xx 类型 ”，而不是 “ 必须是 xx 类型 ”。

接下来编译这个程序：

::

    $ ghc --make InteractWith
    [1 of 1] Compiling Main             ( InteractWith.hs, InteractWith.o )
    Linking InteractWith ...

通过命令行运行这个程序。它接受两个文件名作为参数输入，一个用于读取，一个用于写入：

::

    $ echo "hello world" > hello-in.txt

    $ ./InteractWith hello-in.txt hello-out.txt

    $ cat hello-in.txt 
    hello world

    $ cat hello-out.txt 
    hello world

[译注：原书这里的执行过程少了写入内容到 ``hello-in.txt`` 的一步，导致执行会出错，所以这里加上 ``echo ...`` 这一步。另外原书执行的是 ``Interact`` 过程，也是错误的，正确的执行文件名应该是 ``InteractWith`` 。]


循环的表示
-------------

和传统编程语言不同， Haskell 既没有 ``for`` 循环，也没有 ``while`` 循环。那么，如果有一大堆数据要处理，该用什么代替这些循环呢？这一节就会给出这个问题的几种可能的解决办法。


显式递归
^^^^^^^^^^

通过例子进行比对，可以很直观地认识有 loop 语言和没 loop 语言之间的区别。以下是一个 C 函数，它将字符串表示的数字转换成整数：

.. code-block:: c

    int as_int(char *str)
    {
        int acc; // accumulate the partial result
        for (acc = 0; isdigit(*str); str++){
            acc = acc * 10 + (*str -'0');
        }

    return acc;
    }

既然 Haskell 没有 loop 的话，以上这段 C 语言代码，在 Haskell 里该怎么表达呢？

让我们先从类型签名开始写起，这不是必须的，但它对于弄清楚代码在干什么很有帮助：

::

    -- file: ch04/IntParse.hs
    import Data.Char (digitToInt) -- we'll need ord shortly

    asInt :: String -> Int

C 代码在遍历字符串的过程中，渐增地计算结果。Haskell 代码同样可以做到这一点，而且，在 Haskell 里，使用函数已经足以表示 loop 计算了。[译注：在命令式语言里，很多迭代计算都是通过特殊关键字来实现的，比如 ``do`` 、 ``while`` 和 ``for`` 。]

::

    -- file: ch04/IntParse.hs
    loop :: Int -> String -> Int

    asInt xs = loop 0 xs

``loop`` 的第一个参数是累积器的变量，给它赋值 ``0`` 等同于 C 语言在 ``for`` 循环开始前的初始化操作。

在研究详细的代码前，先来思考一下我们要处理的数据：输入 ``xs`` 是一个包含数字的字符串，而 ``String`` 类型不过是 ``[Char]`` 的别名，一个包含字符的列表。因此，要遍历处理字符串，最好的方法是将它看作是列表来处理：它要么就是一个空字符串；要么就是一个字符，后面跟着列表的其余部分。

以上的想法可以通过对列表的构造器进行模式匹配来表达。先从最简单的情况 —— 输入为空字符串开始：

::

    -- file: ch04/IntParse.hs
    loop acc [] = acc

一个空列表并不仅仅意味着“输入列表为空”，另一种可能的情况是，对一个非空字符串进行遍历之后，最终到达了列表的末尾。因此，对于空列表，我们不是抛出错误，而是将累积值返回。

另一个等式处理列表不为空的情况：先取出并处理列表的当前元素，接着处理列表的其他元素。

::

    -- file: ch04/IntParse.hs
    loop acc (x:xs) = let acc' = acc * 10 + digitToInt x
                      in loop acc' xs

程序先计算出当前字符所代表的数值，将它赋值给局部变量 ``acc'`` 。然后使用 ``acc'`` 和剩余列表的元素 ``xs`` 作为参数，再次调用 ``loop`` 函数。这种调用等同于在 C 代码中再次执行一次循环。

每次递归调用 ``loop`` ，累积器的值都会被更新，并处理掉列表里的一个元素。这样一直下去，最终输入列表为空，递归调用结束。

以下是 ``IntParse`` 函数的完整定义：

.. literalinclude:: /code/ch04/IntParse.hs

[译注：书本原来的代码少了对 ``Data.Char`` 的引用，会造成 ``digitToInt`` 查找失败。]

在 ghci 里看看程序的表现如何：

::

    Prelude> :load IntParse.hs
    [1 of 1] Compiling Main             ( IntParse.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> asInt "33"
    33

在处理字符串表示的字符时，它运行得很好。不过，如果传给它一些不合法的输入，这个可怜的函数就没办法处理了：

::

    *Main> asInt ""
    0
    *Main> asInt "potato"
    *** Exception: Char.digitToInt: not a digit 'p'

在练习一，我们会想办法解决这个问题。

``loop`` 函数是尾递归函数的一个例子：如果输入非空，这个函数做的最后一件事，就是递归地调用自身。这个代码还展示了另一个惯用法：通过研究列表的结构，分别处理空列表和非空列表两种状况，这种方法称之为\ *结构递归*\ （structural recursion）。

非递归情形（列表为空）被称为“基本情形”（有时也叫终止情形）。当对函数进行递归调用时，计算最终会回到基本情形上。在数学上，这也称为“归纳情形”。

作为一项有用的技术，结构递归并不仅仅局限于列表，它也适用于其他代数数据类型，稍后就会介绍更多这方面的例子。


对列表元素进行转换
^^^^^^^^^^^^^^^^^^^^^

考虑以下 C 函数， ``square`` ，它对数组中的所有元素执行平方计算：

.. code-block:: c

    void square(double *out, const double *in, size_t length)
    {
        for (size_t i = 0; i < length; i++) {
            out[i] = in[i] * in[i];
        }
    }

这段代码展示了一个直观且常见的 loop 动作，它对输入数组中的所有元素执行同样的动作。以下是 Haskell 版本的 ``square`` 函数：

.. literalinclude:: /code/ch04/square.hs

``square`` 函数包含两个模式匹配等式。第一个模式解构一个列表，取出它的 ``head`` 部分和 ``tail`` 部分，并对第一个元素进行加倍操作，然后将计算所得的新元素放进列表里面。一直这样做下去，直到处理完整个列表为止。第二个等式确保计算会在列表为空时顺利终止。

``square`` 产生一个和输入列表一样长的新列表，其中每个新元素的值都是原本元素的平方：

::

    Prelude> :load square.hs
    [1 of 1] Compiling Main             ( square.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> let one_to_ten = [1.0 .. 10.0]

    *Main> square one_to_ten
    [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]

以下是另一个 C 循环，它将字符串中的所有字母都设置为大写：

.. code-block:: c

    #include <ctype.h>

    char *uppercase(const char *in)
    {
        char *out = strdup(in);

        if (out != NULL) {
            for (size_t i = 0; out[i] != '\0'; i++) {
                out[i] = toupper(out[i]);
            }
        }

        return out;
    }

以下是相等的 Haskell 版本：

.. literalinclude:: /code/ch04/upperCase.hs

代码从 ``Data.Char`` 模块引入了 ``toUpper`` 函数，如果输入字符是一个字母的话，那么函数就将它转换成大写：

::

    Prelude> :module +Data.Char

    Prelude Data.Char> toUpper 'a'
    'A'

    Prelude Data.Char> toUpper 'A'
    'A'

    Prelude Data.Char> toUpper '1'
    '1'

    Prelude Data.Char> toUpper '*'
    '*'

``upperCase`` 函数和之前的 ``square`` 函数很相似：如果输入是一个空列表，那么它就停止计算，返回一个空列表。另一方面，如果输入不为空，那么它就对列表的第一个元素调用 ``toUpper`` 函数，并且递归调用自身，继续处理剩余的列表元素：

::

    Prelude> :load upperCase.hs
    [1 of 1] Compiling Main             ( upperCase.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> upperCase "The quick brown fox jumps over the lazy dog"
    "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"

以上两个函数遵循了同一种处理列表的公共模式：基本情形处理（base case）空列表输入。而\ *递归情形*\ （recursive case）则处理列表非空时的情况，它对列表的头元素进行某种操作，然后递归地处理列表余下的其他元素。


列表映射
^^^^^^^^^^^

前面定义的 ``square`` 和 ``upperCase`` 函数，都生成一个和输入列表同等长度的新列表，并且每次只对列表的一个元素进行处理。因为这种用法非常常见，所以 Haskell 的 ``Prelude`` 库定义了 ``map`` 函数来更方便地执行这种操作。 ``map`` 函数接受一个函数和一个列表作为参数，将输入函数应用到输入列表的每个元素上，并构建出一个新的列表。

以下是使用 ``map`` 重写的 ``square`` 和 ``upperCase`` 函数：

.. literalinclude:: /code/ch04/rewrite_by_map.hs

[译注：原文代码没有载入 ``Data.Char`` 中的 ``toUpper`` 函数。]

来研究一下 ``map`` 是如何实现的。通过查看它的类型签名，可以发现很多有意思的信息：

::

    Prelude> :type map
    map :: (a -> b) -> [a] -> [b]

类型签名显示， ``map`` 接受两个参数：第一个参数是一个函数，这个函数接受一个 ``a`` 类型的值，并返回一个 ``b`` 类型的值[译注：这里只是说 ``a`` 和 ``b`` 类型可能不一样，但不是必须的。]。

像 ``map`` 这种接受一个函数作为参数、又或者返回一个函数作为结果的函数，被称为\ *高阶*\ 函数。

因为 ``map`` 的抽象出现在 ``square`` 和 ``upperCase`` 函数，所以可以通过观察这两个函数，找出它们之间的共同点，然后实现自己的 ``map`` 函数：

.. literalinclude:: /code/ch04/myMap.hs

[译注：在原文的代码里，第二个等式的定义为 ``myMap _ _ = []`` ，这并不是完全正确的，因为它可以适配于第二个参数不为列表的情况，比如 ``myMap f 1`` 。因此，这里遵循标准库里 ``map`` 的定义放进，将第二个等式修改为 ``myMap _ [] = []`` 。]

在 ghci 测试这个 ``myMap`` 函数：

::

    Prelude> :load myMap.hs
    [1 of 1] Compiling Main             ( myMap.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :module +Data.Char

    *Main Data.Char> myMap toUpper "The quick brown fox"
    "THE QUICK BROWN FOX"

通过观察代码，并从中提炼出重复的抽象，是复用代码的一种良好方法。尽管对代码进行抽象并不是 Haskell 的“专利”，但高阶函数使得这种抽象变得非常容易。


筛选列表元素
^^^^^^^^^^^^^^^

另一种对列表的常见操作是，对列表元素进行筛选，只保留那些符合条件的元素。

以下函数接受一个列表作为参数，并返回这个列表里的所有奇数元素。代码的递归情形比之前的 ``map`` 函数要复杂一些，它使用守卫对元素进行条件判断，只有符合条件的元素，才会被加入进结果列表里：

.. literalinclude:: /code/ch04/oddList.hs

[译注：这里将原文代码的 ``oddList _ = []`` 改为 ``oddList [] = []`` ，原因和上一小节修改 ``map`` 函数的代码一样。]

测试：

::

    Prelude> :load oddList.hs
    [1 of 1] Compiling Main             ( oddList.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> oddList [1 .. 10]
    [1,3,5,7,9]

因为这种过滤模式也很常见，所以 ``Prelude`` 也定义了相应的函数 ``filter`` ：它接受一个谓词函数，并将它应用到列表里的每个元素，只有那些谓词函数求值返回 ``True`` 的元素才会被保留：

::

    Prelude> :type odd
    odd :: Integral a => a -> Bool

    Prelude> odd 1
    True

    Prelude> odd 2
    False

    Prelude> :type filter
    filter :: (a -> Bool) -> [a] -> [a]

    Prelude> filter odd [1 .. 10]
    [1,3,5,7,9]

[译注：谓词函数是指那种返回 ``Bool`` 类型值的函数。]

稍后的章节会介绍如何定义 ``filter`` 。


处理收集器并得出结果
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

将一个收集器（collection）简化（reduce）为一个值也是收集器的常见操作之一。

对列表的所有元素求和，就是其中的一个例子：

.. literalinclude:: /code/ch04/mySum.hs

``helper`` 函数通过尾递归进行计算。 ``acc`` 是累积器参数，它记录了当前列表元素的总和。正如我们在 ``asInt`` 函数看到的那样，这种递归计算是纯函数语言里表示 loop 最自然的方式。

以下是一个稍微复杂一些的例子，它是一个 Adler-32 校验和的 JAVA 实现。Adler-32 是一个流行的校验和算法，它将两个 16 位校验和串联成一个 32 位校验和。第一个校验和是所有输入比特之和，加上一。而第二个校验和则是第一个校验和所有中间值之和。每次计算时，校验和都需要取模 ``65521`` 。（如果你不懂 JAVA ，直接跳过也没关系）：

.. code-block:: java

    public class Adler32
    {
        private static final int base = 65521;

        public static int compute(byte[] data, int offset, int length)
        {
            int a = 1, b = 0;

            for (int i = offset; i < offset + length; i++) {
                a = (a + (data[i] & oxff)) % base
                b = (a + b) % base;
            }
            
            return (b << 16) | a;
        }
    }

尽管 Adler-32 是一个简单的校验和算法，但这个 JAVA 实现还是非常复杂，很难看清楚位操作之间的关系。

以下是 Adler-32 算法的 Haskell 实现：

.. literalinclude:: /code/ch04/Adler32.hs

在这段代码里， ``shiftL`` 函数实现逻辑左移， ``(.&.)`` 实现二进制位的并操作， ``(.|.)`` 实现二进制位的或操作， ``ord`` 函数则返回给定字符对应的编码值。

``helper`` 函数通过尾递归来进行计算，每次对它的调用，都产生新的累积变量，效果等同于 JAVA 在 ``for`` 循环里对变量的赋值更新。当列表处理完毕，递归终止时，程序计算出校验和并将它返回。

.. 这里省略了一段。。。

和前面抽取出 ``map`` 和 ``filter`` 函数类似，从 ``Adler32`` 函数里面，我们也可以抽取出一种通用的抽象，称之为折叠（fold）：它对一个列表中的所有元素做某种处理，并且一边处理元素，一边更新累积器，最后在处理完整个列表之后，返回累积器的值。

有两种不同类型的折叠，其中 ``foldl`` 从左边开始进行折叠，而 ``foldr`` 从右边开始进行折叠。


左折叠
^^^^^^^^^

以下是 ``foldl`` 函数的定义：

.. literalinclude:: /code/ch04/foldl.hs

``foldl`` 函数接受一个步骤（step）函数，一个累积器的初始化值，以及一个列表作为参数。步骤函数每次使用累积器和列表中的一个元素作为参数，并计算出新的累积器值，这个过程称为步进（stepper）。然后，将新的累积器作为参数，再次进行同样的计算，直到整个列表处理完为止。

以下是使用 ``foldl`` 重写的 ``mySum`` 函数：

.. literalinclude:: /code/ch04/foldlSum.hs

因为代码里的 ``step`` 函数执行的操作不过是相加起它的两个输入参数，因此，可以直接将一个加法函数代替 ``step`` 函数，并移除多余的 ``where`` 语句：

.. literalinclude:: /code/ch04/niceSum.hs

为了进一步看清楚 ``foldl`` 的执行模式，以下代码展示了 ``niceSum [1, 2, 3]`` 执行时的计算过程：

::

    niceSum [1, 2, 3]
        == foldl (+) 0                   (1:2:3:[])
        == foldl (+) (0 + 1)             (2:3:[])
        == foldl (+) ((0 + 1) + 2)       (3:[])
        == foldl (+) (((0 + 1) + 2) + 3) []
        == (((0 + 1) + 2) + 3)
        == 6

注意对比新的 ``mySum`` 定义比刚开始的定义节省了多少代码：新版本没有使用显式递归，因为 ``foldl`` 可以代替我们搞定了关于循环的一切。现在程序只要求我们回答两个问题：第一，累积器的初始化值是什么（\ ``foldl`` 的第二个参数）；第二，怎么更新累积器的值（\ ``(+)`` 函数）。

.. 这里 adler32_try2 的例子也被省略了


为什么使用 ``fold`` 、 ``map`` 和 ``filter`` ？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

回顾一下之前的几个例子，可以看出，使用 ``fold`` 和 ``map`` 等高阶函数定义的函数，比起显式使用递归的函数，并不总是能节约大量代码。那么，我们为什么要使用这些函数呢？

答案是，因为它们在 Haskell 中非常通用，并且这些函数都带有正确的、可预见的行为。

这意味着，即使是一个 Haskell 新手，他/她理解起 ``fold`` 通常都要比理解显式递归要容易。一个 ``fold`` 并不产生任何意外动作，但一个显式递归函数的所做作为，通常并不是那么显而易见的。

以上观点同样适用于其他高阶函数库，包括前面介绍过的 ``map`` 和 ``filter`` 。因为这些函数都带有定义良好的行为，我们只需要学习怎样使用这些函数一次，以后每次碰到使用这些函数的代码，这些知识都可以加快我们对代码的理解。这种优势同样体现在代码的编写上：一旦我们能熟练使用高阶函数，那么写出更简洁的代码自然就不在话下。


