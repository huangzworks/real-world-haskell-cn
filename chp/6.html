
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第六章：类型类 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第七章：I/O" href="7.html" />
    <link rel="prev" title="第五章：编写 JSON 库" href="5.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第五章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第七章：I/O</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="using-typeclasses">
<span id="id1"></span><h1>第六章：类型类<a class="headerlink" href="#using-typeclasses" title="Permalink to this headline">¶</a></h1>
<p>类型类（typeclass）是 Haskell 最强大的功能之一：它用于定义通用接口，为各种不同的类型提供一组公共特性集。</p>
<p>类型类是某些基本语言特性的核心，比如相等性测试和数值操作符。</p>
<p>在讨论如何使用类型类之前，先来看看它能做什么。</p>
<div class="section" id="the-need-for-typeclasses">
<span id="id2"></span><h2>类型类的作用<a class="headerlink" href="#the-need-for-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>假设这样一个场景：我们想对 <code class="docutils literal"><span class="pre">Color</span></code> 类型的值进行对比，但 Haskell 的语言设计者却没有实现 <code class="docutils literal"><span class="pre">==</span></code> 操作。</p>
<p>要解决这个问题，必须亲自实现一个相等性测试函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/colorEq.hs</span>

<span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span>

<span class="nf">colorEq</span> <span class="ow">::</span> <span class="kt">Color</span> <span class="ow">-&gt;</span> <span class="kt">Color</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">colorEq</span> <span class="kt">Red</span>   <span class="kt">Red</span>   <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kt">Green</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kt">Blue</span>  <span class="kt">Blue</span>  <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>在 ghci 里测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">colorEq</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">colorEq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">colorEq</span> <span class="kt">Green</span> <span class="kt">Green</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">colorEq</span> <span class="kt">Blue</span> <span class="kt">Red</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>过了一会，程序又添加了一个新类型 —— 职位：它对公司中的各个员工进行分类。</p>
<p>在执行像是工资计算这类任务是，又需要用到相等性测试，所以又需要再次为职位类型定义相等性测试函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/roleEq.hs</span>

<span class="kr">data</span> <span class="kt">Role</span> <span class="ow">=</span> <span class="kt">Boss</span> <span class="o">|</span> <span class="kt">Manager</span> <span class="o">|</span> <span class="kt">Employee</span>

<span class="nf">roleEq</span> <span class="ow">::</span> <span class="kt">Role</span> <span class="ow">-&gt;</span> <span class="kt">Role</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">roleEq</span> <span class="kt">Employee</span> <span class="kt">Employee</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kt">Manager</span>  <span class="kt">Manager</span>  <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kt">Boss</span>     <span class="kt">Boss</span>     <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kr">_</span>        <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">roleEq</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">roleEq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">roleEq</span> <span class="kt">Boss</span> <span class="kt">Boss</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">roleEq</span> <span class="kt">Boss</span> <span class="kt">Employee</span>
<span class="kt">False</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">colorEq</span></code> 和 <code class="docutils literal"><span class="pre">roleEq</span></code> 的定义揭示了一个问题：对于每个不同的类型，我们都需要为它们专门定义一个对比函数。</p>
<p>这种做法非常低效，而且烦人。如果同一个对比函数（比如 <code class="docutils literal"><span class="pre">==</span></code> ）可以用于对比任何类型的值，这样就会方便得多。</p>
<p>另一方面，一般来说，如果定义了相等测试函数（比如 <code class="docutils literal"><span class="pre">==</span></code> ），那么不等测试函数（比如 <code class="docutils literal"><span class="pre">/=</span></code> ）的值就可以直接对相等测试函数取反（使用 <code class="docutils literal"><span class="pre">not</span></code> ）来计算得出。因此，如果可以通过相等测试函数来定义不等测试函数，那么会更方便。</p>
<p>通用函数还可以让代码变得更通用：如果同一段代码可以用于不同类型的输入值，那么程序的代码量将大大减少。</p>
<p>还有很重要的一点是，如果在之后添加通用函数对新类型的支持，那么原来的代码应该不需要进行修改。</p>
<p>Haskell 的类型类可以满足以上提到的所有要求。</p>
</div>
<div class="section" id="what-are-typeclasses">
<span id="id3"></span><h2>什么是类型类？<a class="headerlink" href="#what-are-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>类型类定义了一系列函数，这些函数对于不同类型的值使用不同的函数实现。它和其他语言的接口和多态方法有些类似。</p>
<p>[译注：这里原文是将“面向对象编程中的对象”和 Haskell 的类型类进行类比，但实际上这种类比并不太恰当，类比成接口和多态方法更适合一点。]</p>
<p>我们定义一个类型类来解决前面提到的相等性测试问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>类型类使用 <code class="docutils literal"><span class="pre">class</span></code> 关键字来定义，跟在 <code class="docutils literal"><span class="pre">class</span></code> 之后的 <code class="docutils literal"><span class="pre">BasicEq</span></code> 是这个类型类的名字，之后的 <code class="docutils literal"><span class="pre">a</span></code> 是这个类型类的实例类型（instance type）。</p>
<p><code class="docutils literal"><span class="pre">BasicEq</span></code> 使用类型变量 <code class="docutils literal"><span class="pre">a</span></code> 来表示实例类型，说明它并不将这个类型类限定于某个类型：任何一个类型，只要它实现了这个类型类中定义的函数，那么它就是这个类型类的实例类型。</p>
<p>实例类型所使用的名字可以随意选择，但是它和类型类中定义函数签名时所使用的名字应该保持一致。比如说，我们使用 <code class="docutils literal"><span class="pre">a</span></code> 来表示实例类型，那么函数签名中也必须使用 <code class="docutils literal"><span class="pre">a</span></code> 来代表这个实例类型。</p>
<p><code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类只定义了 <code class="docutils literal"><span class="pre">isEqual</span></code> 一个函数 —— 它接受两个参数作为输入，并且这两个参数都指向同一种实例类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">BasicEq_1</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">BasicEq_1</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">isEqual</span>
<span class="nf">isEqual</span> <span class="ow">::</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>作为演示，以下代码将 <code class="docutils literal"><span class="pre">Bool</span></code> 类型作为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型，实现了 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>在 ghci 里验证这个程序：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">True</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>如果试图将不是 <code class="docutils literal"><span class="pre">BasicEq</span></code> 实例类型的值作为输入调用 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数，那么就会引发错误：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">BasicEq</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
          <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">isEqual&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">BasicEq</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>
</pre></div>
</div>
<p>错误信息提醒我们， <code class="docutils literal"><span class="pre">[Char]</span></code> 并不是 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型。</p>
<p>稍后的一节会介绍更多关于类型类实例的定义方式，这里先继续前面的例子。这一次，除了 <code class="docutils literal"><span class="pre">isEqual</span></code> 之外，我们还想定义不等测试函数 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span>    <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>同时定义 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 两个函数产生了一些不必要的工作：从逻辑上讲，对于任何类型，只要知道 <code class="docutils literal"><span class="pre">isEqual</span></code> 或 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 的任意一个，就可以计算出另外一个。因此，一种更省事的办法是，为 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 两个函数提供默认值，这样 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型只要实现这两个函数中的一个，就可以顺利使用这两个函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>以下是将 <code class="docutils literal"><span class="pre">Bool</span></code> 作为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 实例类型的例子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>我们只要定义 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数，就可以“免费”得到 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">BasicEq_3</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">BasicEq_3</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isNotEqual</span> <span class="kt">False</span> <span class="kt">True</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>当然，如果闲着没事，你仍然可以自己亲手定义这两个函数。但是，你至少要定义两个函数中的一个，否则两个默认的函数就会互相调用，直到程序崩溃。</p>
</div>
<div class="section" id="declaring-typeclass-instances">
<span id="id4"></span><h2>定义类型类实例<a class="headerlink" href="#declaring-typeclass-instances" title="Permalink to this headline">¶</a></h2>
<p>定义一个类型为某个类型类的实例，指的就是，为某个类型实现给定类型类所声明的全部函数。</p>
<p>比如在前面， <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类定义了两个函数 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>在前一节，我们成功将 <code class="docutils literal"><span class="pre">Bool</span></code> 类型实现为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型，要使 <code class="docutils literal"><span class="pre">Color</span></code> 类型也成为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类的实例，就需要另外为 <code class="docutils literal"><span class="pre">Color</span></code> 类型实现 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">Red</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">Blue</span> <span class="kt">Blue</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">Green</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>注意，这里的函数定义和之前的 <code class="docutils literal"><span class="pre">colorEq</span></code> 函数定义实际上没有什么不同，唯一的区别是，它使得 <code class="docutils literal"><span class="pre">isEqual</span></code> 不仅可以对 <code class="docutils literal"><span class="pre">Bool</span></code> 类型进行对比测试，还可以对 <code class="docutils literal"><span class="pre">Color</span></code> 类型进行对比测试。</p>
<p>更一般地说，只要为相应的类型实现 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类中的定义，那么 <code class="docutils literal"><span class="pre">isEqual</span></code> 就可以用于对比<em>任何</em>我们想对比的类型。</p>
<p>不过在实际中，通常并不使用 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类，而是使用 Haskell Report 中定义的 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类：它定义了 <code class="docutils literal"><span class="pre">==</span></code> 和 <code class="docutils literal"><span class="pre">/=</span></code> 操作符，这两个操作符才是 Haskell 中最常用的测试函数。</p>
<p>以下是 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的定义：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span>  <span class="kt">Eq</span> <span class="n">a</span>  <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">),</span> <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- Minimal complete definition:</span>
<span class="c1">--     (==) or (/=)</span>
<span class="nf">x</span> <span class="o">/=</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
<span class="nf">x</span> <span class="o">==</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>稍后会介绍更多使用 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的信息。</p>
</div>
<div class="section" id="important-built-in-typeclasses">
<span id="id5"></span><h2>几个重要的内置类型类<a class="headerlink" href="#important-built-in-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>前面两节分别介绍了类型类的定义，以及如何让某个类型成为给定类型类的实例类型。</p>
<p>正本节会介绍几个 <code class="docutils literal"><span class="pre">Prelude</span></code> 库中包含的类型类。如本章开始时所说的，类型类是 Haskell 语言某些特性的奠基石，本节就会介绍几个这方面的例子。</p>
<p>更多信息可以参考 Haskell 的函数参考，那里一般都给出了类型类的详细介绍，并且说明，要成为这个类型类的实例，需要实现那些函数。</p>
<div class="section" id="show">
<h3>Show<a class="headerlink" href="#show" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类用于将值转换为字符串，它最重要的函数是 <code class="docutils literal"><span class="pre">show</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">show</span></code> 函数使用单个参数接收输入数据，并返回一个表示该输入数据的字符串：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">show</span>
<span class="nf">show</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>以下是一些 <code class="docutils literal"><span class="pre">show</span></code> 函数调用的例子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">1</span>
<span class="s">&quot;1&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="s">&quot;[1,2,3]&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="s">&quot;(1,2)&quot;</span>
</pre></div>
</div>
<p>Ghci 输出一个值，实际上就是对这个值调用 <code class="docutils literal"><span class="pre">putStrLn</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">1</span>
<span class="s">&quot;1&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>因此，如果你定义了一种新的数据类型，并且希望通过 ghci 来显示它，那么你就应该将这个类型实现为 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的实例，否则 ghci 就会向你抱怨，说它不知道该怎样用字符串的形式表示这种数据类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span><span class="p">;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">10</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">show&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">show</span> <span class="kt">Red</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">print&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">a</span> <span class="n">stmt</span> <span class="kr">of</span> <span class="n">an</span> <span class="n">interactive</span> <span class="kt">GHCi</span> <span class="n">command</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
</pre></div>
</div>
<p>通过实现 <code class="docutils literal"><span class="pre">Color</span></code> 类型的 <code class="docutils literal"><span class="pre">show</span></code> 函数，让 <code class="docutils literal"><span class="pre">Color</span></code> 类型成为 <code class="docutils literal"><span class="pre">Show</span></code> 的类型实例，可以解决以上问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span>   <span class="ow">=</span> <span class="s">&quot;Red&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green&quot;</span>
    <span class="n">show</span> <span class="kt">Blue</span>  <span class="ow">=</span> <span class="s">&quot;Blue&quot;</span>
</pre></div>
</div>
<p>当然， <code class="docutils literal"><span class="pre">show</span></code> 函数的打印值并不是非要和类型构造器一样不可，比如 <code class="docutils literal"><span class="pre">Red</span></code> 值并不是非要表示为 <code class="docutils literal"><span class="pre">&quot;Red&quot;</span></code> 不可，以下是另一种实例化 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的方式：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span>   <span class="ow">=</span> <span class="s">&quot;Color 1: Red&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Color 2: Green&quot;</span>
    <span class="n">show</span> <span class="kt">Blue</span>  <span class="ow">=</span> <span class="s">&quot;Color 3: Blue&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="read">
<h3>Read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的作用正好相反，它将字符串转换为值。</p>
<p><code class="docutils literal"><span class="pre">Read</span></code> 最有用的函数是 <code class="docutils literal"><span class="pre">read</span></code> ：它接受一个字符串作为参数，对这个字符串进行处理，并返回一个值，这个值的类型为 <code class="docutils literal"><span class="pre">Read</span></code> 实例类型的成员（所有实例类型中的一种）。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>以下代码展示了 <code class="docutils literal"><span class="pre">read</span></code> 的用法：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a0&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
          <span class="p">(</span><span class="kt">Read</span> <span class="n">a0</span><span class="p">)</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Int</span>
<span class="mi">3</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Int</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Double</span>
<span class="mf">3.0</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Double</span>
</pre></div>
</div>
<p>注意在第一次调用 <code class="docutils literal"><span class="pre">read</span></code> 的时候，我们并没有显式地给定类型签名，这时对 <code class="docutils literal"><span class="pre">read</span> <span class="pre">&quot;3&quot;</span></code> 的求值会引发错误。这是因为有非常多的类型都是 <code class="docutils literal"><span class="pre">Read</span></code> 的实例，而编译器在 <code class="docutils literal"><span class="pre">read</span></code> 函数读入 <code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> 之后，不知道应该将这个值转换成什么类型，于是编译器就会向我们发牢骚。</p>
<p>因此，为了让 <code class="docutils literal"><span class="pre">read</span></code> 函数返回正确类型的值，必须给它指示正确的类型。</p>
</div>
<div class="section" id="read-show">
<h3>使用 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 进行序列化<a class="headerlink" href="#read-show" title="Permalink to this headline">¶</a></h3>
<p>很多时候，程序需要将内存中的数据保存为文件，又或者，反过来，需要将文件中的数据转换为内存中的数据实体。这种转换过程称为<em>序列化</em>和<em>反序列化</em> .</p>
<p>通过将类型实现为 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 的实例类型， <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 两个函数可以成为非常好的序列化工具。</p>
<p>作为例子，以下代码将一个内存中的列表序列化到文件中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">years</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1999</span><span class="p">,</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">2012</span><span class="p">]</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="n">years</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">writeFile</span> <span class="s">&quot;years.txt&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">years</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">writeFile</span></code> 将给定内容写入到文件当中，它接受两个参数，第一个参数是文件路径，第二个参数是写入到文件的字符串内容。</p>
<p>观察文件 <code class="docutils literal"><span class="pre">years.txt</span></code> 可以看到， <code class="docutils literal"><span class="pre">(show</span> <span class="pre">years)</span></code> 所产生的文本被成功保存到了文件当中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">$</span> <span class="n">cat</span> <span class="n">years</span><span class="o">.</span><span class="n">txt</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p>使用以下代码可以对 <code class="docutils literal"><span class="pre">years.txt</span></code> 进行反序列化操作：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;years.txt&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span>                  <span class="c1">-- 读入的字符串</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="n">input</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>    <span class="c1">-- 将字符串转换成列表</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">readFile</span></code> 读入给定的 <code class="docutils literal"><span class="pre">years.txt</span></code> ，并将它的内存传给 <code class="docutils literal"><span class="pre">input</span></code> 变量，最后，通过使用 <code class="docutils literal"><span class="pre">read</span></code> ，我们成功将字符串反序列化成一个列表。</p>
</div>
<div class="section" id="numeric-types">
<span id="id6"></span><h3>数字类型<a class="headerlink" href="#numeric-types" title="Permalink to this headline">¶</a></h3>
<p>Haskell 有一集非常强大的数字类型：从速度飞快的 32 位或 64 位整数，到任意精度的有理数，包罗万有。</p>
<p>除此之外，Haskell 还有一系列通用算术操作符，这些操作符可以用于几乎所有数字类型。而对数字类型的这种强有力的支持就是建立在类型类的基础上的。</p>
<p>作为一个额外的好处（side benefit），用户可以定义自己的数字类型，并且获得和内置数字类型完全平等的权利。</p>
<p>以下表格显示了 Haskell 中最常用的一些数字类型：</p>
<p><strong>表格 6.1 ： 部分数字类型</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">介绍</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>双精度浮点数。表示浮点数的常见选择。</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>单精度浮点数。通常在对接 C 程序时使用。</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>固定精度带符号整数；最小范围在 -2^29 至 2^29-1 。相当常用。</td>
</tr>
<tr class="row-odd"><td>Int8</td>
<td>8 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int16</td>
<td>16 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Int32</td>
<td>32 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int64</td>
<td>64 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Integer</td>
<td>任意精度带符号整数；范围由机器的内存限制。相当常用。</td>
</tr>
<tr class="row-even"><td>Rational</td>
<td>任意精度有理数。保存为两个整数之比（ratio）。</td>
</tr>
<tr class="row-odd"><td>Word</td>
<td>固定精度无符号整数。占用的内存大小和 <code class="docutils literal"><span class="pre">Int</span></code> 相同</td>
</tr>
<tr class="row-even"><td>Word8</td>
<td>8 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>16 位无符号整数</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>32 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>64 位无符号整数</td>
</tr>
</tbody>
</table>
<p>大部分算术操作都可以用于任意数字类型，少数的一部分函数，比如 <code class="docutils literal"><span class="pre">asin</span></code> ，只能用于浮点数类型。</p>
<p>以下表格列举了操作各种数字类型的常见函数和操作符：</p>
<p><strong>表格 6.2 ： 部分数字函数和</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="8%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">项</th>
<th class="head">类型</th>
<th class="head">模块</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(+)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>加法</td>
</tr>
<tr class="row-odd"><td>(-)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>减法</td>
</tr>
<tr class="row-even"><td>(*)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘法</td>
</tr>
<tr class="row-odd"><td>(/)</td>
<td>Fractional a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>份数除法</td>
</tr>
<tr class="row-even"><td>(**)</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘幂</td>
</tr>
<tr class="row-odd"><td>(^)</td>
<td>(Num a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>计算某个数的非负整数次方</td>
</tr>
<tr class="row-even"><td>(^^)</td>
<td>(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>分数的任意整数次方</td>
</tr>
<tr class="row-odd"><td>(%)</td>
<td>Integral a =&gt; a -&gt; a -&gt; Ratio a</td>
<td>Data.Ratio</td>
<td>构成比率</td>
</tr>
<tr class="row-even"><td>(.&amp;.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制并操作</td>
</tr>
<tr class="row-odd"><td>(.|.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制或操作</td>
</tr>
<tr class="row-even"><td>abs</td>
<td>Num a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>绝对值操作</td>
</tr>
<tr class="row-odd"><td>approxRational</td>
<td>RealFrac a =&gt; a -&gt; a -&gt; Rational</td>
<td>Data.Ratio</td>
<td>通过分数的分子和分母计算出近似有理数</td>
</tr>
<tr class="row-even"><td>cos</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>余弦函数。另外还有 acos 、 cosh 和 acosh ，类型和 cos 一样。</td>
</tr>
<tr class="row-odd"><td>div</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法，总是截断小数位。</td>
</tr>
<tr class="row-even"><td>fromInteger</td>
<td>Num a =&gt; Integer -&gt; a</td>
<td>Prelude</td>
<td>将一个 Integer 值转换为任意数字类型。</td>
</tr>
<tr class="row-odd"><td>fromIntegral</td>
<td>(Integral a, Num b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>一个更通用的转换函数，将任意 Integral 值转为任意数字类型。</td>
</tr>
<tr class="row-even"><td>fromRational</td>
<td>Fractional a =&gt; Rational -&gt; a</td>
<td>Prelude</td>
<td>将一个有理数转换为分数。可能会有精度损失。</td>
</tr>
<tr class="row-odd"><td>log</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>自然对数算法。</td>
</tr>
<tr class="row-even"><td>logBase</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>计算指定底数对数。</td>
</tr>
<tr class="row-odd"><td>maxBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数字类型的最大值。</td>
</tr>
<tr class="row-even"><td>minBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数字类型的最小值。</td>
</tr>
<tr class="row-odd"><td>mod</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数取模。</td>
</tr>
<tr class="row-even"><td>pi</td>
<td>Floating a =&gt; a</td>
<td>Prelude</td>
<td>圆周率常量。</td>
</tr>
<tr class="row-odd"><td>quot</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法；商数的分数部分截断为 0 。</td>
</tr>
<tr class="row-even"><td>recip</td>
<td>Fractional a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>分数的倒数。</td>
</tr>
<tr class="row-odd"><td>rem</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法的余数。</td>
</tr>
<tr class="row-even"><td>round</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>四舍五入到最近的整数。</td>
</tr>
<tr class="row-odd"><td>shift</td>
<td>Bits a =&gt; a -&gt; Int -&gt; a</td>
<td>Bits</td>
<td>输入为正整数，就进行左移。如果为负数，进行右移。</td>
</tr>
<tr class="row-even"><td>sin</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正弦函数。还提供了 asin 、 sinh 和 asinh ，和 sin 类型一样。</td>
</tr>
<tr class="row-odd"><td>sqrt</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>平方根</td>
</tr>
<tr class="row-even"><td>tan</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正切函数。还提供了 atan 、 tanh 和 atanh ，和 tan 类型一样。</td>
</tr>
<tr class="row-odd"><td>toInteger</td>
<td>Integral a =&gt; a -&gt; Integer</td>
<td>Prelude</td>
<td>将任意 Integral 值转换为 Integer</td>
</tr>
<tr class="row-even"><td>toRational</td>
<td>Real a =&gt; a -&gt; Rational</td>
<td>Prelude</td>
<td>从实数到有理数的有损转换</td>
</tr>
<tr class="row-odd"><td>truncate</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>向下取整</td>
</tr>
<tr class="row-even"><td>xor</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制异或操作</td>
</tr>
</tbody>
</table>
<p>数字类型及其对应的类型类列举在下表：</p>
<p><strong>表格 6.3 ： 数字类型的类型类实例</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="5%" />
<col width="10%" />
<col width="9%" />
<col width="14%" />
<col width="9%" />
<col width="5%" />
<col width="6%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">Bits</th>
<th class="head">Bounded</th>
<th class="head">Floating</th>
<th class="head">Fractional</th>
<th class="head">Integral</th>
<th class="head">Num</th>
<th class="head">Real</th>
<th class="head">RealFrac</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Int32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Integer</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Rational or any Ratio</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Word</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>表格 6.2 列举了一些数字类型之间进行转换的函数，以下表格是一个汇总：</p>
<p><strong>表格 6.4 ： 数字类型之间的转换</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="29%" />
<col width="15%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td rowspan="2">源类型</td>
<td colspan="4">目标类型</td>
</tr>
<tr class="row-even"><td>Double, Float</td>
<td>Int, Word</td>
<td>Integer</td>
<td>Rational</td>
</tr>
<tr class="row-odd"><td>Double, Float
Int, Word
Integer
Rational</td>
<td>fromRational . toRational
fromIntegral
fromIntegral
fromRational</td>
<td>truncate *
fromIntegral
fromIntegral
truncate *</td>
<td>truncate *
fromIntegral
N/A
truncate *</td>
<td>toRational
fromIntegral
fromIntegral
N/A</td>
</tr>
</tbody>
</table>
<p>* 除了 <code class="docutils literal"><span class="pre">truncate</span></code> 之外，还可以使用 <code class="docutils literal"><span class="pre">round</span></code> 、 <code class="docutils literal"><span class="pre">ceiling</span></code> 或者 <code class="docutils literal"><span class="pre">float</span></code> 。</p>
<p>第十三章会说明，怎样用自定义数据类型来扩展数字类型。</p>
</div>
<div class="section" id="id7">
<h3>相等性，有序和对比<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>除了前面介绍的通用算术符号之外，相等测试、不等测试、大于和小于等对比操作也是非常常见的。</p>
<p>其中， <code class="docutils literal"><span class="pre">Eq</span></code> 类型类定义了 <code class="docutils literal"><span class="pre">==</span></code> 和 <code class="docutils literal"><span class="pre">/=</span></code> 操作，而 <code class="docutils literal"><span class="pre">&gt;=</span></code> 和 <code class="docutils literal"><span class="pre">&lt;=</span></code> 等对比操作，则由 <code class="docutils literal"><span class="pre">Ord</span></code> 类型类定义。</p>
<p>需要将对比操作和相等性测试分开用两个类型类来定义的原因是，对于某些类型，它们只对相等性测试和不等测试有兴趣，比如 <code class="docutils literal"><span class="pre">Handle</span></code> 类型，而部分有序操作（particular ordering， 大于、小于等）对它来说是没有意义的。</p>
<p>所有 <code class="docutils literal"><span class="pre">Ord</span></code> 实例都可以使用 <code class="docutils literal"><span class="pre">Data.List.sort</span></code> 来排序。</p>
<p>几乎所有 Haskell 内置类型都是 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的实例，而 <code class="docutils literal"><span class="pre">Ord</span></code> 实例的类型也不在少数。</p>
</div>
</div>
<div class="section" id="id8">
<h2>自动派生<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>对于简单的数据类型， Haskell 编译器可以自动将类型派生（derivation）为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Bounded</span></code> 、 <code class="docutils literal"><span class="pre">Enum</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例。</p>
<p>以下代码将 <code class="docutils literal"><span class="pre">Color</span></code> 类型派生为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>
<span class="s">&quot;Red&quot;</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Red&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Red</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red, Red, Blue]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">sort</span> <span class="p">[</span><span class="kt">Blue</span><span class="p">,</span> <span class="kt">Green</span><span class="p">,</span> <span class="kt">Blue</span><span class="p">,</span> <span class="kt">Red</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Green</span><span class="p">,</span><span class="kt">Blue</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">&lt;</span> <span class="kt">Blue</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal"><span class="pre">Color</span></code> 类型的排序位置由定义类型时值构造器的排序决定。</p>
<p>自动派生并不总是可用的。比如说，如果定义类型 <code class="docutils literal"><span class="pre">data</span> <span class="pre">MyType</span> <span class="pre">=</span> <span class="pre">MyType</span> <span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span></code> ，那么编译器就没办法派生 <code class="docutils literal"><span class="pre">MyType</span></code> 为 <code class="docutils literal"><span class="pre">Show</span></code> 的实例，因为它不知道该怎么将 <code class="docutils literal"><span class="pre">MyType</span></code> 函数的输出转换成字符串，这会造成编译错误。</p>
<p>除此之外，当使用自动推导将某个类型设置为给定类型类的实例时，定义这个类型时所使用的其他类型，也必须是给定类型类的实例（通过自动推导或手动添加的都可以）。</p>
<p>举个例子，以下代码不能使用自动推导：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>

<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Ghci 会给出提示，说明 <code class="docutils literal"><span class="pre">Book</span></code> 类型也必须是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例， <code class="docutils literal"><span class="pre">BookInfo</span></code> 才能对 <code class="docutils literal"><span class="pre">Show</span></code> 进行自动推导：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">cant_ad</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">cant_ad</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="nf">ad</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">27</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Book</span><span class="p">)</span>
          <span class="n">arising</span> <span class="n">from</span> <span class="n">the</span> <span class="n">&#39;deriving&#39;</span> <span class="n">clause</span> <span class="kr">of</span> <span class="n">a</span> <span class="kr">data</span> <span class="kr">type</span> <span class="n">declaration</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span>
        <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Book</span><span class="p">)</span>
        <span class="n">or</span> <span class="n">use</span> <span class="n">a</span> <span class="n">standalone</span> <span class="n">&#39;deriving</span> <span class="n">instance&#39;</span> <span class="n">declaration</span><span class="p">,</span>
        <span class="n">so</span> <span class="n">you</span> <span class="n">can</span> <span class="n">specify</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">context</span> <span class="n">yourself</span>
    <span class="kt">When</span> <span class="kr">deriving</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">BookInfo</span><span class="p">)</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="n">none</span><span class="o">.</span>
</pre></div>
</div>
<p>相反，以下代码可以使用自动推导，因为它对 <code class="docutils literal"><span class="pre">Book</span></code> 类型也使用了自动推导，使得 <code class="docutils literal"><span class="pre">Book</span></code> 类型变成了 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">:info</span></code> 命令在 ghci 中确认两种类型都是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">ad</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">ad</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">Book</span>
<span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>    <span class="c1">-- Defined at ad.hs:1:6</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Book</span> <span class="c1">-- Defined at ad.hs:2:23</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">BookInfo</span>
<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>   <span class="c1">-- Defined at ad.hs:4:6</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">BookInfo</span> <span class="c1">-- Defined at ad.hs:5:27</span>
</pre></div>
</div>
</div>
<div class="section" id="json">
<h2>类型类实战：让 JSON 更好用<a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h2>
<p>我们在 <a class="reference internal" href="5.html#representing-json-data-in-haskell"><span>在 Haskell 中表示 JSON 数据</span></a> 一节介绍的 <code class="docutils literal"><span class="pre">JValue</span></code> 用起来还不够简便。这里是一段由搜索引擎返回的实际 JSON 数据。删除重整之后：</p>
<div class="highlight-json"><div class="highlight"><pre><span class="p">{</span>
    <span class="nt">&quot;query&quot;</span><span class="p">:</span> <span class="s2">&quot;awkward squad haskell&quot;</span><span class="p">,</span>
    <span class="nt">&quot;estimatedCount&quot;</span><span class="p">:</span> <span class="mi">3920</span><span class="p">,</span>
    <span class="nt">&quot;moreResults&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;results&quot;</span><span class="p">:</span>
    <span class="p">[{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;Tackling the awkward squad: monadic input/output ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://research.microsoft.com/~simonpj/papers/marktoberdorf/&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Haskell for C Programmers | Lambda the Ultimate&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;... the best job of all the tutorials I&#39;ve read ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://lambda-the-ultimate.org/node/724&quot;</span><span class="p">,</span>
    <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>进一步简化之，并用 Haskell 表示：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleResult.hs</span>
<span class="kr">import</span> <span class="nn">SimpleJSON</span>

<span class="nf">result</span> <span class="ow">::</span> <span class="kt">JValue</span>
<span class="nf">result</span> <span class="ow">=</span> <span class="kt">JObject</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">&quot;query&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;awkward squad haskell&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;estimatedCount&quot;</span><span class="p">,</span> <span class="kt">JNumber</span> <span class="mi">3920</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;moreResults&quot;</span><span class="p">,</span> <span class="kt">JBool</span> <span class="kt">True</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;results&quot;</span><span class="p">,</span> <span class="kt">JArray</span> <span class="p">[</span>
        <span class="kt">JObject</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;snippet&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Tackling the awkward ...&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;url&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;http://.../marktoberdorf/&quot;</span><span class="p">)</span>
        <span class="p">]])</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>由于 Haskell 不原生支持包含不同类型值的列表，我们不能直接表示包含不同类型值的 JSON 对象。
我们需要把每个值都用 JValue 构造器包装起来。但这样我们的灵活性就受到了限制：如果我们想把数字 <code class="docutils literal"><span class="pre">3920</span></code> 转换成字符串 <code class="docutils literal"><span class="pre">&quot;3,920&quot;</span></code>，
我们就必须把 <code class="docutils literal"><span class="pre">JNumber</span></code> 构造器换成 <code class="docutils literal"><span class="pre">JString</span></code> 构造器。</p>
<p>Haskell 的类型类提供了一个诱人的解决方案：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">type</span> <span class="kt">JSONError</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">class</span> <span class="kt">JSON</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>
    <span class="n">fromJValue</span> <span class="ow">::</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">JValue</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">id</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="kt">Right</span>
</pre></div>
</div>
<p>现在，我们无需再用 <code class="docutils literal"><span class="pre">JNumber</span></code> 等构造器去包装值了，直接使用 <code class="docutils literal"><span class="pre">toJValue</span></code> 函数即可。
如果我们更改值的类型，编译器会自动选择相应的 <code class="docutils literal"><span class="pre">toJValue</span></code> 实现。</p>
<p>我们也提供了 <code class="docutils literal"><span class="pre">fromJValue</span></code> 函数，它把 <code class="docutils literal"><span class="pre">JValue</span></code> 值转换成我们希望的类型。</p>
<div class="section" id="more-helpful-errors">
<span id="id9"></span><h3>让错误信息更有用<a class="headerlink" href="#more-helpful-errors" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">fromJValue</span></code> 函数的返回类型为 <code class="docutils literal"><span class="pre">Either</span></code>。跟 <code class="docutils literal"><span class="pre">Maybe</span></code> 一样，这个类型是预定义的。我们经常用它来表示可能会失败的计算。</p>
<p>虽然 <code class="docutils literal"><span class="pre">Maybe</span></code> 也用作这个目的，但它在错误发生时没有给我们足够有用的信息：我们只得到一个 <code class="docutils literal"><span class="pre">Nothing</span></code>。
<code class="docutils literal"><span class="pre">Either</span></code> 类型的结构相同，但它在错误发生时会调用 <code class="docutils literal"><span class="pre">Left</span></code> 构造器，并且还接受一个参数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/DataEither.hs</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span>
             <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span>
                <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>我们经常使用 <code class="docutils literal"><span class="pre">String</span></code> 作为 <code class="docutils literal"><span class="pre">a</span></code> 参数的类型，以便在出错时提供有用的描述。
为了说明在实际中怎么使用 <code class="docutils literal"><span class="pre">Either</span></code> 类型，我们来看一个简单实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JBool</span>
    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JBool</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">b</span>
    <span class="n">fromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON boolean&quot;</span>
</pre></div>
</div>
<p>[译注：读者若想在 <strong>ghci</strong> 中尝试 <code class="docutils literal"><span class="pre">fromJValue</span></code>，需要为其提供类型标注，例如 <code class="docutils literal"><span class="pre">(fromJValue(toJValue</span> <span class="pre">True))::Either</span> <span class="pre">JSONError</span> <span class="pre">Bool</span></code>。]</p>
</div>
<div class="section" id="making-an-instance-with-a-type-synonym">
<span id="id10"></span><h3>使用类型别名创建实例<a class="headerlink" href="#making-an-instance-with-a-type-synonym" title="Permalink to this headline">¶</a></h3>
<p>Haskell 98标准不允许我们用下面的形式声明实例，尽管它看起来没什么问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">toJValue</span>               <span class="ow">=</span> <span class="kt">JString</span>

    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JString</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">s</span>
    <span class="n">fromJValue</span> <span class="kr">_</span>           <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON string&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">String</span></code> 是 <code class="docutils literal"><span class="pre">[Char]</span></code> 的别名，因此它的类型是 <code class="docutils literal"><span class="pre">[a]</span></code>，并用 <code class="docutils literal"><span class="pre">Char</span></code> 替换了类型变量 <code class="docutils literal"><span class="pre">a</span></code>。
根据 Haskell 98的规则，我们在声明实例的时候不能用具体类型替代类型变量。
也就是说，我们可以给 <code class="docutils literal"><span class="pre">[a]</span></code> 声明实例，但给 <code class="docutils literal"><span class="pre">[Char]</span></code> 不行。</p>
<p>尽管 GHC 默认遵守 Haskell 98标准，但是我们可以在文件顶部添加特殊格式的注释来解除这个限制。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances #-}</span>
</pre></div>
</div>
<p>这条注释是一条编译器指令，称为<em>编译选项（pragma）</em>，它告诉编译器允许这项语言扩展。
上面的代码因为``TypeSynonymInstances`` 这项语言扩展而合法。
我们在本章（本书）还会碰到更多的语言扩展。</p>
<p>[译注：作者举的这个例子实际上牵涉到了两个问题。第一，Haskell 98不允许类型别名，这个问题可以通过上述方法解决。
第二，Haskell 98不允许 <code class="docutils literal"><span class="pre">[Char]</span></code> 这种形式的类型，这个问题需要通过增加另外一条编译选项 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 来解决。]</p>
</div>
</div>
<div class="section" id="living-in-an-open-world">
<span id="id11"></span><h2>生活在开放世界<a class="headerlink" href="#living-in-an-open-world" title="Permalink to this headline">¶</a></h2>
<p>Haskell 的设计允许我们任意创建类型类实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">doubleToJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="n">a</span>
<span class="nf">doubleToJValue</span> <span class="n">f</span> <span class="p">(</span><span class="kt">JNumber</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">doubleToJValue</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON number&quot;</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Integer</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Double</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">id</span>
</pre></div>
</div>
<p>我们可以在任意地方创建新实例，而不仅限于在定义了类型类的模块中。类型类系统的这个特性被称为<em>开放世界假设</em>（open world assumption）。
如果有方法表示“这个类型类只存在这些实例”，那我们将得到一个<em>封闭的</em>世界。</p>
<p>我们希望把列表转为 JSON 数组。现在先不用关心实现细节，暂时用 <code class="docutils literal"><span class="pre">undefined</span></code> 替代函数内容即可。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<p>我们也希望能将键/值对列表转为 JSON 对象。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<div class="section" id="overlapping-instances">
<span id="when-do-overlapping-instances-cause-problems"></span><h3>什么时候重叠实例（Overlapping instances）会出问题？<a class="headerlink" href="#overlapping-instances" title="Permalink to this headline">¶</a></h3>
<p>如果我们把这些定义放进文件中并在 <strong>ghci</strong> 里载入，初看起来没什么问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">JSONClass</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">JSONClass</span>        <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BrokenClass</span>      <span class="p">(</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">JSONClass</span><span class="p">,</span> <span class="kt">BrokenClass</span>
</pre></div>
</div>
<p>然而，当我们使用序对列表实例时，麻烦来了。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*BrokenClass&gt; toJValue [(&quot;foo&quot;,&quot;bar&quot;)]

&lt;interactive&gt;:10:1:
    Overlapping instances for JSON [([Char], [Char])]
        arising from a use of ‘toJValue’
    Matching instances:
        instance JSON a =&gt; JSON [(String, a)]
            -- Defined at BrokenClass.hs:13:10
        instance JSON a =&gt; JSON [a] -- Defined at BrokenClass.hs:8:10
    In the expression: toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
    In an equation for ‘it’: it = toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
</pre></div>
</div>
<p><em>重叠实例</em>问题是由 Haskell 的开放世界假设造成的。
这里有一个更简单的例子来说明发生了什么。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Overlap.hs</span>
<span class="kr">class</span> <span class="kt">Borked</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">=</span> <span class="n">show</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Borked</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Borked</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Borked</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;&gt;&gt;&quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot;&lt;&lt;&quot;</span>
</pre></div>
</div>
<p>对于序对，我们有两个 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类实例：一个是 <code class="docutils literal"><span class="pre">Int</span></code> 序对，另一个是任意类型的序对，只要这个类型是 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类的实例。</p>
<p>假设我们想把 <code class="docutils literal"><span class="pre">bork</span></code> 应用于 <code class="docutils literal"><span class="pre">Int</span></code> 序对。编译器必须选择一个实例来用。由于这两个实例都能用，所以看上去它好像只要选那个更相关（specific）的实例就可以了。</p>
<p>但是，<code class="docutils literal"><span class="pre">GHC</span></code> 默认是保守的。它坚持只能有一个可用实例。这样，当我们试图使用 <code class="docutils literal"><span class="pre">bork</span></code> 时，它就会报错。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>重叠实例什么时候会出问题？</p>
<p class="last">之前我们提到，我们可以把某个类型类的实例分散在几个模块中。GHC 并不会在意重叠实例的存在。
相反，只有当我们使用受影响的类型类的函数，GHC 被迫要选择使用哪个实例时，它才会报错。</p>
</div>
</div>
<div class="section" id="relaxing-some-restrictions-on-typeclasses">
<span id="id12"></span><h3>取消类型类的一些限制<a class="headerlink" href="#relaxing-some-restrictions-on-typeclasses" title="Permalink to this headline">¶</a></h3>
<p>通常，我们不能给多态类型（polymorphic type）的特化版本（specialized version）写类型类实例。
<code class="docutils literal"><span class="pre">[Char]</span></code> 类型就是多态类型 <code class="docutils literal"><span class="pre">[a]</span></code> 特化成 <code class="docutils literal"><span class="pre">Char</span></code> 的结果。因此我们禁止声明 <code class="docutils literal"><span class="pre">[Char]</span></code> 为某个类型类的实例。
这非常不方便，因为字符串在代码中无处不在。</p>
<p><code class="docutils literal"><span class="pre">FlexibleInstances</span></code> 语言扩展取消了这个限制，它允许我们写这样的实例。</p>
<p>GHC 支持另外一个有用的语言扩展，<code class="docutils literal"><span class="pre">OverlappingInstances</span></code>，它解决了重叠实例带来的问题。
如果存在重叠实例，编译器会选择最相关的（specific）那一个。</p>
<p>我们经常把这个扩展和 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> 放在一起使用。下面是一个例子。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">intersperse</span> <span class="s">&quot;, &quot;</span> <span class="o">.</span> <span class="n">map</span> <span class="n">foo</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Char</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="n">c</span> <span class="ow">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
<p>如果我们对 <code class="docutils literal"><span class="pre">String</span></code> 应用 <code class="docutils literal"><span class="pre">foo</span></code>，编译器会选择 <code class="docutils literal"><span class="pre">String</span></code> 的特定实现。
即使 <code class="docutils literal"><span class="pre">[a]</span></code> 和 <code class="docutils literal"><span class="pre">Char</span></code> 都是 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例，但由于 <code class="docutils literal"><span class="pre">String</span></code> 实例更相关，因此 GHC 选择了它。</p>
<p>即使开了 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 扩展，如果 GHC 发现了多个同样相（equally specific）关的实例，它仍然会拒绝代码。</p>
<blockquote id="note">
<div>何时使用 OverlappingInstances 扩展（to be added）</div></blockquote>
</div>
<div class="section" id="how-does-show-work-for-strings">
<span id="id13"></span><h3>字符串的 show 是如何工作的？<a class="headerlink" href="#how-does-show-work-for-strings" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 和 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> 语言扩展是 GHC 特有的，Haskell 98 并不支持。
然而，Haskell 98 中的 <code class="docutils literal"><span class="pre">Show</span></code> 类型类在转化 <code class="docutils literal"><span class="pre">Char</span></code> 列表和 <code class="docutils literal"><span class="pre">Int</span></code> 列表时却用了不同的方法。它用了一个聪明但简单的小技巧。</p>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类定义了转换单个值的 <code class="docutils literal"><span class="pre">show</span></code> 方法和转换列表的 <code class="docutils literal"><span class="pre">showList</span></code> 方法。
<code class="docutils literal"><span class="pre">showList</span></code> 默认使用中括号和逗号转换列表。</p>
<p><code class="docutils literal"><span class="pre">[a]</span></code> 的 <code class="docutils literal"><span class="pre">Show</span></code> 实例使用 <code class="docutils literal"><span class="pre">showList</span></code> 实现。<code class="docutils literal"><span class="pre">Char</span></code> 的 <code class="docutils literal"><span class="pre">Show</span></code> 实例提供了一个特殊的 <code class="docutils literal"><span class="pre">showList</span></code> 实现，
它使用双引号，并转义非 ASCII 打印字符。</p>
<p>结果是，如果有人想对 <code class="docutils literal"><span class="pre">[Char]</span></code> 应用 <code class="docutils literal"><span class="pre">show</span></code>，编译器会选择 <code class="docutils literal"><span class="pre">showList</span></code> 的实现，并使用双引号正确转换这个字符串。</p>
<p>这样，换个角度看问题，我们就能避免 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 扩展了。</p>
</div>
</div>
<div class="section" id="how-to-give-a-type-a-new-identity">
<span id="identity"></span><h2>如何给类型定义新身份（Identity）<a class="headerlink" href="#how-to-give-a-type-a-new-identity" title="Permalink to this headline">¶</a></h2>
<p>除了熟悉的 <code class="docutils literal"><span class="pre">data</span></code> 关键字外，Haskell 还允许我们用 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字来创建新类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">data</span> <span class="kt">DataInt</span> <span class="ow">=</span> <span class="kt">D</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">NewtypeInt</span> <span class="ow">=</span> <span class="kt">N</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 声明的作用是重命名现有类型，并给它一个新身份。可以看出，它的用法和使用 <code class="docutils literal"><span class="pre">data</span></code> 关键字进行类型声明看起来很相似。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>type 和 newtype 关键字</p>
<p>尽管名字类似，<code class="docutils literal"><span class="pre">type</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字的作用却完全不同。
<code class="docutils literal"><span class="pre">type</span></code> 关键字给了我们另一种指代某个类型的方法，类似于给朋友起的绰号。
我们和编译器都知道 <code class="docutils literal"><span class="pre">[Char]</span></code> 和 <code class="docutils literal"><span class="pre">String</span></code> 指的是同一个类型。</p>
<p>相反，<code class="docutils literal"><span class="pre">newtype</span></code> 关键字的存在是为了隐藏类型的本性。考虑这个 <code class="docutils literal"><span class="pre">UniqueID</span></code> 类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">newtype</span> <span class="kt">UniqueID</span> <span class="ow">=</span> <span class="kt">UniqueID</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">编译器会把 <code class="docutils literal"><span class="pre">UniqueID</span></code> 当成和 <code class="docutils literal"><span class="pre">Int</span></code> 不同的类型。
作为 <code class="docutils literal"><span class="pre">UniqueID</span></code> 的用户，我们只知道它是一个唯一标识符；我们并不知道它是用 <code class="docutils literal"><span class="pre">Int</span></code> 来实现的。</p>
</div>
<p>在声明 <code class="docutils literal"><span class="pre">newtype</span></code> 时，我们必须决定暴露被重命名类型的哪些类型类实例。
这里，我们让 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 提供 <code class="docutils literal"><span class="pre">Int</span></code> 类型的 <code class="docutils literal"><span class="pre">Eq</span></code>， <code class="docutils literal"><span class="pre">Ord</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 实例。
这样，我们就可以比较和打印 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">N</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="kt">N</span> <span class="mi">2</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>由于我们没有暴露 <code class="docutils literal"><span class="pre">Int</span></code> 的 <code class="docutils literal"><span class="pre">Num</span></code> 或 <code class="docutils literal"><span class="pre">Integral</span></code> 实例，<code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值并不是数字。
例如，我们不能做加法。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*Main&gt; N 313 + N 37

&lt;interactive&gt;:9:7:
    No instance for (Num NewtypeInt) arising from a use of ‘+’
    In the expression: N 313 + N 37
    In an equation for ‘it’: it = N 313 + N 37
</pre></div>
</div>
<p>跟用 <code class="docutils literal"><span class="pre">data</span></code> 关键字一样，我们可以用 <code class="docutils literal"><span class="pre">newtype</span></code> 的值构造器创建新值，或者对现有值进行模式匹配。</p>
<p>如果 <code class="docutils literal"><span class="pre">newtype</span></code> 没用自动派生来暴露对应类型的类型类实现的话，我们可以自己写一个新实例或者干脆不实现那个类型类。</p>
<div class="section" id="data-newtype">
<span id="data-and-newtype"></span><h3>data 和 newtype 的区别<a class="headerlink" href="#data-newtype" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 关键字给现有类型一个不同的身份，相比起 <code class="docutils literal"><span class="pre">data</span></code>，它使用时的限制更多。具体来讲，<code class="docutils literal"><span class="pre">newtype</span></code> 只能有一个值构造器，
并且这个构造器只能有一个字段。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/NewtypeDiff.hs</span>
<span class="c1">-- 可以：任意数量的构造器和字段</span>
<span class="kr">data</span> <span class="kt">TwoFields</span> <span class="ow">=</span> <span class="kt">TwoFields</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="c1">-- 可以：一个字段</span>
<span class="kr">newtype</span> <span class="kt">Okay</span> <span class="ow">=</span> <span class="kt">ExactlyOne</span> <span class="kt">Int</span>

<span class="c1">-- 可以：使用类型变量</span>
<span class="kr">newtype</span> <span class="kt">Param</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Param</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>

<span class="c1">-- 可以：使用记录语法</span>
<span class="kr">newtype</span> <span class="kt">Record</span> <span class="ow">=</span> <span class="kt">Record</span> <span class="p">{</span>
        <span class="n">getInt</span> <span class="ow">::</span> <span class="kt">Int</span>
    <span class="p">}</span>

<span class="c1">-- 不可以：没有字段</span>
<span class="kr">newtype</span> <span class="kt">TooFew</span> <span class="ow">=</span> <span class="kt">TooFew</span>

<span class="c1">-- 不可以：多于一个字段</span>
<span class="kr">newtype</span> <span class="kt">TooManyFields</span> <span class="ow">=</span> <span class="kt">Fields</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="c1">-- 不可以：多于一个构造器</span>
<span class="kr">newtype</span> <span class="kt">TooManyCtors</span> <span class="ow">=</span> <span class="kt">Bad</span> <span class="kt">Int</span>
                     <span class="o">|</span> <span class="kt">Worse</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>除此之外，<code class="docutils literal"><span class="pre">data</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 还有一个重要区别。由 <code class="docutils literal"><span class="pre">data</span></code> 关键字创建的类型在运行时有一个簿记开销，
如记录某个值是用哪个构造器创建的。而 <code class="docutils literal"><span class="pre">newtype</span></code> 只有一个构造器，所以不需要这个额外开销。
这使得它在运行时更省时间和空间。</p>
<p>由于 <code class="docutils literal"><span class="pre">newtype</span></code> 的构造器只在编译时使用，运行时甚至不存在，
用 <code class="docutils literal"><span class="pre">newtype</span></code> 定义的类型和用 <code class="docutils literal"><span class="pre">data</span></code> 定义的类型在匹配 <code class="docutils literal"><span class="pre">undefined</span></code> 时会有不同的行为。</p>
<p>为了理解它们的不同点，我们首先回顾一下普通数据类型的行为。我们已经非常熟悉，在运行时对 <code class="docutils literal"><span class="pre">undefined</span></code> 求值会导致崩溃。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">undefined</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>我们把 <code class="docutils literal"><span class="pre">undefined</span></code> 放进 <code class="docutils literal"><span class="pre">D</span></code> 构造器创建一个 <code class="docutils literal"><span class="pre">DataInt</span></code>，然后对它进行模式匹配。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">D</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>由于我们的模式匹配只匹配构造器而不管里面的值，<code class="docutils literal"><span class="pre">undefined</span></code> 未被求值，因而不会抛出异常。</p>
<p>下面的例子没有使用 <code class="docutils literal"><span class="pre">D</span></code> 构造器，因而模式匹配时 <code class="docutils literal"><span class="pre">undefined</span></code> 被求值，异常抛出。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>当我们用 <code class="docutils literal"><span class="pre">N</span></code> 构造器创建 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 值时，它的行为与使用 <code class="docutils literal"><span class="pre">DataInt</span></code> 类型的 <code class="docutils literal"><span class="pre">D</span></code> 构造器相同：没有异常。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">N</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>但当我们把表达式中的 <code class="docutils literal"><span class="pre">N</span></code> 去掉，并对 <code class="docutils literal"><span class="pre">undefined</span></code> 进行模式匹配时，关键的不同点来了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>没有崩溃！由于运行时不存在构造器，匹配 <code class="docutils literal"><span class="pre">N</span> <span class="pre">_</span></code> 实际上就是在匹配通配符 <code class="docutils literal"><span class="pre">_</span></code>：由于通配符总可以被匹配，所以表达式是不需要被求值的。</p>
</div>
<div class="section" id="summary-the-three-ways-of-naming-types">
<span id="id14"></span><h3>命名类型的三种方式<a class="headerlink" href="#summary-the-three-ways-of-naming-types" title="Permalink to this headline">¶</a></h3>
<p>这里简要回顾一下 haskell 引入新类型名的三种方式。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">data</span></code> 关键字定义一个真正的代数数据类型。</li>
<li><code class="docutils literal"><span class="pre">type</span></code> 关键字给现有类型定义别名。类型和别名可以通用。</li>
<li><code class="docutils literal"><span class="pre">newtype</span></code> 关键字给现有类型定义一个不同的身份（distinct identity）。原类型和新类型不能通用。</li>
</ul>
</div>
</div>
<div class="section" id="json-typeclasses-without-overlapping-instances">
<span id="id15"></span><h2>不会造成重叠实例的JSON类型类<a class="headerlink" href="#json-typeclasses-without-overlapping-instances" title="Permalink to this headline">¶</a></h2>
<p>开启GHC的重叠实例支持可以方便快速地让我们的JSON代码通过编译。在更复杂的场景中，我们有时会面对这样一种情况：某个类型类有多个相关程度相同实例，重叠实例没法帮我们搞定，我们得靠自己添加几处 <code class="docutils literal"><span class="pre">newtype</span></code> 声明。我们将使用 <code class="docutils literal"><span class="pre">newtype</span></code> 代替重叠实例来重做这个JSON类型类，并以此了解其中的复杂之处。</p>
<p>我们的第一个任务，是帮助GHC区分即用来表示JSON数组的类型 <code class="docutils literal"><span class="pre">[a]</span></code> ；以及用来表示JSON对象的类型 <code class="docutils literal"><span class="pre">[(String,</span> <span class="pre">[a])]</span></code> 。这两个类型在我们学会 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 以前给我们带来了点小麻烦。我们把列表类型做了包装，所以编译器不会把它看作列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JAry.hs</span>
<span class="kr">newtype</span> <span class="kt">JAry</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">JAry</span> <span class="p">{</span>
      <span class="n">fromJAry</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们从自己的模块导出这个类型时，我们会把该类型的所有细节都暴露出来。这个模块的头部看起来会像是这样：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClassExport.hs</span>
<span class="kr">module</span> <span class="nn">JSONClass</span>
    <span class="p">(</span>
      <span class="kt">JAry</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>紧跟着``Jary``的“(..)”表示“导出这个类型的所有细节”。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>与通常做法的相悖之处</p>
<p>通常，在导出一个 <code class="docutils literal"><span class="pre">newtype</span></code> 的时候，为了让该类型的细节对外透明，我们 <em>不会</em> 导出这个类型的数据构造器，而是定义一个函数来替我们调用数据构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass2.hs</span>
<span class="nf">jary</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">JAry</span> <span class="n">a</span>
<span class="nf">jary</span> <span class="ow">=</span> <span class="kt">JAry</span>
</pre></div>
</div>
<p>我们会导出这个类型的类型构造器、解构函数、构造函数，只有数据构造器是不被导出的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClassExport2.hs</span>
<span class="kr">module</span> <span class="nn">JSONClass</span>
    <span class="p">(</span>
      <span class="kt">JAry</span><span class="p">(</span><span class="nf">fromJAry</span><span class="p">)</span>
    <span class="p">,</span> <span class="nf">jary</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>由于我们没有导出数据构造器，所以我们的库的用户们就只能使用我们导出的函数对该类型的值进行构造和结构了。这个特性为我们这些库作者提供了随时改变类型的内部表示形式的自由。</p>
<p>如果我们导出了数据构造器，用户方就可能编写依赖数据构造器的代码，比方说拿数据构造器做模式识别。如果哪天我们想要修改这个类型的内部构造，就要冒这种风险：可能修改之后，所有涉及数据构造器的代码都被破坏了。</p>
<p class="last">在当前的场景中，让数组的包装器保持抽象也得不到什么额外的好处，所以我们就干脆把类型的完整定义全数导出了。</p>
</div>
<p>我们提供了另一个包装类型，通过它，我们隐藏了JSON对象的内部表示。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass3.hs</span>
<span class="kr">newtype</span> <span class="kt">JObj</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">JObj</span> <span class="p">{</span>
      <span class="n">fromJObj</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>类型定义完毕，我们来对 <code class="docutils literal"><span class="pre">JValue</span></code> 类型的定义做一些小改动。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass4.hs</span>
<span class="kr">data</span> <span class="kt">JValue</span> <span class="ow">=</span> <span class="kt">JString</span> <span class="kt">String</span>
            <span class="o">|</span> <span class="kt">JNumber</span> <span class="kt">Double</span>
            <span class="o">|</span> <span class="kt">JBool</span> <span class="kt">Bool</span>
            <span class="o">|</span> <span class="kt">JNull</span>
            <span class="o">|</span> <span class="kt">JObject</span> <span class="p">(</span><span class="kt">JObj</span> <span class="kt">JValue</span><span class="p">)</span>   <span class="c1">-- was [(String, JValue)]</span>
            <span class="o">|</span> <span class="kt">JArray</span> <span class="p">(</span><span class="kt">JAry</span> <span class="kt">JValue</span><span class="p">)</span>    <span class="c1">-- was [JValue]</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>这个改动不会影响到已经完成的 <code class="docutils literal"><span class="pre">JSON</span></code> 类型类实例，但是我们还是要为新定义的 <code class="docutils literal"><span class="pre">JAry</span></code> 和 <code class="docutils literal"><span class="pre">JObj</span></code> 类型编写实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass5.hs</span>
<span class="nf">jaryFromJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">)</span>

<span class="nf">jaryToJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JAry</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">jaryToJValue</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">jaryFromJValue</span>
</pre></div>
</div>
<p>我们来单步跟踪将一个 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">a``值转换为</span> <span class="pre">``JValue``值的过程。假设有一个包含的元素都是</span> <span class="pre">``JSON</span></code> 类型类实例的列表，把该列表转换为 <code class="docutils literal"><span class="pre">JValue</span></code> 组成的列表的过程很简单。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/listToJValues.hs</span>
<span class="nf">listToJValues</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">JValue</span><span class="p">]</span>
<span class="nf">listToJValues</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">toJValue</span>
</pre></div>
</div>
<p>将这个值包装为 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">JValue</span></code> 值的过程实际上就是对其应用 <code class="docutils literal"><span class="pre">newtype</span></code> 的类型构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass6.hs</span>
<span class="nf">jvaluesToJAry</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">JValue</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">JAry</span> <span class="kt">JValue</span>
<span class="nf">jvaluesToJAry</span> <span class="ow">=</span> <span class="kt">JAry</span>
</pre></div>
</div>
<p>(记住，这种做法没有任何性能代价。我们只是要求编译器隐藏“正在操作的对象是一个列表”这个事实。)要把这个值转换为 <code class="docutils literal"><span class="pre">JValue</span></code> 值，我们还得应用另一个类型构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/jaryOfJValuesToJValue.hs</span>
<span class="nf">jaryOfJValuesToJValue</span> <span class="ow">::</span> <span class="kt">JAry</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>
<span class="nf">jaryOfJValuesToJValue</span> <span class="ow">=</span> <span class="kt">JArray</span>
</pre></div>
</div>
<p>使用函数组合(function composition)将上面这些代码片段组装到一起，我们就得到了一个可以把值转换为 <code class="docutils literal"><span class="pre">JValue</span></code> 类型的函数，它简洁到只有一行。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/jaryToJValue.hs</span>
<span class="nf">jaryToJValue</span> <span class="ow">=</span> <span class="kt">JArray</span> <span class="o">.</span> <span class="kt">JAry</span> <span class="o">.</span> <span class="n">map</span> <span class="n">toJValue</span> <span class="o">.</span> <span class="n">fromJAry</span>
</pre></div>
</div>
<p>要把 <code class="docutils literal"><span class="pre">JValue</span></code> 值转换为 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">a</span></code> 需要做更多的工作，但是我们把它拆分成多个可重用的部分。转换函数的基本骨架一目了然。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/jaryFromJValue.hs</span>
<span class="nf">jaryFromJValue</span> <span class="p">(</span><span class="kt">JArray</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=</span>
    <span class="n">whenRight</span> <span class="kt">JAry</span> <span class="p">(</span><span class="n">mapEithers</span> <span class="n">fromJValue</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">jaryFromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON array&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">whenRight</span></code> 函数会检查传给它的参数：如果第二个参数是用 <code class="docutils literal"><span class="pre">Right</span></code> 构造器创建的，以它为参数调用第一个参数指定的函数；如果第二个参数是 <code class="docutils literal"><span class="pre">Left</span></code> 构造器创建的，则将它保持原状返回，其它什么也不做。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/whenRight.hs</span>
<span class="nf">whenRight</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">c</span>
<span class="nf">whenRight</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
<span class="nf">whenRight</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mapEithers``函数要更复杂一些。它的行为就像</span> <span class="pre">``map</span></code> 函数，但如果它遇到一个 <code class="docutils literal"><span class="pre">Left``值，会直接返回该值，而不会继续积累</span> <span class="pre">``Right</span></code> 值构成的列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/mapEithers.hs</span>
<span class="nf">mapEithers</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="nf">mapEithers</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">mapEithers</span> <span class="n">f</span> <span class="n">xs</span> <span class="kr">of</span>
                        <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
                        <span class="kt">Right</span> <span class="n">ys</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">of</span>
                                      <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
                                      <span class="kt">Right</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">mapEithers</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>由于隐藏在 <code class="docutils literal"><span class="pre">JObj</span></code> 类型中的列表元素有更细碎的结构，相应的，在它和 <code class="docutils literal"><span class="pre">JValue</span></code> 类型之间互相转换的代码就会有点复杂。万幸的是，我们可以重用刚刚定义过的函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/toJValue.hs</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">(</span><span class="nf">second</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">(</span><span class="kt">JObj</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JObject</span> <span class="o">.</span> <span class="kt">JObj</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">second</span> <span class="n">toJValue</span><span class="p">)</span> <span class="o">.</span> <span class="n">fromJObj</span>

    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JObject</span> <span class="p">(</span><span class="kt">JObj</span> <span class="n">o</span><span class="p">))</span> <span class="ow">=</span> <span class="n">whenRight</span> <span class="kt">JObj</span> <span class="p">(</span><span class="n">mapEithers</span> <span class="n">unwrap</span> <span class="n">o</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">unwrap</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">whenRight</span> <span class="p">((,)</span> <span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n">fromJValue</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">fromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON object&quot;</span>
</pre></div>
</div>
<div class="section" id="id16">
<h3>练习题<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>在 <strong>ghci</strong> 中加载 <code class="docutils literal"><span class="pre">Control.Arrow</span></code> 模块，弄清 <code class="docutils literal"><span class="pre">second</span></code> 函数的功能。</li>
<li><code class="docutils literal"><span class="pre">(,)``是什么类型？在</span> <span class="pre">**ghci**</span> <span class="pre">中调用它时，它的行为是什么？</span> <span class="pre">``(,,)</span></code> 呢？</li>
</ol>
</div>
</div>
<div class="section" id="monomorphism-restriction">
<span id="the-dreaded-monomorphism-restriction"></span><h2>可怕的单一同态限定（monomorphism restriction）<a class="headerlink" href="#monomorphism-restriction" title="Permalink to this headline">¶</a></h2>
<p>Haskell 98 有一个微妙的特性可能会在某些意想不到的情况下“咬”到我们。下面这个简单的函数展示了这个问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Monomorphism.hs</span>
<span class="nf">myShow</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>如果我们试图把它载入 <strong>ghci</strong>，会产生一个奇怪的错误：</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :l Monomorphism.hs

[1 of 1] Compiling Main             ( Monomorphism.hs, interpreted )

Monomorphism.hs:2:10:
    No instance for (Show a0) arising from a use of ‘show’
    The type variable ‘a0’ is ambiguous
    Relevant bindings include
        myShow :: a0 -&gt; String (bound at Monomorphism.hs:2:1)
    Note: there are several potential instances:
        instance Show a =&gt; Show (Maybe a) -- Defined in ‘GHC.Show’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 22 others
    In the expression: show
    In an equation for ‘myShow’: myShow = show
    Failed, modules loaded: none.
</pre></div>
</div>
<p>[译注：译者得到的输出和原文有出入，这里提供的是使用最新版本 GHC 得到的输出。]</p>
<p>错误信息中提到的 “monomorphism” 是 Haskell 98 的一部分。
<em>单一同态</em>是多态（polymorphism）的反义词：它表明某个表达式只有一种类型。
Haskell 有时会强制使某些声明不像我们预想的那么多态。</p>
<p>我们在这里提单一同态是因为尽管它和类型类没有直接关系，但类型类给它提供了产生的环境。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在实际代码中可能很久都不会碰到单一同态，因此我们觉得你没必要记住这部分的细节，
只要在心里知道有这么回事就可以了，除非 GHC 真的报告了跟上面类似的错误。
如果真的发生了，记得在这儿曾读过这个错误，然后回过头来看就行了。</p>
</div>
<p>我们不会试图去解释单一同态限制。Haskell 社区一致同意它并不经常出现；它解释起来很棘手（tricky)；
它几乎没什么实际用处；它唯一的作用就是坑人。举个例子来说明它为什么棘手：尽管上面的例子违反了这个限制，
下面的两个编译起来却毫无问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Monomorphism.hs</span>
<span class="nf">myShow2</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">value</span>

<span class="nf">myShow3</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">myShow3</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>上面的定义表明，如果 GHC 报告单一同态限制错误，我们有三个简单的方法来处理。</p>
<ul class="simple">
<li>显式声明函数参数，而不是隐性。</li>
<li>显式定义类型签名，而不是依靠编译器去推导。</li>
<li>不改代码，编译模块的时候用上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 语言扩展。它取消了单一同态限制。</li>
</ul>
<p>没人喜欢单一同态限制，因此几乎可以肯定的是下一个版本的 Haskell 会去掉它。
但这并不是说加上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 就可以一劳永逸：有些编译器（包括一些老版本的 GHC）
识别不了这个扩展，但用另外两种方法就可以解决问题。如果这种可移植性对你不是问题，那么请务必打开这个扩展。</p>
</div>
<div class="section" id="conclusion">
<span id="id17"></span><h2>结论<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>在这章，你学到了类型类有什么用以及怎么用它们。我们讨论了如何定义自己的类型类，然后又讨论了一些 Haskell 库里定义的类型类。
最后，我们展示了怎么让 Haskell 编译器给你的类型自动派生出某些类型类实例。</p>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第五章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第七章：I/O</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>