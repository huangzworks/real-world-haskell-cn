.. _using-typeclasses:

第 6 章：使用类型类
=========================

类型类（typeclass）跻身于 ``Haskell`` 最强大功能之列：
它们（typeclasses）允许你定义通用接口，而其（这些接口）为各种不同的类型（type）提供一组公共特性集。
类型类是某些基本语言特性的核心，比如相等性测试（equality testing）和数值操作符（numeric operators）。
在讨论到底类型类是什么之前，我想解释下他们的作用（the need for them）。


.. _the-need-for-typeclasses:

类型类的作用
---------------

假设因为某个原因，
``Haskell`` 语言的设计者拒绝实现相等性测试 ``==`` ，
因此我们决定实现自己的 ``==`` 操作。
你的应用由一个简单的 ``Color`` 类型组成。
首先你尝试一下，像这样：

::

   -- file: ch06/naiveeq.hs
   data Color = Red | Green | Blue

   colorEq :: Color -> Color -> Bool
   colorEq Red   Red   = True
   colorEq Green Green = True
   colorEq Blue  Blue  = True
   colorEq _     _     = False

让我们在 ghci 里测试一下：

::

    Prelude> :l naiveeq.hs
    [1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
    Ok, modules loaded: Main.
    *Main> colorEq Green Green
    True
    *Main> colorEq Red Red
    True
    *Main> colorEq Red Green
    False

现在，假设你想要添加 ``String`` 的相等性测试(equality testing)。
因为一个 ``Haskell`` 的 ``String`` 其实是字符们（characters）的列表(即[char])，所以我们可以写一个小函数来运行那个测试(相等性测试)。
为了简单（偷懒）起见，我们作一下弊：使用 ``==`` 操作符。

::

   -- file: ch06/naiveeq.hs
   stringEq :: [Char] -> [Char] -> Bool

   -- Match if both are empty
   stringEq [] [] = True

   -- If both start with the same char, check the rest
   stringEq (x:xs) (y:ys) = x == y && stringEq xs ys

   -- Everything else doesn't match
   stringEq _ _ = False

让我们运行一下：

::

   Prelude> :l naiveeq.hs
   [1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
   Ok, modules loaded: Main.

   *Main> stringEq "" ""
   True

   *Main> stringEq "" []
   True

   *Main> stringEq "" [""]
   <interactive>:5:14:
   Couldn't match expected type `Char' with actual type `[Char]'
   In the expression: ""
   In the second argument of `stringEq', namely `[""]'
   In the expression: stringEq "" [""]

现在你应该能看出一个问题了吧：我们不得不为各个不同类型（type）实现一坨带有不同名字的函数（function），以便我们有能力用其进行比较。
这种做法非常低效，而且烦人。
如果我们能用 ``==`` 对比任何类型的值，就再方便不过了。

同时，我们能定义一些通用（generic）函数，比如基于 ``==`` 的 ``/=`` ， 其能对几乎任何东西（anything）合法。
通过写一个通用函数，其能比较所有的东西，也能使我们的代码一般化（generic）：如果一段代码仅需要比较（compare）一些东西，然后他应该就能够接受任何数据类型，而对其（这些类型）编译器是知道如何比较的。

而且更进一步，如果以后新类型被添加进来，现有的代码不应该被修改。
而Haskell 的类型类（typeclass）就是被设计成处理上面的这些破事的。


.. _what-are-typeclasses:

什么是类型类？
--------------------

类型类定义了一系列函数，而这些函数对于不同类型的值使用不同的函数实现。
它和面向对象（object-oriented）语言的对象（objects）有些类似，但是他们是完全不同的。

[huangz，labyrlnth，YenvY等译者注：这里原文是将“面向对象编程中的对象”和 Haskell 的类型类进行类比，但实际上这种类比并不太恰当，类比成接口和多态方法更适合一点。]
[sancao2译注:我觉得作者不是不知道类型类应该与接口和多态方法类比，他这么说的原因是下面他自己的注释"When is a class not a class?"里面说的，因为类型类的关键词是class，传统面向对象编程里面的关键词也是class。]

让我们使用类型类来解决我们章节前面相等性测试的困局。
首先，我们定义类型类本身。
我们需要一个函数，其接受两个参数。
每个参数拥有相同的类型，然后返回一个 ``Bool`` 类型以指示他们是否相等。
我们不关心这些类型到底是什么，但我需要的是同一个类型的两项(items)。

下面是我们的类型的初定义：

::

    -- file: ch06/eqclasses.hs
    class BasicEq a where
        isEqual :: a -> a -> Bool

这个定义说，我们申明（使用 ``class`` 关键字）了一个类型类（typeclass），其名字叫 ``BasicEq`` 。
接着我们将引用（refer to）实例类型（instance types），带着字母 ``a`` 作名字。
一个类型类的实例类型可以是任何类型，只要其（实例类型）实现了类型类中定义的函数。
这个类型类定义了一个函数(``isEqual``)，而这个函数接受两个参数，他们（这俩参数）对应于实例类型即 ``a`` ，并且返回一个 ``Bool`` 型。

在定义的第一行，参数（实例类型）的名字是任选的。
就是说，我们能使用任意名字。
关键之处在于，当我们列出函数的类型时，我们必须使用相同的名字引用实例类型们（instance types）。
比如说，我们使用 ``a`` 来表示实例类型，那么函数签名中也必须使用 ``a`` 来代表这个实例类型。

让我们在 ``ghci`` 看一下 ``isEqual`` 的类型。
回想一下，在 ``ghci`` 我们能用 ``:type`` （简写 ``:t`` ）来查看某些东西的类型。

::

    Prelude> :load eqclasses.hs
    [1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :type isEqual
    isEqual :: (BasicEq a) => a -> a -> Bool

这种方式让我们读出：＂对于所有的类型 ``a`` ，只要 ``a`` 是 ``BasicEq`` 的一个实例， ``isEqual`` 就能接受两个类型为 ``a`` 的参数，并返回一个 ``Bool`` 。＂
让我们快速地浏览一遍为某个特定类型定义的 ``isEqual`` 吧。

::

    -- file: ch06/eqclasses.hs
    instance BasicEq Bool where
        isEqual True  True  = True
        isEqual False False = True
        isEqual _     _     = False

你能用 ``ghci`` 来验证我们基于 ``Bool`` 类的 ``isEqual`` ， 而不是基于其他实例类型的。

::

    *Main> isEqual True True
    True

    *Main> isEqual False True
    False

    *Main> isEqual "hello" "moto"

    <interactive>:5:1:
        No instance for (BasicEq [Char])
              arising from a use of `isEqual'
        Possible fix: add an instance declaration for (BasicEq [Char])
        In the expression: isEqual "hello" "moto"
        In an equation for `it': it = isEqual "hello" "moto"

.. ** fix editor highlight

注意，当我们试图比较两个字符串，ghci抱怨到，“我们没有提供基于 ``[Char]`` 实例类型的 ``BasicEq`` ，所以他不知道如何去比较 ``[Char]`` 。”
并且其建议（"``Possible fix``"）我们可以通过定义基于 ``[Char]`` 实例类型的 ``BasicEq`` 。

稍后的一节我们将会详细介绍定义实例（instances）。
不过，首先让我们继续看定义类型类(typeclass)。
在这个例子中，一个＂不相等＂（not-equal-to）函数可能很有用。
这里我们可以做的是，定义一个带两个函数的类型类（typeclass）：

::

    -- file: ch06/eqclasses.hs
    class BasicEq2 a where
        isEqual2    :: a -> a -> Bool
        isNotEqual2 :: a -> a -> Bool

如果有人要提供一个 ``BasicEq2`` 的实例（instance），那么他将要定义两个函数： ``isEqual2`` 和 ``isNotEqual2`` 。
当我们定义好以上的 ``BasicEq2`` ， 看起来我们为自己制造了额外的工作。
从逻辑上讲，如果我们知道 ``isEqual2`` 或 ``isNotEqual2`` 返回的是什么，那么我们就可以知道另外一个函数的返回值，对于所有（输入）类型来说。
为了避免让类型类的用户为所有类型都定义两个函数，我们可以提供他们（两个函数）的默认实现。
然后，用户只要自己实现其中一个就可以了。
这里的例子展示了如何实现这种手法。

::

    -- file: ch06/eqclasses.hs
    class BasicEq3 a where
        isEqual3 :: a -> a -> Bool
        isEqual3 x y = not (isNotEqual3 x y)

        isNotEqual3 :: a -> a -> Bool
        isNotEqual3 x y = not (isEqual3 x y)

人们实现这个类型类必须提供至少一个函数的实现。
当然他们可以实现两个，如果他们乐意，但是他们不必被强制（这么做）。
虽然我们提供两个函数的默认实现，每个函数取决于另外一个来计算答案。
如果我们不指定至少一个，所产生的代码将是一个无尽循环。
因此，至少得有一个函数总是要被实现。

以下是将 ``Bool`` 作为 ``BasicEq3`` 实例类型的例子。

::

    -- file: ch06/eqclasses.hs
    instance BasicEq3 Bool where
        isEqual3 False False = True
        isEqual3 True  True  = True
        isEqual3 _     _     = False

我们只要定义 ``isEqual3`` 函数，就可以“免费”得到 ``isNotEqual3`` ：

::

    Prelude> :load eqclasses.hs
    [1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> isEqual True True
    True

    *Main> isEqual False False
    True

    *Main> isNotEqual False True
    True

用 ``BasicEq3`` ，我们提供了一个类型类(class)，其行为类似于 ``Haskell`` 原生的 ``==`` 和 ``/=`` 操作符。
事实上，这些操作符本来就是被一个类型类定义的，其看起来几乎等价于 ``BasicEq3`` 。
"Haskell 98 Report"定义了一个类型类，它实现了相等性比较(equality comparison)。
这是内建类型类 ``Eq`` 的代码。
注意到他和我们的 ``BasicEq3`` 类型类多么相似呀。

::

   class  Eq a  where
    (==), (/=) :: a -> a -> Bool

       -- Minimal complete definition:
       --     (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)

.. _declaring-typeclass-instances:

定义类型类实例
-------------------

现在你知道了怎么定义一个类型类，是时候学习一下怎么定义某个类型类的实例(instance)。
回忆一下那些用于创造某个特定类型类的实例的类型们(types)，他们是通过实现对那个类型类必须的函数来实现的。
回忆一下我们位于章节前面的尝试(attemp)，针对 ``Color`` 类型创造的相等性测试。

那么让我们看看我们要怎样创造同样的 ``Color`` 类型，作为 ``BasicEq3`` 类型类的一员。

::

    -- file: ch06/naiveeq.hs
    instance BasicEq3 Color where
        isEqual3 Red Red = True
        isEqual3 Blue Blue = True
        isEqual3 Green Green = True
        isEqual3 _ _ = False

注意，这里的函数定义和之前 "类型类的作用" 章节的 ``colorEq`` 函数定义实际上没有什么不同。
事实上，它的实现就是等价的。
然而，在本例中，我们能将 ``isEqual3`` 使用于\*任何*\类型上，只要其(该类型)声明成 ``BasicEq3`` 的一个实例(instance)， 而不仅仅限于 ``Color`` 一类。
我们能定义相等性测试，针对任何东西，从数值到图形，通过采用相同的基本模式(basic pattern)的方式。
事实上，我们将会在 "相等性，有序和对比" 章节中看到，这就是你能使Haskell的 ``==`` 操作符作用于你自己的类型的方式。

还要注意到，虽然 ``BasicEq3`` 类型类定义了两个函数 ``isEqual`` 和 ``isNotEqual`` ， 但是我们只实现了其中的一个，在 ``Color`` 的例子中。
那得归功于包含于 ``BasicEq3`` 中的默认实现。
即使我们没有显式地定义 ``isNotEqual3`` ， 编译器也会自动地使用 ``BasicEq3`` 声明中的默认实现。

.. _important-built-in-typeclasses:

重要的内置类型类
-----------------------

前面两节我们分别讨论了(如何)定义你自己的类型类(typeclass)，以及如何创造你自己的类型类实例(type instance)。

是时候介绍几个作为 ``Prelude`` 库一部分的类型类。
如本章开始时所说的，类型类处于 Haskell 语言某些重要特性的中心。
我们将讨论最常见的几个。
更多细节，"Haskell library reference" 是一个很好的资源。
其将给你介绍类型类，并且将一直告诉你什么函数是你必须要实现的以获得一份完整的定义。

Show
^^^^^^^

``Show`` 类型类用于将值(values)转换为字符串(Strings)，其最常用的（功能）可能是将数值(numbers)转换成字符串，但是他被定义成如此多类型以至于能转化相当多东西。
如果你已经定义了你自己的类型们(types)，创造他们(types) ``Show`` 的实例，将会使他们能够在 ``ghci`` 中展示或者在程序中打印出来。
``Show`` 类型类中最重要的函数是 ``show`` 。
其接受一个参数，以用于数据(data)转换，并返回一个 ``String`` ，以代表这个数据(data)。

::

    Main> :type show
    show :: Show a => a -> String

让我们看看一些例子，关于转化数值到字符串的。

::

    Main> show 1
    "1"

    Main> show [1, 2, 3]
    "[1,2,3]"

    Main> show (1, 2)
    "(1,2)"

记住 ``ghci`` 显示出结果，就像你进入一个Haskell的程序。
所以表达式 ``show 1`` 返回一个包含数字 ``1`` 的单字符的字符串。
即引号不是字符串本身的一部分。
我们将使用 ``putStrLn`` 明确这一点。

::

    ghci> putStrLn (show 1)
    1
    ghci> putStrLn (show [1,2,3])
    [1,2,3]

你也可以将 ``show`` 用在 ``String`` 上面。

::

   ghci> show "Hello!"
   "\"Hello!\""
   ghci> putStrLn (show "Hello!")
   "Hello!"
   ghci> show ['H', 'i']
   "\"Hi\""
   ghci> putStrLn (show "Hi")
   "Hi"
   ghci> show "Hi, \"Jane\""
   "\"Hi, \\\"Jane\\\"\""
   ghci> putStrLn (show "Hi, \"Jane\"")
   "Hi, \"Jane\""

运行 ``show`` 于 ``String`` 之上，可能使你感到困惑。
因为 ``show`` 生成了一个结果，其相配（suitable）于Haskell的字面值(literal)，
或者说， ``show`` 添加了引号和转义符号("\")，其适用于Haskell程序内部。
``ghci`` 也用 ``show`` 来显示结果，所以引号和转义符号被添加了两次。
使用 ``putStrLn`` 能帮助你明确这种差异。

你能轻易地定义你自己的 ``Show`` 实例，如下。

::

   -- file: ch06/naiveeq.hs
   instance Show Color where
       show Red   = "Red"
       show Green = "Green"
       show Blue  = "Blue"

上面的例子定义了 ``Show`` 类型类的实例，其针对我们章节前面的定义的类型 ``Color`` 。

.. note:: ``Show`` 类型类

   ``show`` 经常用于定义数据(data)的字符串(``String``)表示，其非常有利于机器使用用 ``Read`` 类型类解析回来。
   Haskell程序员经常写自己的函数去格式化(format)数据以漂亮的方式为终端用户呈现，如果这种表示方式有别于 ``Show`` 预期的输出。

因此，如果你定义了一种新的数据类型，并且希望通过 ghci 来显示它，那么你就应该将这个类型实现为 ``Show`` 类型类的实例，否则 ghci 就会向你抱怨，说它不知道该怎样用字符串的形式表示这种数据类型：

::

    Main> data Color = Red | Green | Blue;

    Main> show Red

    <interactive>:10:1:
        No instance for (Show Color)
            arising from a use of `show'
        Possible fix: add an instance declaration for (Show Color)
        In the expression: show Red
        In an equation for `it': it = show Red

    Prelude> Red

    <interactive>:5:1:
        No instance for (Show Color)
            arising from a use of `print'
        Possible fix: add an instance declaration for (Show Color)
        In a stmt of an interactive GHCi command: print it

通过实现 ``Color`` 类型的 ``show`` 函数，让 ``Color`` 类型成为 ``Show`` 的类型实例，可以解决以上问题：

::

    -- file: ch06/naiveeq.hs
    instance Show Color where
        show Red   = "Red"
        show Green = "Green"
        show Blue  = "Blue"

当然， ``show`` 函数的打印值并不是非要和类型构造器一样不可，比如 ``Red`` 值并不是非要表示为 ``"Red"`` 不可，以下是另一种实例化 ``Show`` 类型类的方式：

::

    -- file: ch06/naiveeq.hs
    instance Show Color where
        show Red   = "Color 1: Red"
        show Green = "Color 2: Green"
        show Blue  = "Color 3: Blue"

Read
^^^^^^^

``Read`` 类型类，本质上 和 ``Show`` 类型类相反: 其(``Read``)最有用的函数是 ``read`` ，它接受一个字符串作为参数，对这个字符串进行解析(parse)，并返回一个值。
这个值的类型为 ``Read`` 实例类型的成员（所有实例类型中的一种）。

::

    Prelude> :type read
    read :: Read a => String -> a

这是一个例子，展示了 ``read`` 和 ``show`` 函数的用法:

::

   -- file: ch06/read.hs
   main = do
     putStrLn "Please enter a Double:"
     inpStr <- getLine
     let inpDouble = (read inpStr)::Double
     putStrLn ("Twice " ++ show inpDouble ++ " is " ++ show (inpDouble * 2))

测试结果如下：

::

   Prelude> :l read.hs
   [1 of 1] Compiling Main             ( read.hs, interpreted )
   Ok, modules loaded: Main.
   *Main> main
   Please enter a Double:
   123.213
   Twice 123.213 is 246.426

这是一个简单的例子，关于 ``read`` 和 ``show``。
请注意，我们给出了一个显式的 ``Double`` 类型，当运行 ``read`` 函数的时候。

那是因为 ``read`` 会返回任意类型的值(a value of type) ``Read a => a`` ， 并且 ``show`` 期望任意类型的值 ``Show a => a`` 。
存在着许许多多类型(type)，其拥有定义于 ``Read`` 和 ``Show`` 之上的实例(instance)。

不知道一个特定的类型，编译器必须从许多类型中猜出那个才是必须的(needed)。
在上面的这种情况下，他可能会经常选择 ``Integer`` 类型。
如果我们想要接受的是浮点输入，他就不会正常工作，所以我们提供了一个显式的类型。

.. note:: 关于默认值的笔记

   在大多数情况下，如果显式的 ``Double`` 类型标记被忽略了，编译器会拒绝猜测一个通用的类型，并仅仅返回一个错误。
   他能默认以 ``Integer`` 类型这件事请是个特例。
   他起因于以下事实:字面值 ``2`` (在程序中 ``inpDouble * 2``)被当成 ``Integer`` 除非他得到一个不同类型的期望。]

你能看到相同的效果在起作用，如果你试着在 ``ghci`` 命令行中使用 ``read`` 。
``ghci`` 内部使用 ``show`` 来展示结果， 意味着你可能同样会碰到一样会碰到模棱两可的类型问题。
你将须要显式地指定类型于 ``read`` 的结果在 ``ghci`` 当中，如下。

::

    Prelude> read "3"

    <interactive>:5:1:
        Ambiguous type variable `a0' in the constraint:
              (Read a0) arising from a use of `read'
        Probable fix: add a type signature that fixes these type variable(s)
        In the expression: read "3"
        In an equation for `it': it = read "3"

    Prelude> (read "3")::Int
    3

    Prelude> :type it
    it :: Int

    Prelude> (read "3")::Double
    3.0

    Prelude> :type it
    it :: Double

注意，在第一次调用 ``read`` 的时候，我们并没有显式地给定类型签名，这时对 ``read "3"`` 的求值会引发错误。
这是因为有非常多的类型都是 ``Read`` 的实例，而编译器在 ``read`` 函数读入 ``"3"`` 之后，不知道应该将这个值转换成什么类型，于是编译器就会向我们发牢骚。

因此，为了让 ``read`` 函数返回正确类型的值，必须给它指示正确的类型。

回想一下， ``read`` 函数的类型签名: ``(Read a) => String -> a`` 。
``a`` 在这里是 ``Read`` 类型类的任何实例类型。
其特定的解析函数被调用取决于 ``read`` 返回值的期望类型。
让我们看看他是怎么工作的。

::

   ghci> (read "5.0")::Double
   5.0
   ghci> (read "5.0")::Integer
   *** Exception: Prelude.read: no parse

注意到错误(将发生)当你试图解析 ``5.0`` 作为一个整数 ``Integer`` 。
解释器选择了一个不同的 ``Read`` 实例：
当返回值的期望是 ``Integer`` ，而他做的却是期望得到一个 ``Double`` 。
``Integer`` 的解析器不能接受小数点，从而抛出一个异常。

``Read`` 类型提供了一些相当复杂的解析器。
你可以定义一个简单的解析器，通过提供 ``readsPrec`` 函数的实现。
你的实现能返回一个列表(list)：该列表在解析成功时包含一个元组(tuple)，在解析失败时为空。
下面是一个实现的例子。

::

   -- file: ch06/naiveeq.hs
   instance Read Color where
       -- readsPrec is the main function for parsing input
       readsPrec _ value =
           -- We pass tryParse a list of pairs.  Each pair has a string
           -- and the desired return value.  tryParse will try to match
           -- the input to one of these strings.
           tryParse [("Red", Red), ("Green", Green), ("Blue", Blue)]
           where tryParse [] = []    -- If there is nothing left to try, fail
                 tryParse ((attempt, result):xs) =
                      -- Compare the start of the string to be parsed to the
                      -- text we are looking for.
                      if (take (length attempt) value) == attempt
                         -- If we have a match, return the result and the
                         -- remaining input
                         then [(result, drop (length attempt) value)]
                         -- If we don't have a match, try the next pair
                         -- in the list of attempts.
                         else tryParse xs

运行测试一下:

::

   *Main> :l naiveeq.hs
   [1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
   Ok, modules loaded: Main.
   *Main> (read "Red")::Color
   Color 1: Red
   *Main> (read "Green")::Color
   Color 2: Green
   *Main> (read "Blue")::Color
   Color 3: Blue
   *Main> (read "[Red]")::Color
   *** Exception: Prelude.read: no parse
   *Main> (read "[Red]")::[Color]
   [Color 1: Red]
   *Main> (read "[Red,Green,Blue]")::[Color]
   [Color 1: Red,Color 2: Green,Color 3: Blue]
   *Main> (read "[Red, Green, Blue]")::[Color]
   *** Exception: Prelude.read: no parse

注意到最后的尝试产生了错误。
那是因为我们的编译器没有聪明到可以处理置位(leading，包括前置和后置)的空格。
你可以改进他，通过些改你的 ``Read`` 实例以忽略任何置位的空格。
这在Haskell程序中是常见的做法。

使用 ``Read`` 和 ``Show`` 进行序列化
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

很多时候，程序需要将内存中的数据保存为硬盘上的文件以备将来获取，或者通过网络发送出去。
把内存中的数据转化成为，为存储目的，序列的过程，被称为 ``序列化`` 。

通过将类型实现为 ``Read`` 和 ``Show`` 的实例类型， ``read`` 和 ``show`` 两个函数可以成为非常好的序列化工具。
``show`` 函数生成的输出是人类和机器皆可读的。
大部分 ``show`` 输出也是对Haskell语法合法的，虽然他取决于人们如何写 ``Show`` 实例来达到这个结果。

.. note:: 解析超大（large）字符串

   字符串处理在Haskell中通常是惰性的，所以 ``read`` 和 ``show`` 能被无意外地用于很大的数据结构。
   Haskell中内建的 ``read`` 和 ``show`` 实例被实现成高效的纯函数。
   如果想知道怎么处理解析的异常，请参考"19章 错误处理"。

作为例子，以下代码将一个内存中的列表序列化到文件中：

::

    Prelude> let years = [1999, 2010, 2012]

    Prelude> show years
    "[1999,2010,2012]"

    Prelude> writeFile "years.txt" (show years)

``writeFile`` 将给定内容写入到文件当中，它接受两个参数，第一个参数是文件路径，第二个参数是写入到文件的字符串内容。

观察文件 ``years.txt`` 可以看出， ``(show years)`` 所产生的文本被成功保存到了文件当中：

::

    $ cat years.txt
    [1999,2010,2012]

使用以下代码可以对 ``years.txt`` 进行反序列化操作：

::

    Prelude> input <- readFile "years.txt"

    Prelude> input                  -- 读入的字符串
    "[1999,2010,2012]"

    Prelude> (read input)::[Int]    -- 将字符串转换成列表
    [1999,2010,2012]

``readFile`` 读入给定的 ``years.txt`` ，并将它的内存传给 ``input`` 变量。
最后，通过使用 ``read`` ，我们成功将字符串反序列化成一个列表。

.. _numeric-types:

数值类型
^^^^^^^^^^^^

Haskell 有一个非常强大的数值类型集合：从速度飞快的 32 位或 64 位整数，到任意精度的有理数，无所不包。
你可能知道操作符(比如 ``(+)``)能作用于所有的这些类型。
这个特性是用类型(typeclass)类实现的。
作为附带的好处，
他(Haskell)允许你定义自己的数值类型，并且把他们当做Haskell的一等公民(first-class citizens)。

让我们开始讨论，关于围绕在数值类型(numberic types)周围的类型类们(typeclass)，用以类型们(type)本身的检查(examination)。
以下表格显示了 Haskell 中最常用的一些数值类型。
请注意，存在这更多数值类型用于特定的目的，比如提供接口给 ``C`` 。

----

**表格 6.1 ： 部分数值类型**

========    =====================================================================
类型        介绍
========    =====================================================================
Double      双精度浮点数。表示浮点数的常见选择。
Float       单精度浮点数。通常在对接 C 程序时使用。
Int         固定精度带符号整数；最小范围在 -2^29 至 2^29-1 。相当常用。
Int8        8 位带符号整数
Int16       16 位带符号整数
Int32       32 位带符号整数
Int64       64 位带符号整数
Integer     任意精度带符号整数；范围由机器的内存限制。相当常用。
Rational    任意精度有理数。保存为两个整数之比（ratio）。
Word        固定精度无符号整数。占用的内存大小和 ``Int`` 相同
Word8       8 位无符号整数
Word16      16 位无符号整数
Word32      32 位无符号整数
Word64      64 位无符号整数
========    =====================================================================

----

这是相当多的数值类型。
存在这某些操作符，比如加号 ``(+)`` ，其能在他们中的所有之上工作。
另外的一部分函数，比如 ``asin`` ，只能用于浮点数类型。

以下表格汇总了操作(operate)于不同类型的不同函数。
当你读到表，记住，Haskell操作符们(operators)只是函数。
你可以通过 ``(+) 2 3`` 或者 ``2 + 3`` 得到相同的结果。
按照惯例，当讲操作符当做函数时，他们被写在括号中，如下表 6.2。

----

**表格 6.2 ： 部分数值函数和常量**

============== =========================================== =========== ===================================================================
项              类型                                        模块        描述
============== =========================================== =========== ===================================================================
(+)             Num a => a -> a -> a                        Prelude     加法
(-)             Num a => a -> a -> a                        Prelude     减法
(*)             Num a => a -> a -> a                        Prelude     乘法
(/)             Fractional a => a -> a -> a                 Prelude     份数除法
(**)            Floating a => a -> a -> a                   Prelude     乘幂
(^)             (Num a, Integral b) => a -> b -> a          Prelude     计算某个数的非负整数次方
(^^)            (Fractional a, Integral b) => a -> b -> a   Prelude     分数的任意整数次方
(%)             Integral a => a -> a -> Ratio a             Data.Ratio  构成比率
(.&.)           Bits a => a -> a -> a                       Data.Bits   二进制并操作
(.|.)           Bits a => a -> a -> a                       Data.Bits   二进制或操作
abs             Num a => a -> a                             Prelude     绝对值操作
approxRational  RealFrac a => a -> a -> Rational            Data.Ratio  通过分数的分子和分母计算出近似有理数
cos             Floating a => a -> a                        Prelude     余弦函数。另外还有 acos 、 cosh 和 acosh ，类型和 cos 一样。
div             Integral a => a -> a -> a                   Prelude     整数除法，总是截断小数位。
fromInteger     Num a => Integer -> a                       Prelude     将一个 Integer 值转换为任意数值类型。
fromIntegral    (Integral a, Num b) => a -> b               Prelude     一个更通用的转换函数，将任意 Integral 值转为任意数值类型。
fromRational    Fractional a => Rational -> a               Prelude     将一个有理数转换为分数。可能会有精度损失。
log             Floating a => a -> a                        Prelude     自然对数算法。
logBase         Floating a => a -> a -> a                   Prelude     计算指定底数对数。
maxBound        Bounded a => a                              Prelude     有限长度数值类型的最大值。
minBound        Bounded a => a                              Prelude     有限长度数值类型的最小值。
mod             Integral a => a -> a -> a                   Prelude     整数取模。
pi              Floating a => a                             Prelude     圆周率常量。
quot            Integral a => a -> a -> a                   Prelude     整数除法；商数的分数部分截断为 0 。
recip           Fractional a => a -> a                      Prelude     分数的倒数。
rem             Integral a => a -> a -> a                   Prelude     整数除法的余数。
round           (RealFrac a, Integral b) => a -> b          Prelude     四舍五入到最近的整数。
shift           Bits a => a -> Int -> a                     Bits        输入为正整数，就进行左移。如果为负数，进行右移。
sin             Floating a => a -> a                        Prelude     正弦函数。还提供了 asin 、 sinh 和 asinh ，和 sin 类型一样。
sqrt            Floating a => a -> a                        Prelude     平方根
tan             Floating a => a -> a                        Prelude     正切函数。还提供了 atan 、 tanh 和 atanh ，和 tan 类型一样。
toInteger       Integral a => a -> Integer                  Prelude     将任意 Integral 值转换为 Integer
toRational      Real a => a -> Rational                     Prelude     从实数到有理数的有损转换
truncate        (RealFrac a, Integral b) => a -> b          Prelude     向着零截断
xor             Bits a => a -> a -> a                       Data.Bits   二进制异或操作
============== =========================================== =========== ===================================================================

----

“数值类型及其对应的类型类” 列举在下表 6.3。

----

**表格 6.3 ： 数值类型的类型类实例**

========================= ==== ========= ======== ============ ======== ==== ===== ===========
类型                      Bits  Bounded  Floating  Fractional  Integral  Num  Real  RealFrac
========================= ==== ========= ======== ============ ======== ==== ===== ===========
Double                                      X       X                    X    X     X
Float                                       X       X                    X    X     X
Int                        X    X                               X        X    X
Int16                      X    X                               X        X    X
Int32                      X    X                               X        X    X
Int64                      X    X                               X        X    X
Integer                    X                                    X        X    X
Rational or any Ratio                               X                    X    X     X
Word                       X    X                               X        X    X
Word16                     X    X                               X        X    X
Word32                     X    X                               X        X    X
Word64                     X    X                               X        X    X
========================= ==== ========= ======== ============ ======== ==== ===== ===========

----

表格 6.4 列举了一些数值类型之间进行转换的函数，以下表格是一个汇总：

----

**表格 6.4 ： 数值类型之间的转换**

+--------------+---------------------------------------------------------------------------------+
|源类型        | 目标类型                                                                        |
|              +---------------------------+--------------+---------------+----------------------+
|              | Double, Float             | Int, Word    |  Integer      |  Rational            |
+--------------+---------------------------+--------------+---------------+----------------------+
|Double, Float | fromRational . toRational | truncate *   |  truncate *   |  toRational          |
|Int, Word     | fromIntegral              | fromIntegral |  fromIntegral |  fromIntegral        |
|Integer       | fromIntegral              | fromIntegral |  N/A          |  fromIntegral        |
|Rational      | fromRational              | truncate *   |  truncate *   |  N/A                 |
+--------------+---------------------------+--------------+---------------+----------------------+

----

.. dirty fix ||

6.4 表中 \* 代表除了 ``truncate`` (向着零截断) 之外，还可以使用 ``round`` (最近整数)、 ``ceiling`` (上取整)或者 ``floor`` (下取整)的类型。

第十三章会说明，怎样用自定义数据类型来扩展数值类型。


相等性，有序和对比
^^^^^^^^^^^^^^^^^^^^^^

我们已经讨论过了算术符号比如 ``(+)`` 能用到不同数字的所有类型。
但是Haskell中还存在着某些甚至更加广泛使用的操作符。
最显然地，当然，就是相等性测试: ``(==)`` 和 ``(/=)`` ，这两操作符们都定义于 ``Eq`` 类(class)中。

存在着其他的比较操作符， 如 ``>=`` 和 ``<=`` ，其则由 ``Ord`` 类型类定义。
他们(``Ord``)是放在于单独类中是因为存在着某些类型，比如 ``Handle`` ，使在这些地方相等性测试有意义(make sense)，而表达特定的序(ording)一点意义都没有。

所有 ``Ord`` 实例都可以使用 ``Data.List.sort`` 来排序。

几乎所有 Haskell 内置类型都是 ``Eq`` 类型类的实例，而 ``Ord`` 类的实例类型也几乎一样多。

.. tip::

    ``Ord`` 产生的排列顺序在某些时候是非常随意的，
    比如对于 ``Maybe`` 而言， ``Nothing`` 就排在 ``Just x`` 之前，
    这些都是随意决定的，
    并没有什么特殊的意义。

自动派生
-------------

对于许多简单的数据类型， Haskell 编译器可以自动将类型派生（derivation）为 ``Read`` 、 ``Show`` 、 ``Bounded`` 、 ``Enum`` 、 ``Eq`` 和 ``Ord`` 的实例(instance)。
这节省了我们大量的精力用于手动写代码进行比较或者显示他们的类型。

以下代码将 ``Color`` 类型派生为 ``Read`` 、 ``Show`` 、 ``Eq`` 和 ``Ord`` 的实例：

::

    -- file: ch06/colorderived.hs
    data Color = Red | Green | Blue
        deriving (Read, Show, Eq, Ord)

让我们看看这些派生实例们是怎么工作的：

::

    *Main> show Red
    "Red"

    *Main> (read "Red")::Color
    Red

    *Main> (read "[Red, Red, Blue]")::[Color]
    [Red,Red,Blue]

    *Main> Red == Red
    True

    *Main> Data.List.sort [Blue, Green, Blue, Red]
    [Red,Green,Blue,Blue]

    *Main> Red < Blue
    True

.. note:: 什么类型(types)能被自动派生?

   Haskell标准要求编译器能自动派生这些指定类型类的实例。

注意 ``Color`` 类型的排序位置由定义类型时值构造器的排序决定，即对应上面例子就是 ``Red | Green | Blue`` 的顺序。

自动派生并不总是可用的。
比如说，如果定义类型 ``data MyType = MyType (Int -> Bool)`` ，那么编译器就没办法派生 ``MyType`` 为 ``Show`` 的实例，因为它不知道该怎么渲染(render)一个函数。
在上面这种情况下，我们会得到一个编译错误。

当我们自动派生某个类型类的一个实例时，在我们利用 ``data`` 关键词声明参考这个实例的类型时，也必须是给定类型类的实例（手动或自动地）。

举个例子，以下代码不能使用自动派生：

::

    -- file: ch06/cant_ad.hs
    data Book = Book

    data BookInfo = BookInfo Book
                    deriving (Show)

ghci 会给出提示，说明 ``Book`` 类型也必须是 ``Show`` 的实例， ``BookInfo`` 才能对 ``Show`` 进行自动派生(``driving``)：

::

    Prelude> :load cant_ad.hs
    [1 of 1] Compiling Main             ( cant_ad.hs, interpreted )

    ad.hs:4:27:
        No instance for (Show Book)
              arising from the 'deriving' clause of a data type declaration
        Possible fix:
            add an instance declaration for (Show Book)
            or use a standalone 'deriving instance' declaration,
            so you can specify the instance context yourself
        When deriving the instance for (Show BookInfo)
    Failed, modules loaded: none.

相反，以下代码可以使用自动派生，因为它对 ``Book`` 类型也使用了自动派生，使得 ``Book`` 类型变成了 ``Show`` 的实例：

::

    -- file: ch06/ad.hs
    data Book = Book
                deriving (Show)

    data BookInfo = BookInfo Book
                    deriving (Show)

使用 ``:info`` 命令在 ghci 中确认两种类型都是 ``Show`` 的实例：

::

    Prelude> :load ad.hs
    [1 of 1] Compiling Main             ( ad.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :info Book
    data Book = Book    -- Defined at ad.hs:1:6
    instance Show Book -- Defined at ad.hs:2:23

    *Main> :info BookInfo
    data BookInfo = BookInfo Book   -- Defined at ad.hs:4:6
    instance Show BookInfo -- Defined at ad.hs:5:27

类型类实战：让 JSON 更好用
------------------------------

我们在 :ref:`representing-json-data-in-haskell` 一节介绍的 ``JValue`` 用起来还不够简便。
这里是一段由的经过截断(truncate)和整齐化(tidy)之后的实际 JSON 数据，由一个知名搜索引擎生成。

.. code-block:: json

    {
        "query": "awkward squad haskell",
        "estimatedCount": 3920,
        "moreResults": true,
        "results":
        [{
            "title": "Simon Peyton Jones: papers",
            "snippet": "Tackling the awkward squad: monadic input/output ...",
            "url": "http://research.microsoft.com/~simonpj/papers/marktoberdorf/",
        },
        {
            "title": "Haskell for C Programmers | Lambda the Ultimate",
            "snippet": "... the best job of all the tutorials I've read ...",
            "url": "http://lambda-the-ultimate.org/node/724",
        }]
    }

这是进一步缩减片段的数据，并用 Haskell 表示：

::

    -- file: ch06/SimpleResult.hs
    import SimpleJSON

    result :: JValue
    result = JObject [
        ("query", JString "awkward squad haskell"),
        ("estimatedCount", JNumber 3920),
        ("moreResults", JBool True),
        ("results", JArray [
            JObject [
            ("title", JString "Simon Peyton Jones: papers"),
            ("snippet", JString "Tackling the awkward ..."),
            ("url", JString "http://.../marktoberdorf/")
            ]])
        ]

由于 Haskell 不原生支持包含不同类型值的列表，我们不能直接表示包含不同类型值的 JSON 对象。
我们需要把每个值都用 JValue 构造器包装起来。
但这样我们的灵活性就受到了限制：如果我们想把数字 ``3920`` 转换成字符串 ``"3,920"`` ，我们就必须改变构造器，即我们使用它(JValue构造器)从 ``JNumber`` 构造器到 ``JString`` 构造器包装(wrap)数据。

Haskell 的类型类对这个问题提供了一个诱人的解决方案：

::

    -- file: ch06/JSONClass.hs
    type JSONError = String

    class JSON a where
        toJValue :: a -> JValue
        fromJValue :: JValue -> Either JSONError a

    instance JSON JValue where
        toJValue = id
        fromJValue = Right

现在，我们无需再用 ``JNumber`` 等构造器去包装值了，直接使用 ``toJValue`` 函数即可。
如果我们更改值的类型，编译器会自动选择合适的 ``toJValue`` 实现以使用他。

我们也提供了 ``fromJValue`` 函数.它试图把 ``JValue`` 值转换成我们希望的类型。

.. _more-helpful-errors:

让错误信息更有用
^^^^^^^^^^^^^^^^^^^

``fromJValue`` 函数的返回类型为 ``Either`` 。
跟 ``Maybe`` 一样，这个类型是为我们预定义的。
我们经常用它来表示可能会失败的计算。

虽然 ``Maybe`` 也用作这个目的，但它在错误发生时没有给我们足够有用的信息：我们只得到一个 ``Nothing`` 。
虽然 ``Either`` 类型的结构相同，但是不同于 ``Nothing`` (相对于 ``Maybe``)， "坏事情发生"构造器命名为 ``Left`` ，并且其还接受一个参数。

::

    -- file: ch06/DataEither.hs
    data Maybe a = Nothing
                 | Just a
                   deriving (Eq, Ord, Read, Show)

    data Either a b = Left a
                    | Right b
                      deriving (Eq, Ord, Read, Show)

我们经常使用 ``String`` 作为 ``a`` 参数值的类型，所以在出错时我们能提供有用的描述。
为了说明在实际中怎么使用 ``Either`` 类型，我们来看一个简单的类型类的实例。

::

    -- file: ch06/JSONClass.hs
    instance JSON Bool where
        toJValue = JBool
        fromJValue (JBool b) = Right b
        fromJValue _ = Left "not a JSON boolean"

[译注：读者若想在 **ghci** 中尝试 ``fromJValue`` ，需要为其提供类型标注，例如 ``(fromJValue(toJValue True))::Either JSONError Bool`` 。]

.. _making-an-instance-with-a-type-synonym:

使用类型别名创建实例
^^^^^^^^^^^^^^^^^^^^^^^^

Haskell 98标准不允许我们用下面的形式声明实例，尽管它看起来没什么问题：

::

    -- file: ch06/JSONClass.hs
    instance JSON String where
        toJValue               = JString

        fromJValue (JString s) = Right s
        fromJValue _           = Left "not a JSON string"

回忆一下， ``String`` 是 ``[Char]`` 的别名。
因此它的类型是 ``[a]`` ，并用 ``Char`` 替换了类型变量 ``a`` 。
根据 Haskell 98的规则，我们在声明实例的时候不允许提供一个类型替代类型变量。
也就是说，我们可以给 ``[a]`` 声明实例，但给 ``[Char]`` 不行。

尽管 GHC 默认遵守 Haskell 98标准，但是我们可以在文件顶部添加特殊格式的注释来解除这个限制。

::

    -- file: ch06/JSONClass.hs
    {-# LANGUAGE TypeSynonymInstances #-}

这条注释是一条编译器指令，称为\ *编译选项（pragma）*\，它告诉编译器允许这项语言扩展。
上面的代码因为 ``TypeSynonymInstances`` ("同义类型的实例")这项语言扩展而合法。
我们在本章（本书）还会碰到更多的语言扩展。

[译注：作者举的这个例子实际上牵涉到了两个问题。
第一，Haskell 98不允许类型别名，这个问题可以通过上述方法解决。
第二，Haskell 98不允许 ``[Char]`` 这种形式的类型，这个问题需要通过增加另外一条编译选项 ``{-# LANGUAGE FlexibleInstances #-}`` 来解决。]

[sancao2译注，若没有 ``{-# LANGUAGE FlexibleInstances #-}`` 这条编译选项，就会产生下面的结果。
其实编译器的 ``fix`` 提示给大家了。

::

   Prelude> :l JSONClass.hs  ../ch05/SimpleJSON.hs
   [1 of 2] Compiling SimpleJSON       ( ../ch05/SimpleJSON.hs, interpreted )
   [2 of 2] Compiling Main             ( JSONClass.hs, interpreted )

   JSONClass.hs:16:10:
      Illegal instance declaration for `JSON String'
         (All instance types must be of the form (T a1 ... an)
         where a1 ... an are *distinct type variables*,
         and each type variable appears at most once in the instance head.
         Use -XFlexibleInstances if you want to disable this.)
      In the instance declaration for `JSON String'
   Failed, modules loaded: SimpleJSON.

]

[Forec译注：在 Haskell 8.0.1 中，即使不添加 ``{-# LANGUAGE TypeSynonymInstances #-}`` 也不会出现问题，但 ``{-# LANGUAGE FlexibleInstances #-}`` 这条编译选项仍然需要。]

.. _living-in-an-open-world:

生活在开放世界
--------------------

Haskell 的有意地设计成允许我们任意创建类型类的实例，每当我们认为合适时。

::

    -- file: ch06/JSONClass.hs
    doubleToJValue :: (Double -> a) -> JValue -> Either JSONError a
    doubleToJValue f (JNumber v) = Right (f v)
    doubleToJValue _ _ = Left "not a JSON number"

    instance JSON Int where
        toJValue = JNumber . realToFrac
        fromJValue = doubleToJValue round

    instance JSON Integer where
        toJValue = JNumber . realToFrac
        fromJValue = doubleToJValue round

    instance JSON Double where
        toJValue = JNumber
        fromJValue = doubleToJValue id

我们可以在任意地方添加新实例，而不仅限于在定义了类型类的模块中。
类型类系统的这个特性被称为\ *开放世界假设*\ （open world assumption）。
如果我们有方法表示“这个类型类只存在这些实例”，那我们将得到一个\ *封闭的*\ 世界。

我们希望把列表(list)转为 JSON 数组(array)。
我们现在还不用关心实现细节，所以让我们暂时使用 ``undefined`` 作为函数内容。

::

    -- file: ch06/BrokenClass.hs
    instance (JSON a) => JSON [a] where
        toJValue = undefined
        fromJValue = undefined

我们也希望能将键/值对列表转为 JSON 对象。

::

    -- file: ch06/BrokenClass.hs
    instance (JSON a) => JSON [(String, a)] where
        toJValue = undefined
        fromJValue = undefined


.. _when-do-overlapping-instances-cause-problems:

什么时候重叠实例（Overlapping instances）会出问题？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

如果我们把这些定义放进文件中并在 **ghci** 里载入，初看起来没什么问题。

::

    *JSONClass> :l BrokenClass.hs
    [1 of 2] Compiling JSONClass        ( JSONClass.hs, interpreted )
    [2 of 2] Compiling BrokenClass      ( BrokenClass.hs, interpreted )
    Ok, modules loaded: JSONClass, BrokenClass

然而，一旦我们使用序对列表实例时，我们就"跑"(不是get，体会一下)进麻烦里面了(run in trouble)。

::

    *BrokenClass> toJValue [("foo","bar")]

    <interactive>:10:1:
        Overlapping instances for JSON [([Char], [Char])]
            arising from a use of ‘toJValue’
        Matching instances:
            instance JSON a => JSON [(String, a)]
                -- Defined at BrokenClass.hs:13:10
            instance JSON a => JSON [a] -- Defined at BrokenClass.hs:8:10
        In the expression: toJValue [("foo", "bar")]
        In an equation for ‘it’: it = toJValue [("foo", "bar")]

[sancao2译注:上面的抱怨说的是匹配了两个实例，编译器不知道选择哪一个。
``Matching instances: instance xxx, instance xxx`` 。]

\ *重叠实例*\ 问题是由 Haskell 的"开放世界假设"的一个后果(a consequence)。
以下这个例子可以把问题展现得更清楚一些。

::

    -- file: ch06/Overlap.hs
    {-# LANGUAGE FlexibleInstances #-}
    class Borked a where
        bork :: a -> String

    instance Borked Int where
        bork = show

    instance Borked (Int, Int) where
        bork (a, b) = bork a ++ ", " ++ bork b

    instance (Borked a, Borked b) => Borked (a, b) where
        bork (a, b) = ">>" ++ bork a ++ " " ++ bork b ++ "<<"

我们有两个 ``Borked`` 类型类实例应用于序对(for pairs)：一个是 ``Int`` 序对，另一个是任意类型的序对，只要这个类型是 ``Borked`` 类型类的实例。

假设我们想把 ``bork`` 应用于 ``Int`` 序对。
为了这样做，编译器必须选择一个实例来用。
因为这些实例都是正确地紧挨着(right next to each other)，所以它似乎可以选择更相关的(specific)的实例。

但是， ``GHC`` 在默认情况下是保守的，且坚持(insist)只有一个可能的GHC 能使用的实例 。
因此如果我们尝试使用 ``bork`` 的话，
那么它将报错。

.. note:: 什么时候重叠实例要紧(matter)？

    就像我们之前提到的，我们可以分散一个类型类的实例横跨于(across)几个模块中。
    GHC 不会抱怨重叠实例的单单存在(mere existence)。
    取而代之地，他会抱怨，只有当我们试图使用受影响的类型类的函数时，只有他被迫要去做决定采用哪个实例时。

.. _relaxing-some-restrictions-on-typeclasses:

放松(relex)类型类的一些限制
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

通常，我们不能写一个类型类实例，(仅)为了一个多态类型（polymorphic type）的特化版本（specialized version）。
``[Char]`` 类型就是多态类型 ``[a]`` (其中的 ``a``)特化成类型 ``Char`` 。
我们就这样被禁止声明 ``[Char]`` 为某个类型类的实例。
这"高度地"(highly)不方便，因为字符串无处不在于实际的代码中。

``TypeSynonymInstances`` ("同义类型的实例")语言扩展取消了这个限制，并允许我们写这样的实例。

GHC 支持另外一个有用的语言扩展， ``OverlappingInstances`` （覆盖实例）。
它解决(原文为address)了在处理重叠实例时候我们碰到的问题。
如果存在多个重叠的实例去从中选择，这个扩展会"采摘"(pick)最相关的（specific）那一个。

[Forec译注：在 Haskell 8.0 后， ``OverlappingInstances`` 已被抛弃，可替代的方法是在实例中加上 ``{-# OVERLAPPABLE #-}`` ，如：

::

    instance {-# OVERLAPPABLE -#} Foo a => Foo [a] where
        foo = concat . intersperse ", " . map foo

]

我们经常使用这个扩展，同 ``TypeSynonymInstances`` 一起。
这里是一个例子。

::

    -- file: ch06/SimpleClass.hs
    {-# LANGUAGE TypeSynonymInstances, OverlappingInstances, FlexibleInstances #-}

    import Data.List

    class Foo a where
        foo :: a -> String

    instance Foo a => Foo [a] where
        foo = concat . intersperse ", " . map foo

    instance Foo Char where
        foo c = [c]

    instance Foo String where
        foo = id

如果我们应用(apply) ``foo`` 于 ``String`` ，编译器会选择 ``String`` 相关的(specific)实现。
虽然我们有一个 ``Foo`` 的实例关于 ``[a]`` 和 ``Char`` ，但关于 ``String`` 的实例更相关，所以 GHC 选择它。

即使 ``OverlappingInstances`` (覆盖实例)扩展出于使能状态(enabled)，GHC仍将拒绝代码，若他找到一个以上等价地相关的（equally specific）实例。

.. note:: 何时去使用 ``OverlappingInstances`` 扩展?

    这是一个重要的点：GHC认为 ``OverlappingInstances`` 会影响一个实例的声明，而不是一个位置，于此（位置）我们使用一个实例。
    换句话说，当我们定义一个实例，其（这个实例）我们希望能（被）允许覆盖（overlap）于其他实例的时候，我们必须使能(enable)该扩展(``OverlappingInstances``)为这个模块，而其（这个模块）包含着定义。
    当他编译这个模块的时候，GHC会记录那个实例为＂能被覆盖（overlap）以其他的模块＂的。
    一旦我们引入(import)这个模块而使用他的实例，我们将不需要使能(enable) ``OverlappingInstances`` 编译选项在引入模块的时候：GHC将已经知道这个实例是被标记为＂对覆盖友好的＂(okay to overlap)，当他被定义的时候。
    这种行为是很有用的，当我们在写一个库(library)的时候:我们能选择去创造可覆盖的(overlappable)实例，但是库的用户不必须使能(enable)任何特殊的语言扩展。


.. _how-does-show-work-for-strings:

show是如何处理String的?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``OverlappingInstances`` (覆盖实例)和 ``TypeSynonymInstances`` ("同义类型的实例")语言扩展是特定于GHC的，而在定义上过去没有出现(present)于“Haskell 98”。
然而，大家熟悉的 ``Show`` 类型类，来自“Haskell 98”，以某种方法区别地"渲染"(render) ``Char`` 列表(list)和 ``Int`` 列表。
它达成这个（"区别地渲染"）通过一个聪明但简单的把戏(trick)。

``Show`` 类型类定义了两个方法：一个 ``show`` 方法，用于渲染单值(one value)和一个 ``showList`` 方法，用于渲染值的列表。
而 ``showList`` 的默认实现，渲染一个列表，以使用中括号们和逗号们的方式。

``Show`` 的实例对于 ``[a]`` 是使用 ``showList`` 实现的。
``Show`` 的实例为 ``[Char]`` 提供一个特殊的 ``showList`` 实现。
其（该实现）使用双引号，并转义"非ASCII可打印"(non-ASCII-printable)的字符们。

[sancao2译注:上面那句 ``[Char]`` 原文没有 ``[]`` ，应该是错了。]

作为结果，如果有人对 ``[Char]`` 应用 ``show`` 函数，那么 ``showList`` 的实现会被选上，并且将会正确地渲染字符串，通过使用括号们。

至少有时，因而，我们就能克制对 ``OverlappingInstances`` (覆盖实例)扩展的需要，带着一点点(时间维度的)横向思维(lateral thinking)。


.. _how-to-give-a-type-a-new-identity:

如何给类型以新身份（new identity）
------------------------------------

包括熟悉的 ``data`` 关键字以外，Haskell 提供我们另外一种方式来创建新类型，即采用 ``newtype`` 关键字。

::

    -- file: ch06/Newtype.hs
    data DataInt = D Int
        deriving (Eq, Ord, Show)

    newtype NewtypeInt = N Int
        deriving (Eq, Ord, Show)

``newtype`` 声明的目的是重命名一个存在着的类型，来给它一个独特的身份(id)。
像我们能看到的，它的用法和采用 ``data`` 关键字进行声明，在表面上很相似。

.. note:: type 和 newtype 关键字

    尽管他们的名字是类似的， ``type`` 和 ``newtype`` 关键字有不同的目的。
    ``type`` 关键字给了我们另一种方式以引用(refer to)某个类型，就像昵称之于一个朋友。
    我们和编译器都知道 ``[Char]`` 和 ``String`` 引用的是同一个类型。

    比较起来(与 ``type``)， ``newtype`` 关键字存在，以隐藏一个类型的本性(nature)。
    考虑一个 ``UniqueID`` 类型。

    ::

        -- file: ch06/Newtype.hs
        newtype UniqueID = UniqueID Int
            deriving (Eq)

    编译器会视 ``UniqueID`` 为 一个不同的类型于 ``Int`` 。
    作为一个 ``UniqueID`` 的用户，我们只知道它有一个"唯一标识符"(Unique ID，英语字面意思)；我们并不知道它被实现为一个 ``Int`` 。

当我们声明一个 ``newtype`` 时，我们必须选择哪个潜在类型的类型类实例，而对其（该实例）我们想要暴露。
在这里，我们决定让 ``NewtypeInt`` 提供 ``Int`` 的 ``Eq`` 、 ``Ord`` 和 ``Show`` 实例。
作为一个结果，我们可以比较和打印 ``NewtypeInt`` 类型的值。

::

    *Main> N 1 < N 2
    True

由于我们没有暴露 ``Int`` 的 ``Num`` 或 ``Integral`` 实例， ``NewtypeInt`` 类型的值并不是数字们。
例如，我们不能加他们。

::

    *Main> N 313 + N 37

    <interactive>:9:7:
        No instance for (Num NewtypeInt) arising from a use of ‘+’
        In the expression: N 313 + N 37
        In an equation for ‘it’: it = N 313 + N 37

跟用 ``data`` 关键字一样，我们可以用 ``newtype`` 的值构造器创建一个新值，或者模式匹配于存在的值。

如果 ``newtype`` 没用自动派生（deriving）来暴露一个类型类的潜在（underlying）类型实现的话，我们是自由的，或者去写一个新实例，或者干脆留那个类型类处于不实现状态。

.. _data-and-newtype:

data 和 newtype 声明之间的区别
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``newtype`` 关键字存在着（exists）为了给现有类型以一个新的身份（id）。
它有更多的限制于其使用上，比起 ``data`` 关键字。
说白了， ``newtype`` 只能有一个值构造器，并且那个构造器须恰有一个字段(field)。

::

    -- file: ch06/NewtypeDiff.hs
    -- 可以：任意数量的构造器和字段（这里的两个Int为两个字段(fields)）
    data TwoFields = TwoFields Int Int

    -- 可以：恰一个字段
    newtype Okay = ExactlyOne Int

    -- 可以：类型变量是没问题的
    newtype Param a b = Param (Either a b)

    -- 可以：记录语法是友好的
    newtype Record = Record {
            getInt :: Int
        }

    -- 不可以：没有字段
    newtype TooFew = TooFew

    -- 不可以：多于一个字段
    newtype TooManyFields = Fields Int Int

    -- 不可以：多于一个构造器
    newtype TooManyCtors = Bad Int
                         | Worse Int

在此之上，还有另一个重要的区别于 ``data`` 和 ``newtype`` 之间。
一个类型，由 ``data`` 关键字创建，有一个簿记保持（book-keeping）的开销在运行时。
例如，追踪（track）某个值是由哪个值构造器创造的。
而另一方面， ``newtype`` 只能有一个构造器，所以不需要这个额外开销。
这使得它在运行时更省时间和空间。

因为 ``newtype`` 的构造器只在编译时使用，运行时甚至不存在，所以对于用 ``newtype`` 定义的类型和那些用 ``data`` 定义的类型来说，类型匹配在 ``undefined`` 上的表现不同。

为了理解这个不同点，让我们首先回顾一下，我们可能期望一个普通类型的什么行为。
我们已经非常熟悉，如果在运行时 ``undefined`` 被求值会导致崩溃。

::

    Prelude> undefined
    *** Exception: Prelude.undefined

这里有一个类型匹配，在其（类型匹配）中我们采用 “``D`` 构造器” 构造一个 ``DataInt`` ，然后放 ``undefined`` 在内部。

::

    *Main> case (D undefined) of D _ -> 1
    1

[sancao2译注:做这个实验要先加载“Newtype.hs"，其中定义了 ``Ｄ`` 。]

由于我们的模式匹配只对构造器而不检查载荷(payload)， ``undefined`` 保持未被求值状态，因而不会导致一个异常被抛出。

在这个例子中，我们没有同时使用 ``D`` 构造器，因而未被保护的 ``undefined`` 会被求值。
当模式匹配发生时，我们抛出异常。

::

    *Main> case undefined of D _ -> 1
    *** Exception: Prelude.undefined

当我们使用 ``N`` 构造器以得到 ``NewtypeInt`` 值时，我们看到相同的行为：没有异常，就像使用 ``DataInt`` 类型的 ``D`` 构造器。

::

    *Main> case (N undefined) of N _ -> 1
    1

决定性的（crucial）差异发生了，当我们从表达式中去掉 ``N`` ，并匹配于一个未保护的 ``undefined`` 时。

::

    *Main> case undefined of N _ -> 1
    1

我们没有崩溃！由于不存在构造器于运行时，对 ``N _`` 的匹配实际上等效于对空白通配符 ``_`` 的匹配：由于这个通配符（ ``_`` ）总可以匹配，所以表达式不需要被求值。

.. note::  关于 ``newtype`` 构造器的另一种看法

    虽然，我们使用值（value）构造器，以得到一个 ``newtype`` ，其方式等同于一个类型被定义而其采用 ``data`` 关键词。
    两者所做的是强迫一个值（value）处于（between）他的“正常”（normal）类型和他的 ``newtype`` 类型之间。

    换句话说，当我们应用（apply） ``N`` 于一个表达式，我们强迫一个表达式从 ``Int`` 类型到 ``NewtypeInt`` 类型，对我们（we）和编译器（compiler）而言，但是，完全地（absolutely），没有事情发生于运行时（runtime）。

    类似地，当我们匹配 ``N`` 构造器于一个模式中，我们强制一个表达式从 ``NewtypeInt`` 到 ``Int`` ，但是再次地不存在开销于运行时。

.. _summary-the-three-ways-of-naming-types:

总结：三种命名类型的方式
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

这是一份简要重述（recap），关于 Haskell 的三种方式用来为类型提出（introduce）新名。

- ``data`` 关键字提出（introduce）一个真正的代数（albegraic）数据类型。

- ``type`` 关键字给我们一个别名（synonym）去用，为一个存在着的（existing）类型。
  我们可以交换地（interchangeably）使用这个类型和他的别名,

- ``newtype`` 关键字给予一个存在着的类型以一个独特的身份（distinct identity）。
  这个原类型和这个新类型是不可交换的（interchangeable）。


.. _json_typeclasses_without_overlapping_instances:

JSON类型类,不带有重叠实例
--------------------------------

启用GHC的重叠实例支持是一个让我们的JSON库工作的既有效又快速的方法。
在更复杂的场景中，我们有时被迫面对这样一种情况：某个类型类有多个相关程度相同（equally good）实例。
在这种情况下，重叠实例们将不会帮助我，而我们将需要代之以几处 ``newtype`` 声明。
为了弄明白这涉及到了什么，让我们重构（rework）我们的JSON类型类实例们以使用 ``newtype`` 代替重叠实例。

我们的第一个任务，是帮助编译器区分 ``[a]`` 和 ``[(String,[a])]`` 。
前者（ ``[a]`` ）我们用来表示JSON数组们（arrays），而后者（ ``[(String, [a])]`` ）用来表示JSON对象们（objects）。
他们是这些类型们，其给我们制造了麻烦于我们学会 ``OverlappingInstances`` （覆盖实例）之前。
我们包装了（wrap up）列表（list）类型，以至于编译器不会视其为一个列表。

::

   -- file: ch06/JSONClass.hs
   newtype JAry a = JAry {
         fromJAry :: [a]
         } deriving (Eq, Ord, Show)

当我们从自己的模块导出这个类型时，我们会导出该类型完整的细节。
我们的模块头部将看起来像这样：

::

   -- file: ch06/JSONClassExport.hs
   module JSONClass
       (
         JAry(..)
       ) where

紧跟着 ``Jary`` 的” ``(..)`` “，意思是“导出这个类型的所有细节”。

.. note:: 一点稍微的偏差，相比于正常使用

    通常地，当我们导出一个 ``newtype`` 的时候，我们 *不会* 导出这个类型的数据构造器，为了保持其细节的抽象（abstract）。
    取而代之，我们会定义一个函数为我们应用（apply）该数据构造器。

    ::

       -- file: ch06/JSONClass.hs
       jary :: [a] -> JAry a
       jary = JAry

    于是，我们会导出类型构造器、解构函数和我们的构造函数，除了数据构造器。

    ::

       -- file: ch06/JSONClassExport.hs
       module JSONClass
           (
             JAry(fromJAry)
           , jary
           ) where

    当我们没有导出一个类型的数据构造器，我们库的顾客们就只能使用我们提供的函数们去构造和解构该类型的值。
    这个特性为我们，这些库作者们，提供了自由去改变类型的内部表示形式（represention），如果我们需要去（这么做）。

    如果我们导出数据构造器，顾客们很可能开始依赖于它，比方说使用它（数据构造器）在一些模式中。
    如果哪天我们希望去修改这个类型的内部构造，我们将冒险打破任意代码，而其（这些代码）使用着该数据构造器。

    在我们这里的情况下，我们得不到什么额外的好处，通过让数组的包装器保持抽象，所以我们就干脆地导出该类型的整个定义。

我们提供另一个包装类型，而其隐藏了一个JSON对象的我们的表示形式（represention）。

::

   -- file: ch06/JSONClass.hs
   newtype JObj a = JObj {
         fromJObj :: [(String, a)]
       } deriving (Eq, Ord, Show)

带着这些定义好的类型，我们制造一些小改动到我们的 ``JValue`` 类型的定义。

::

   -- file: ch06/JSONClass.hs
   data JValue = JString String
               | JNumber Double
               | JBool Bool
               | JNull
               | JObject (JObj JValue)   -- was [(String, JValue)]
               | JArray (JAry JValue)    -- was [JValue]
                 deriving (Eq, Ord, Show)

这个改动不会影响到 ``JSON`` 类型类的实例们，而那些我们已经写完。
但是我们还要为我们新的 ``JAry`` 和 ``JObj`` 类型编写实例。

::

   -- file: ch06/JSONClass.hs
   jaryFromJValue :: (JSON a) => JValue -> Either JSONError (JAry a)

   jaryToJValue :: (JSON a) => JAry a -> JValue

   instance (JSON a) => JSON (JAry a) where
       toJValue = jaryToJValue
       fromJValue = jaryFromJValue

让我们缓慢地走过各个步骤，而这些步骤会转换一个 ``JAry a`` 到一个 ``JValue`` 。
给定一个列表，其中内部每一个元素都是一个 ``JSON`` 实例，转换它（前面的列表）到一个 ``JValue`` s 组成的列表是简单的。

::

   -- file: ch06/JSONClass.hs
   listToJValues :: (JSON a) => [a] -> [JValue]
   listToJValues = map toJValue

取得这个值并包装他来得到一个 ``JAry JValue`` 的过程，实际上就是对其应用 ``newtype`` 的类型构造器。

::

   -- file: ch06/JSONClass.hs
   jvaluesToJAry :: [JValue] -> JAry JValue
   jvaluesToJAry = JAry

(记住，这种做法没有任何性能代价。我们只是告诉编译器隐藏这个事实：我们正在使用一个列表。)
为了转化这个值成为一个 ``JValue`` ，我们应用另一个类型构造器。

::
   -- file: ch06/JSONClass.hs
   jaryOfJValuesToJValue :: JAry JValue -> JValue
   jaryOfJValuesToJValue = JArray

组装这些代码片段，通过使用函数组合(function composition)，而我们得到一个简洁的单行（代码），用于转换得到一个 ``JValue`` 。

::

   -- file: ch06/JSONClass.hs
   jaryToJValue = JArray . JAry . map toJValue . fromJAry

我们有更多的工作去做来实现从 ``JValue`` 到 ``JAry a`` 的转换，但是我们把它“碎裂”（break）成一些可重用的部分。
基本函数一目了然（straightforward）。

::

   -- file: ch06/JSONClass.hs
   jaryFromJValue (JArray (JAry a)) =
       whenRight JAry (mapEithers fromJValue a)
   jaryFromJValue _ = Left "not a JSON array"

``whenRight`` 函数会检查传给它的参数：如果第二个参数是用 ``Right`` 构造器创建的，以它为参数调用第一个参数指定的函数；如果第二个参数是 ``Left`` 构造器创建的，则将它保持原状返回，其它什么也不做。

::

   -- file: ch06/JSONClass.hs
   whenRight :: (b -> c) -> Either a b -> Either a c
   whenRight _ (Left err) = Left err
   whenRight f (Right a) = Right (f a)

``mapEithers`` 函数要更复杂一些。
它的行为就像 ``map`` 函数，但如果它遇到一个 ``Left`` 值，会直接返回该值，而不会继续积累 ``Right`` 值构成的列表。

::

   -- file: ch06/JSONClass.hs
   mapEithers :: (a -> Either b c) -> [a] -> Either b [c]
   mapEithers f (x:xs) = case mapEithers f xs of
                           Left err -> Left err
                           Right ys -> case f x of
                                         Left err -> Left err
                                         Right y -> Right (y:ys)
   mapEithers _ _ = Right []

由于隐藏在 ``JObj`` 类型中的列表元素有更细碎的结构，相应的，在它和 ``JValue`` 类型之间互相转换的代码就会有点复杂。
万幸的是，我们可以重用刚刚定义过的函数。

::

   -- file: ch06/JSONClass.hs
   import Control.Arrow (second)

   instance (JSON a) => JSON (JObj a) where
       toJValue = JObject . JObj . map (second toJValue) . fromJObj

       fromJValue (JObject (JObj o)) = whenRight JObj (mapEithers unwrap o)
         where unwrap (k,v) = whenRight ((,) k) (fromJValue v)
       fromJValue _ = Left "not a JSON object"

练习题
^^^^^^^^^^

1. 在 **ghci** 中加载 ``Control.Arrow`` 模块，弄清 ``second`` 函数的功能。

2. ``(,)`` 是什么类型？在 **ghci** 中调用它时，它的行为是什么？ ``(,,)`` 呢？



.. _the_dreaded_monomorphism_restriction:

可怕的单一同态限定（monomorphism restriction）
--------------------------------------------------

Haskell 98 有一个微妙的特性可能会在某些意想不到的情况下“咬”到我们。
下面这个简单的函数展示了这个问题。

::

    -- file: ch06/Monomorphism.hs
    myShow = show

如果我们试图把它载入 **ghci** ，会产生一个奇怪的错误：

::

    Prelude> :l Monomorphism.hs

    [1 of 1] Compiling Main             ( Monomorphism.hs, interpreted )

    Monomorphism.hs:2:10:
        No instance for (Show a0) arising from a use of ‘show’
        The type variable ‘a0’ is ambiguous
        Relevant bindings include
            myShow :: a0 -> String (bound at Monomorphism.hs:2:1)
        Note: there are several potential instances:
            instance Show a => Show (Maybe a) -- Defined in ‘GHC.Show’
            instance Show Ordering -- Defined in ‘GHC.Show’
            instance Show Integer -- Defined in ‘GHC.Show’
            ...plus 22 others
        In the expression: show
        In an equation for ‘myShow’: myShow = show
        Failed, modules loaded: none.

错误信息中提到的 “monomorphism restriction” 是 Haskell 98 的一部分。
\ *单一同态*\ 是多态（polymorphism）的反义词：它表明某个表达式只有一种类型。
Haskell 有时会强制使某些声明不像我们预想的那么多态。

我们在这里提单一同态是因为尽管它和类型类没有直接关系，但类型类给它提供了产生的环境。

.. tip::

    在实际代码中可能很久都不会碰到单一同态，因此我们觉得你没必要记住这部分的细节，
    只要在心里知道有这么回事就可以了，除非 GHC 真的报告了跟上面类似的错误。
    如果真的发生了，记得在这儿曾读过这个错误，然后回过头来看就行了。

我们不会试图去解释单一同态限制。
Haskell 社区一致同意它并不经常出现；它解释起来很棘手（tricky)；
它几乎没什么实际用处；它唯一的作用就是坑人。
举个例子来说明它为什么棘手：尽管上面的例子违反了这个限制，
下面的两个编译起来却毫无问题。

::

    -- file: ch06/Monomorphism.hs
    myShow2 value = show value

    myShow3 :: (Show a) => a -> String
    myShow3 = show

上面的定义表明，如果 GHC 报告单一同态限制错误，我们有三个简单的方法来处理。

- 显式声明函数参数，而不是隐性。

- 显式定义类型签名，而不是依靠编译器去推导。

- 不改代码，编译模块的时候用上 ``NoMonomorphismRestriction`` 语言扩展。
  它取消了单一同态限制。

没人喜欢单一同态限制，因此几乎可以肯定的是下一个版本的 Haskell 会去掉它。
但这并不是说加上 ``NoMonomorphismRestriction`` 就可以一劳永逸：有些编译器（包括一些老版本的 GHC）识别不了这个扩展，但用另外两种方法就可以解决问题。
如果这种可移植性对你不是问题，那么请务必打开这个扩展。

.. _conclusion:

结论
---------

在这章，你学到了类型类有什么用以及怎么用它们。
我们讨论了如何定义自己的类型类，然后又讨论了一些 Haskell 库里定义的类型类。
最后，我们展示了怎么让 Haskell 编译器给你的类型自动派生出某些类型类实例。
