第八章：高效文件处理、正则表达式、文件名匹配
===========

高效文件处理
--------------

下面是个简单的基准测试，读取一个由数字构成的文本文件，并打印它们的和。

::

    -- file: ch08/SumFile.hs
    main = do
        contents <- getContents
        print (sumFile contents)
      where sumFile = sum . map read . words



尽管读写文件时，默认使用 ``String`` 类型，但它并不高效，所以这样简单的程序效率会很糟糕。

一个 ``String`` 代表一个元素类型为 ``Char`` 的列表；列表的每个元素被单独分配内存，并有一定的写入开销。对那些要读取文本及二进制数据的程序来说，这些因素会影响内存消耗和执行效率。在这个简单的测试中，即使是 ``Python`` 那样的解释型语言的表现也会大大好于使用 ``String`` 的 ``Haskell`` 代码。

``bytestring`` 库是 ``String`` 类型的一个快速、经济的替代品。在保持 ``Haskell`` 代码的表现力和简洁的同时，使用 ``bytestring`` 编写的代码在内存占用和执行效率经常可以达到或超过 ``C`` 代码。

这个库提供两个模块。每个都定义了与 ``String`` 类型上函数对应的替代物。

    * ``Data.ByteString`` 定义了一个名为 ``ByteString`` 的严格类型，其将一个字符串或二进制数据或文本用一个数组表示。

    * ``Data.ByteString.Lazy`` 模块定义了一个惰性类型，同样命名为 ``ByteString`` 。其将字符串数据表示为一个由 ``块`` 组成的列表，每个块是大小为 64KB 的数组。

这两种 ``ByteString`` 适用于不同的场景。对于大体积的文件流(几百 MB 至几 TB)，最好使用惰性的 ``ByteString`` 。其块的大小被调整得对现代 CPU 的 L1 缓存特别友好，并且在流中已经被处理过块可以被垃圾收集器快速丢弃。

对于不在意内存占用而且需要随机访问的数据，最好使用严格的 ``ByteString`` 类型。

二进制 I/O 和有限载入
^^^^^^^^^^^^^^^^^^^^

让我们来开发一个小函数以说明 ``ByteString`` API 的一些用法。我们将检测一个文件是否是 ELF object 文件：这种文件类型几乎被所有现代类 Unix 系统作为可执行文件。

这个简单的问题可以通过查看文件头部的四个字节解决，看他们是否匹配某个特定的字节序列。表示某种文件类型的字节序列通常被称为 ``魔法数`` 。

::

   -- file: ch08/ElfMagic.hs
   import qualified Data.ByteString.Lazy as L
   
   hasElfMagic :: L.ByteString -> Bool
   hasElfMagic content = L.take 4 content == elfMagic
       where elfMagic = L.pack [0x7f, 0x45, 0x4c, 0x46]

我们使用 Haskell 的 ``有限载入`` 语法载入 ``ByteString`` 模块， 像上面 ``import qualified`` 那句那样。这样可以把一个模块关联到另一个我们选定的名字。

例如，使用到惰性 ``ByteString`` 模块的 ``take`` 函数时，要写成 ``L.take`` ，因为我们将这个模块引入到了 ``L`` 这个名字下。若没有明确指明使用哪个版本的函数，如此处的 ``take`` ，编译器会报错。

我们将一直使用有限载入语法使用 ``ByteString`` 模块，因为其中提供的很多函数与 ``Prelude`` 模块中的函数重名。

.. tip::
   有限载入使得可以方便地切换两种 ``ByteString`` 类型。只需要在代码的头部改变 ``import`` 声明；剩余的代码可能无需任何修改。你可以方便地比较两种类型，以观察哪种类型更符合你程序的需要。

无论是否使用有限载入，始终可以使用模块的全名来识别某些混淆。例如， ``Data.ByteString.Lazy.length`` 和 ``L.length`` 表示相同的函数， ``Prelude.sum`` 和 ``sum`` 也是如此。

``ByteString`` 模块为二进制 I/O 而设计。Haskell 中表达字节的类型是 ``Word8`` ；如果需要按名字引用它，需要将其从 ``Data.Word`` 模块载入。

``L.pack`` 函数接受一个由 ``Word8`` 组成的列表，并将其装入一个惰性 ``ByteString`` （ ``L.unpack`` 函数的作用恰好相反。）。 ``hasElfMagic`` 函数简单地将一个 ``ByteString`` 的前四字节与一个魔法数相比较。

我们使用了典型的 Haskell 风格编写 ``hasElfMagic`` 函数，其并不执行 I/O。这里是如何在真正的文件上使用它。

::

   -- file: ch08/ElfMagic.hs
   isElfFile :: FilePath -> IO Bool
   isElfFile path = do
     content <- L.readFile path
     return (hasElfMagic content)

``L.readFile`` 函数是 ``readFile`` 的惰性 ``ByteString`` 等价物。它是惰性执行的，将文件读取为数据是需求。它也很高效，立即读取 64KB 大小的块。对我们的任务而言，惰性 ``ByteString`` 是一个好选择，我们可以安全的将这个函数应用在任意大小的文件上。

文本 I/O
^^^^^^^^^^^^^^^^^^^^

方便起见， ``bytestring`` 库提供两个具有有限文本 I/O 功能的模块， ``Data.ByteString.Char8`` 和 ``Data.ByteSring.Lazy.Char8`` 。它们将每个字符串的元素暴露为 ``Char`` 而非 ``Word8`` 。

.. warning::

   这些模块中的函数适用于单字节大小的 ``Char`` 值，所以他们仅适用于 ``ASCII`` 及某些欧洲字符集。大于 255 的值将被截断。

这两个面向字符的 ``bytestring`` 模块提供了用于文本处理的函数。以下文件包含了一家知名互联网公司在 2008 年中期每个月的股价。

如何在这一系列记录中找到最高收盘价呢？收盘价位于以逗号分隔的第四列。以下函数从单行数据中获取收盘价。

::

   -- file: ch08/HighestClose.hs
   import qualified Data.ByteString.Lazy.Char8 as L

   closing = readPrice . (!!4) . L.split ','

这个函数使用 ``point-free`` 风格编写，我们要从右向左阅读。 ``L.split`` 函数将一个惰性 ``ByteString`` 按某个分隔符切分为一个由 ``ByteString`` 组成的列表。 ``(!!)`` 操作符检索列表中的第 k 个元素。 ``readPrice``  函数将一个表示小数的字符串转换为一个数。

::

   - file: ch08/HighestClose.hs
   readPrice :: L.ByteString -> Maybe Int
   readPrice str =
       case L.readInt str of
         Nothing             -> Nothing
         Just (dollars,rest) ->
           case L.readInt (L.tail rest) of
             Nothing           -> Nothing
             Just (cents,more) ->
               Just (dollars * 100 + cents)

我们使用 ``L.readInt`` 函数来解析一个整数。当发现数字时，它会将一个整数和字符串的剩余部分一起返回。 ``L.readInt`` 在解析失败时返回 ``Nothing`` ，这导致我们的函数稍有些复杂。

查找最高收盘价的函数很容易编写。

::

   -- file: ch08/HighestClose.hs
   highestClose = maximum . (Nothing:) . map closing . L.lines
   
   highestCloseFrom path = do
       contents <- L.readFile path
       print (highestClose contents)

不能对空列表使用 ``maximum`` 函数，所以我们耍了点小把戏。

::

   ghci> maximum [3,6,2,9]
   9
   ghci> maximum []
   *** Exception: Prelude.maximum: empty list

我们想在没有股票数据时也不抛出异常，所以用 ``(Nothing:)`` 这个表达式来确保输入到 ``maximum`` 函数的由 ``Maybe Int`` 值构成的列表总是非空。

::

   ghci> maximum [Nothing, Just 1]
   Just 1
   ghci> maximum [Nothing]
   Nothing

我们的函数工作正常吗？

::

   ghci> :load HighestClose
   [1 of 1] Compiling Main             ( HighestClose.hs, interpreted )
   Ok, modules loaded: Main.
   ghci> highestCloseFrom "prices.csv"
   Loading package array-0.1.0.0 ... linking ... done.
   Loading package bytestring-0.9.0.1 ... linking ... done.
   Just 2741

因为我们把逻辑和 I/O 分离开了，所以即使不创建一个空文件也可以测试无数据的情况。

::

   ghci> highestClose L.empty
   Nothing


匹配文件名
--------------

很多面向操作系统的编程语言提供了检测某个文件名是否匹配给定模式的库函数，或者返回一个匹配给定模式的文件列表。在其他语言中，这个函数通常叫做 ``fmatch`` 。尽管 Haskell 标准库提供了很多有用的系统编程设施，但是并没有提供这类用于匹配文件名的函数。所以我们可以自己开发一个。

我们需要处理的模式种类通常称为 glob 模式（我们将使用这个术语），通配符模式，或称 shell 风格模式。它们仅是一些简单规则。你可能已经了解了，但是这里将做一个简要的回顾。

.. note::

    * 对某个模式的匹配从字符串头部开始，在字符串尾部结束。
  
    * 多数文本字符匹配自身。例如，文本 ``foo`` 作为模式匹配其自身 ``foo`` ，且在一个输入字符串中仅匹配 ``foo`` 。
  
    *  ``*`` (星号) 意味着 “匹配所有”; 其将匹配所有文本，包括空字符串。 例如, 模式 ``foo*`` 将匹配任意以 ``foo`` 开头的字符串，比如 ``foo`` 自身， ``foobar`` ， 或 ``foo.c`` 。 模式 ``quux*.c`` 将匹配任何以 ``quux`` 开头且以 ``.c`` 结束的字符串，如 ``quuxbaz.c`` 。
 
    * ``?`` (问号) 匹配任意单个字符。模式 ``pic??.jpg`` 将匹配类似 ``picaa.jpg`` 或 ``pic01.jpg`` 的文件名。
 
    * ``[`` (左方括号) 将开始定义一个字符类，以 ] 结束。其意思是 “匹配在这个字符类中的任意字符”。 ``[!`` 开启一个否定的字符类，其意为 “匹配不在这个字符类中的任意字符”。
 
    用 ``-`` (破折号) 连接的两个字符，是一种表示范围的速记方法，表示：“匹配这个围内的任意字符”。
  
    字符类有一个附加的条件；其不可为空。在 ``[`` 或 ``[!`` 后的字符是这个字符类的一部分，所以我们可以编写包含 ``]`` 的字符类，如 ``[]aeiou]`` 。模式 ``pic[0-9].[pP][nN][gG]`` 将匹配由字符串 ``pic`` 开始，跟随单个数字，最后是字符串 ``.png`` 的任意大小写形式。

尽管 Haskell 的标准库没有提供匹配 glob 模式的方法，但它提供了一个良好的正则表达式库。Glob 模式仅是一个从正则表达式中切分出来的略有不同的子集。很容易将 glob 模式转换为正则表达式，但在此之前，我们首先要了解怎样在 Haskell 中使用正则表达式。



Haskell 中的正则表达式
--------------
在这一节，我们将假设读者已经熟悉 Python、Perl 或 Java 等其他语言中的正则表达式。

为了简洁，此后我们将 “regular expression” 简写为 regexp。

我们将以与其他语言对比的方式介绍 Haskell 如何处理 regexp，而非从头讲解何为 regexp。Haskell 的正则表达式库比其他语言具备更加强大的表现力，所以我们有很多可以聊的。

在我们对 regexp 库的探索开始时，只需使用 ``Text.Regex.Posix`` 工作。一般通过在 ``ghci`` 进行交互是探索一个模块最方便的办法。


::

   ghci> :module +Text.Regex.Posix

可能正则表达式匹配函数是我们平时需要使用的唯一的函数，其以中缀预算符 ``(=~)`` (``从 Perl 中借鉴``) 表示。要克服的第一个障碍是 Haskell 的 regexp 库重度使用了多态。其结果就是， ``(=~)`` 的类型签名非常难懂，所以我们在此对其不做解释。

``=~`` 操作符的参数和返回值都使用了类型类。第一个参数 (``=~`` 左侧) 是要被匹配的文本；第二个参数 (``=~`` 右侧) 是准备匹配的正则表达式。对每个参数我们都可以使用 ``String`` 或者 ``ByteString`` 。

结果的多种类型
^^^^^^^^^^^^^^

``=~`` 操作符的返回类型是多态的，所以 Haskell 编译器需要一通过一些途径知道我们想获得哪种类型的结果。实际编码中，可以通过我们如何使用匹配结果推导出它的类型。但是当我们通过 ``ghci`` 进行探索时，缺少类型推导的线索。如果不指明匹配结果的类型，ghci 将因其无法获得足够信息对匹配结果进行类型推导而报错。

When ghci can't infer the target type, we tell it what we'd like the type to be. If we want a result of type Bool, we'll get a pass/fail answer. 1 comment
当 ``ghci`` 无法推断目标的类型时，我们要告诉它想要哪种类型。若想知道正则匹配是否通过时，需要将结果类型指定为 ``Bool`` 型。

::

   ghci> "my left foot" =~ "foo" :: Bool
   Loading package array-0.1.0.0 ... linking ... done.
   Loading package containers-0.1.0.1 ... linking ... done.
   Loading package bytestring-0.9.0.1 ... linking ... done.
   Loading package mtl-1.1.0.0 ... linking ... done.
   Loading package regex-base-0.93.1 ... linking ... done.
   Loading package regex-posix-0.93.1 ... linking ... done.
   True
   ghci> "your right hand" =~ "bar" :: Bool
   False
   ghci> "your right hand" =~ "(hand|foot)" :: Bool
   True


